---
phase: 17-graphql-layer
plan: 02
type: execute
wave: 2
depends_on:
  - 17-01
files_modified:
  - src/lib/graphql/resolvers/queries.ts
  - src/generated/graphql.ts
  - src/generated/resolvers-types.ts
autonomous: true

must_haves:
  truths:
    - "Resolver returns flat list when includeChildren is false or undefined"
    - "Resolver returns root logs with children array when includeChildren is true"
    - "Children are fetched in single batch query (no N+1)"
    - "GraphQL codegen runs without errors"
    - "Generated hooks include parentJobId and includeChildren"
  artifacts:
    - path: "src/lib/graphql/resolvers/queries.ts"
      provides: "Tree assembly logic for enrichmentLogs"
      contains: "includeChildren"
    - path: "src/generated/graphql.ts"
      provides: "Generated hooks with new fields"
      contains: "parentJobId"
  key_links:
    - from: "src/lib/graphql/resolvers/queries.ts"
      to: "prisma.enrichmentLog"
      via: "database queries"
      pattern: "prisma.enrichmentLog.findMany"
    - from: "src/generated/graphql.ts"
      to: "src/graphql/schema.graphql"
      via: "codegen"
      pattern: "parentJobId"
---

<objective>
Implement tree fetching logic in enrichmentLogs resolver and regenerate GraphQL types.

Purpose: Enable parent-child tree assembly when clients request `includeChildren=true`.
Output: Updated resolver with tree logic, regenerated types with new fields.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/17-graphql-layer/17-RESEARCH.md
@.planning/phases/17-graphql-layer/17-01-SUMMARY.md

@src/lib/graphql/resolvers/queries.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update enrichmentLogs resolver with tree fetching</name>
  <files>src/lib/graphql/resolvers/queries.ts</files>
  <action>
Update the `enrichmentLogs` resolver to support tree fetching when `includeChildren=true`.

Replace the current enrichmentLogs resolver with:

```typescript
enrichmentLogs: async (_, args, { prisma }) => {
  try {
    const { includeChildren = false, ...filterArgs } = args;
    
    // Build where clause for filters
    const where: Record<string, unknown> = {};
    if (filterArgs.entityType) where.entityType = filterArgs.entityType;
    if (filterArgs.entityId) where.entityId = filterArgs.entityId;
    if (filterArgs.status) where.status = filterArgs.status;
    if (filterArgs.sources && filterArgs.sources.length > 0) {
      where.sources = { hasSome: filterArgs.sources };
    }

    // Simple flat fetch (default behavior)
    if (!includeChildren) {
      const logs = await prisma.enrichmentLog.findMany({
        where,
        orderBy: { createdAt: 'desc' },
        skip: filterArgs.skip || 0,
        take: filterArgs.limit || 50,
      });
      return logs.map(log => ({ ...log, children: null }));
    }

    // Tree fetch: get root logs only (parentJobId is null)
    const parentLogs = await prisma.enrichmentLog.findMany({
      where: {
        ...where,
        parentJobId: null,
      },
      orderBy: { createdAt: 'desc' },
      skip: filterArgs.skip || 0,
      take: filterArgs.limit || 50,
    });

    // Collect all parent jobIds for batch child fetch
    const parentJobIds = parentLogs
      .map(log => log.jobId)
      .filter((id): id is string => Boolean(id));

    // If no parents have jobIds, return with empty children
    if (parentJobIds.length === 0) {
      return parentLogs.map(log => ({ ...log, children: [] }));
    }

    // Batch fetch all children in single query
    const childLogs = await prisma.enrichmentLog.findMany({
      where: {
        parentJobId: { in: parentJobIds },
      },
      orderBy: { createdAt: 'asc' },
    });

    // Build children map for O(n) lookup
    const childrenMap = new Map<string, typeof childLogs>();
    for (const child of childLogs) {
      if (!child.parentJobId) continue;
      const siblings = childrenMap.get(child.parentJobId) || [];
      siblings.push(child);
      childrenMap.set(child.parentJobId, siblings);
    }

    // Attach children to parents
    return parentLogs.map(parent => ({
      ...parent,
      children: parent.jobId
        ? (childrenMap.get(parent.jobId) || []).map(child => ({
            ...child,
            children: null, // Leaf nodes have no children (one level only)
          }))
        : [],
    }));
  } catch (error) {
    throw new GraphQLError(`Failed to fetch enrichment logs: ${error}`);
  }
},
```

Key points:
- Default behavior unchanged (includeChildren defaults to false)
- Tree mode filters to `parentJobId: null` for root logs only
- Children fetched in single batch query using `{ in: parentJobIds }`
- Map used for O(n) child lookup, avoiding N+1
- Children returned with `children: null` (no grandchildren support)
  </action>
  <verify>grep -A 5 "includeChildren" src/lib/graphql/resolvers/queries.ts | head -10</verify>
  <done>Resolver handles includeChildren parameter with tree assembly logic</done>
</task>

<task type="auto">
  <name>Task 2: Run GraphQL codegen</name>
  <files>src/generated/graphql.ts, src/generated/resolvers-types.ts</files>
  <action>
Run GraphQL code generation to update types:

```bash
pnpm codegen
```

This will:
1. Parse updated schema.graphql (from Plan 01)
2. Parse updated enrichment.graphql client queries
3. Generate TypeScript types for EnrichmentLog with parentJobId and children
4. Generate useGetEnrichmentLogsQuery hook with includeChildren variable
5. Generate useGetEnrichmentLogsWithChildrenQuery hook

Verify codegen succeeds without errors. If there are schema validation errors, fix them in schema.graphql before proceeding.

Common issues to watch for:
- Missing imports in resolver (GraphQLError should already be imported)
- Type mismatch between resolver return and generated types (children: null vs undefined)
  </action>
  <verify>pnpm codegen && echo "Codegen successful"</verify>
  <done>Generated types include parentJobId, children, and includeChildren</done>
</task>

<task type="auto">
  <name>Task 3: Verify type safety and test query</name>
  <files>src/lib/graphql/resolvers/queries.ts</files>
  <action>
Run TypeScript type check to ensure resolver types match generated types:

```bash
pnpm type-check
```

If there are type errors in the resolver:
1. Check that `children` return type matches `EnrichmentLog[] | null`
2. Ensure all returned fields match the EnrichmentLog type
3. The generated types should have `children?: Maybe<Array<EnrichmentLog>>`

Common fixes if type errors occur:
- Import types from generated file if needed
- Ensure parentJobId is included in returned objects
- Ensure children is always present (null for flat, array for tree)

Also verify the resolver logic compiles correctly.
  </action>
  <verify>pnpm type-check 2>&1 | grep -E "(error|Error)" | head -5 || echo "No type errors"</verify>
  <done>Type checking passes, resolver is type-safe</done>
</task>

</tasks>

<verification>
1. `pnpm codegen` completes without errors
2. `pnpm type-check` passes without errors
3. `grep "parentJobId" src/generated/graphql.ts` shows field in generated types
4. `grep "includeChildren" src/generated/graphql.ts` shows parameter in generated hooks
5. `grep "GetEnrichmentLogsWithChildren" src/generated/graphql.ts` shows new hook
</verification>

<success_criteria>
- GQL-04 met: Resolver assembles parent-child tree when includeChildren=true
- Generated hooks include parentJobId field
- Generated hooks include includeChildren parameter
- New GetEnrichmentLogsWithChildrenQuery hook exists
- All type checks pass
- No N+1 queries (verified by single batch child fetch pattern)
</success_criteria>

<output>
After completion, create `.planning/phases/17-graphql-layer/17-02-SUMMARY.md`
</output>
