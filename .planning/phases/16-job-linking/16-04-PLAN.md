---
phase: 16-job-linking
plan: 04
type: execute
wave: 3
depends_on: ['16-02']
files_modified:
  - src/lib/queue/processors/discogs-processor.ts
autonomous: true

must_haves:
  truths:
    - 'DISCOGS_SEARCH_ARTIST creates EnrichmentLog entry with parentJobId'
    - 'DISCOGS_GET_ARTIST creates EnrichmentLog entry with parentJobId'
    - 'Discogs log entries capture comprehensive metadata'
    - 'Both success and failure cases are logged'
  artifacts:
    - path: 'src/lib/queue/processors/discogs-processor.ts'
      provides: 'Enrichment logging for discogs operations'
      contains: 'enrichmentLogger.logEnrichment'
  key_links:
    - from: 'handleDiscogsSearchArtist'
      to: 'enrichmentLogger.logEnrichment'
      via: 'SUCCESS/FAILED/NO_DATA_AVAILABLE status'
      pattern: 'logEnrichment'
    - from: 'handleDiscogsGetArtist'
      to: 'queue.addJob(CACHE_ARTIST_IMAGE)'
      via: 'parentJobId propagation'
      pattern: 'parentJobId: rootJobId'
---

<objective>
Add comprehensive EnrichmentLog entries to Discogs processor handlers and propagate parentJobId to child jobs.

Purpose: Discogs processors currently have NO logging. This plan adds full audit trail with metadata capture for timeline UI.
Output: Both discogs handlers create EnrichmentLog entries with comprehensive metadata.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-job-linking/16-02-SUMMARY.md
@.planning/phases/16-job-linking/16-RESEARCH.md

@src/lib/queue/processors/discogs-processor.ts
@src/lib/enrichment/enrichment-logger.ts
@src/lib/queue/jobs.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add logging to handleDiscogsSearchArtist</name>
  <files>src/lib/queue/processors/discogs-processor.ts</files>
  <action>
1. Import Job from bullmq and createEnrichmentLogger:
   import { Job } from 'bullmq';
   import { createEnrichmentLogger } from '../../enrichment/enrichment-logger';

2. Change function signature:
   export async function handleDiscogsSearchArtist(
   job: Job<DiscogsSearchArtistJobData>
   ): Promise<any>

3. At start of function:
   const data = job.data;
   const rootJobId = data.parentJobId || job.id;
   const startTime = Date.now();
   const enrichmentLogger = createEnrichmentLogger(prisma);

4. Log NO results case (after "No Discogs results found"):
   await enrichmentLogger.logEnrichment({
   entityType: 'ARTIST',
   entityId: data.artistId,
   operation: JOB_TYPES.DISCOGS_SEARCH_ARTIST,
   sources: ['DISCOGS'],
   status: 'NO_DATA_AVAILABLE',
   reason: 'No Discogs results found for artist',
   fieldsEnriched: [],
   durationMs: Date.now() - startTime,
   apiCallCount: 1,
   metadata: {
   searchQuery: data.artistName,
   resultsCount: 0,
   },
   jobId: job.id,
   parentJobId: data.parentJobId || null,
   isRootJob: !data.parentJobId,
   triggeredBy: 'system',
   });

5. Log NO confident match case (after "No confident match found"):
   await enrichmentLogger.logEnrichment({
   entityType: 'ARTIST',
   entityId: data.artistId,
   operation: JOB_TYPES.DISCOGS_SEARCH_ARTIST,
   sources: ['DISCOGS'],
   status: 'NO_DATA_AVAILABLE',
   reason: 'No confident match found (confidence < 85%)',
   fieldsEnriched: [],
   durationMs: Date.now() - startTime,
   apiCallCount: 1,
   metadata: {
   searchQuery: data.artistName,
   resultsCount: searchResults.results.length,
   },
   jobId: job.id,
   parentJobId: data.parentJobId || null,
   isRootJob: !data.parentJobId,
   triggeredBy: 'system',
   });

6. Update DISCOGS_GET_ARTIST job spawn to include parentJobId:
   await queue.addJob(
   JOB_TYPES.DISCOGS_GET_ARTIST,
   {
   artistId: data.artistId,
   discogsId: String(discogsId),
   requestId: data.requestId,
   parentJobId: rootJobId, // ADD THIS
   },
   ...
   );

7. Log SUCCESS after queuing fetch job:
   await enrichmentLogger.logEnrichment({
   entityType: 'ARTIST',
   entityId: data.artistId,
   operation: JOB_TYPES.DISCOGS_SEARCH_ARTIST,
   sources: ['DISCOGS'],
   status: 'SUCCESS',
   reason: 'Found Discogs artist match and queued fetch job',
   fieldsEnriched: ['discogsId'],
   dataQualityBefore: 'LOW',
   dataQualityAfter: 'MEDIUM',
   durationMs: Date.now() - startTime,
   apiCallCount: 1,
   metadata: {
   searchQuery: data.artistName,
   discogsId: String(discogsId),
   discogsTitle: bestMatch.result.title,
   matchConfidence: bestMatch.score,
   resultsCount: searchResults.results.length,
   },
   jobId: job.id,
   parentJobId: data.parentJobId || null,
   isRootJob: !data.parentJobId,
   triggeredBy: 'system',
   });

8. Wrap entire function in try-catch, log FAILED in catch block:
   await enrichmentLogger.logEnrichment({
   entityType: 'ARTIST',
   entityId: data.artistId,
   operation: JOB_TYPES.DISCOGS_SEARCH_ARTIST,
   sources: ['DISCOGS'],
   status: 'FAILED',
   reason: 'Discogs API error',
   fieldsEnriched: [],
   errorMessage: error instanceof Error ? error.message : 'Unknown error',
   errorCode: 'DISCOGS_API_ERROR',
   durationMs: Date.now() - startTime,
   apiCallCount: 1,
   metadata: { searchQuery: data.artistName },
   jobId: job.id,
   parentJobId: data.parentJobId || null,
   isRootJob: !data.parentJobId,
   triggeredBy: 'system',
   });
   </action>
   <verify>
9. handleDiscogsSearchArtist accepts Job<DiscogsSearchArtistJobData>
10. All 4 code paths log: no results, no match, success, failure
11. DISCOGS_GET_ARTIST job spawn includes parentJobId
    </verify>
    <done>DISCOGS_SEARCH_ARTIST logs all outcomes with metadata and propagates parentJobId</done>
    </task>

<task type="auto">
  <name>Task 2: Add logging to handleDiscogsGetArtist</name>
  <files>src/lib/queue/processors/discogs-processor.ts</files>
  <action>
1. Change function signature:
   export async function handleDiscogsGetArtist(
     job: Job<DiscogsGetArtistJobData>
   ): Promise<any>

2. At start of function:
   const data = job.data;
   const rootJobId = data.parentJobId || job.id;
   const startTime = Date.now();
   const enrichmentLogger = createEnrichmentLogger(prisma);

3. Log NO image case (after "No image found for Discogs artist"):
   await enrichmentLogger.logEnrichment({
   entityType: 'ARTIST',
   entityId: data.artistId,
   operation: JOB_TYPES.DISCOGS_GET_ARTIST,
   sources: ['DISCOGS'],
   status: 'PARTIAL_SUCCESS',
   reason: 'Discogs artist found but no image available',
   fieldsEnriched: [],
   durationMs: Date.now() - startTime,
   apiCallCount: 1,
   metadata: {
   discogsId: data.discogsId,
   imageFound: false,
   },
   jobId: job.id,
   parentJobId: data.parentJobId || null,
   isRootJob: !data.parentJobId,
   triggeredBy: 'system',
   });

4. Update CACHE_ARTIST_IMAGE job spawn to include parentJobId:
   const cacheJobData: CacheArtistImageJobData = {
   artistId: data.artistId,
   requestId: ...,
   parentJobId: rootJobId, // ADD THIS
   };

5. Log SUCCESS after updating artist and queuing cache:
   await enrichmentLogger.logEnrichment({
   entityType: 'ARTIST',
   entityId: data.artistId,
   operation: JOB_TYPES.DISCOGS_GET_ARTIST,
   sources: ['DISCOGS'],
   status: 'SUCCESS',
   reason: 'Fetched Discogs artist details and queued image caching',
   fieldsEnriched: ['imageUrl'],
   dataQualityBefore: 'LOW',
   dataQualityAfter: 'MEDIUM',
   durationMs: Date.now() - startTime,
   apiCallCount: 1,
   metadata: {
   discogsId: data.discogsId,
   imageUrl: discogsArtist.imageUrl,
   imageFound: true,
   },
   jobId: job.id,
   parentJobId: data.parentJobId || null,
   isRootJob: !data.parentJobId,
   triggeredBy: 'system',
   });

6. Wrap in try-catch, log FAILED in catch:
   await enrichmentLogger.logEnrichment({
   entityType: 'ARTIST',
   entityId: data.artistId,
   operation: JOB_TYPES.DISCOGS_GET_ARTIST,
   sources: ['DISCOGS'],
   status: 'FAILED',
   reason: 'Failed to fetch Discogs artist details',
   fieldsEnriched: [],
   errorMessage: error instanceof Error ? error.message : 'Unknown error',
   errorCode: 'DISCOGS_FETCH_ERROR',
   durationMs: Date.now() - startTime,
   apiCallCount: 1,
   metadata: { discogsId: data.discogsId },
   jobId: job.id,
   parentJobId: data.parentJobId || null,
   isRootJob: !data.parentJobId,
   triggeredBy: 'system',
   });
   </action>
   <verify>
7. handleDiscogsGetArtist accepts Job<DiscogsGetArtistJobData>
8. All 3 code paths log: no image, success, failure
9. CACHE_ARTIST_IMAGE job spawn includes parentJobId
   </verify>
   <done>DISCOGS_GET_ARTIST logs all outcomes with metadata and propagates parentJobId</done>
   </task>

</tasks>

<verification>
1. Both discogs handlers accept Job<T> parameter
2. handleDiscogsSearchArtist logs 4 outcomes: no results, no match, success, failure
3. handleDiscogsGetArtist logs 3 outcomes: no image, success, failure
4. DISCOGS_GET_ARTIST job receives parentJobId from search
5. CACHE_ARTIST_IMAGE job receives parentJobId from get
6. All log entries include comprehensive metadata
</verification>

<success_criteria>

- Requirements LINK-04 and LINK-05 satisfied
- Discogs handlers create EnrichmentLog entries for all outcomes
- Parent ID propagates through: DISCOGS_SEARCH -> DISCOGS_GET -> CACHE_ARTIST_IMAGE
- pnpm type-check passes
  </success_criteria>

<output>
After completion, create .planning/phases/16-job-linking/16-04-SUMMARY.md
</output>
