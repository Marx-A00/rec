---
phase: 16-job-linking
plan: 05
type: execute
wave: 3
depends_on: ["16-02"]
files_modified:
  - src/lib/queue/processors/cache-processor.ts
autonomous: true

must_haves:
  truths:
    - "CACHE_ARTIST_IMAGE creates EnrichmentLog entry with parentJobId"
    - "CACHE_ALBUM_COVER_ART creates EnrichmentLog entry with parentJobId"
    - "Cache log entries capture image metadata (URLs, size, format)"
    - "Both success and failure cases are logged"
  artifacts:
    - path: "src/lib/queue/processors/cache-processor.ts"
      provides: "Enrichment logging for cache operations"
      contains: "enrichmentLogger.logEnrichment"
  key_links:
    - from: "handleCacheArtistImage"
      to: "enrichmentLogger.logEnrichment"
      via: "SUCCESS/SKIPPED/FAILED status"
      pattern: "logEnrichment"
    - from: "handleCacheAlbumCoverArt"
      to: "enrichmentLogger.logEnrichment"
      via: "SUCCESS/SKIPPED/FAILED status"
      pattern: "logEnrichment"
---

<objective>
Add comprehensive EnrichmentLog entries to cache processor handlers with detailed image metadata.

Purpose: Cache processors currently have NO logging. This plan adds full audit trail with before/after URLs, Cloudflare IDs, and caching status.
Output: Both cache handlers create EnrichmentLog entries with comprehensive image metadata.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-job-linking/16-02-SUMMARY.md
@.planning/phases/16-job-linking/16-RESEARCH.md

@src/lib/queue/processors/cache-processor.ts
@src/lib/enrichment/enrichment-logger.ts
@src/lib/queue/jobs.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add logging to handleCacheArtistImage</name>
  <files>src/lib/queue/processors/cache-processor.ts</files>
  <action>
1. Add imports at top of file:
   import { Job } from 'bullmq';
   import { createEnrichmentLogger } from '../../enrichment/enrichment-logger';
   import { JOB_TYPES } from '../jobs';

2. Change function signature:
   export async function handleCacheArtistImage(
     job: Job<CacheArtistImageJobData>
   ): Promise<any>

3. At start of function (inside try block):
   const data = job.data;
   const { artistId } = data;
   const startTime = Date.now();
   const enrichmentLogger = createEnrichmentLogger(prisma);

4. After "Artist not found" error, before throw:
   await enrichmentLogger.logEnrichment({
     entityType: 'ARTIST',
     entityId: artistId,
     operation: JOB_TYPES.CACHE_ARTIST_IMAGE,
     sources: ['CLOUDFLARE'],
     status: 'FAILED',
     reason: 'Artist not found in database',
     fieldsEnriched: [],
     errorMessage: 'Artist not found',
     errorCode: 'ARTIST_NOT_FOUND',
     durationMs: Date.now() - startTime,
     apiCallCount: 0,
     metadata: { requestedArtistId: artistId },
     jobId: job.id,
     parentJobId: data.parentJobId || null,
     isRootJob: !data.parentJobId,
     triggeredBy: 'system',
   });

5. After "Already cached" return:
   await enrichmentLogger.logEnrichment({
     entityType: 'ARTIST',
     entityId: artistId,
     operation: JOB_TYPES.CACHE_ARTIST_IMAGE,
     sources: ['CLOUDFLARE'],
     status: 'SKIPPED',
     reason: 'Artist image already cached in Cloudflare',
     fieldsEnriched: [],
     durationMs: Date.now() - startTime,
     apiCallCount: 0,
     metadata: {
       artistName: artist.name,
       existingCloudflareImageId: artist.cloudflareImageId,
     },
     jobId: job.id,
     parentJobId: data.parentJobId || null,
     isRootJob: !data.parentJobId,
     triggeredBy: 'system',
   });

6. After "No image URL available" return:
   await enrichmentLogger.logEnrichment({
     entityType: 'ARTIST',
     entityId: artistId,
     operation: JOB_TYPES.CACHE_ARTIST_IMAGE,
     sources: ['CLOUDFLARE'],
     status: 'SKIPPED',
     reason: 'No source image URL available for artist',
     fieldsEnriched: [],
     durationMs: Date.now() - startTime,
     apiCallCount: 0,
     metadata: { artistName: artist.name },
     jobId: job.id,
     parentJobId: data.parentJobId || null,
     isRootJob: !data.parentJobId,
     triggeredBy: 'system',
   });

7. After "Failed to fetch image" (result is null):
   await enrichmentLogger.logEnrichment({
     entityType: 'ARTIST',
     entityId: artistId,
     operation: JOB_TYPES.CACHE_ARTIST_IMAGE,
     sources: ['CLOUDFLARE'],
     status: 'FAILED',
     reason: 'Failed to fetch image from source (404 or invalid URL)',
     fieldsEnriched: [],
     errorMessage: 'Image fetch failed',
     errorCode: 'IMAGE_FETCH_FAILED',
     durationMs: Date.now() - startTime,
     apiCallCount: 1,
     metadata: {
       artistName: artist.name,
       sourceUrl: artist.imageUrl,
     },
     jobId: job.id,
     parentJobId: data.parentJobId || null,
     isRootJob: !data.parentJobId,
     triggeredBy: 'system',
   });

8. After successful caching (before return):
   await enrichmentLogger.logEnrichment({
     entityType: 'ARTIST',
     entityId: artistId,
     operation: JOB_TYPES.CACHE_ARTIST_IMAGE,
     sources: ['CLOUDFLARE'],
     status: 'SUCCESS',
     reason: 'Successfully cached artist image to Cloudflare CDN',
     fieldsEnriched: ['cloudflareImageId'],
     dataQualityBefore: 'MEDIUM',
     dataQualityAfter: 'HIGH',
     durationMs: Date.now() - startTime,
     apiCallCount: 1,
     metadata: {
       artistName: artist.name,
       beforeUrl: artist.imageUrl,
       afterUrl: result.url,
       cloudflareImageId: result.id,
       cacheLocation: 'cloudflare_images',
     },
     jobId: job.id,
     parentJobId: data.parentJobId || null,
     isRootJob: !data.parentJobId,
     triggeredBy: 'system',
   });

9. In catch block, log failure:
   await enrichmentLogger.logEnrichment({
     entityType: 'ARTIST',
     entityId: artistId,
     operation: JOB_TYPES.CACHE_ARTIST_IMAGE,
     sources: ['CLOUDFLARE'],
     status: 'FAILED',
     reason: 'Unexpected error during caching operation',
     fieldsEnriched: [],
     errorMessage: errorMessage,
     errorCode: 'CACHE_ERROR',
     durationMs: Date.now() - startTime,
     apiCallCount: 1,
     metadata: { error: errorMessage },
     jobId: job.id,
     parentJobId: data.parentJobId || null,
     isRootJob: !data.parentJobId,
     triggeredBy: 'system',
   });
  </action>
  <verify>
1. handleCacheArtistImage accepts Job<CacheArtistImageJobData>
2. All 6 code paths log: not found, already cached, no URL, fetch failed, success, error
3. Metadata includes image URLs and Cloudflare IDs
  </verify>
  <done>CACHE_ARTIST_IMAGE logs all outcomes with comprehensive metadata</done>
</task>

<task type="auto">
  <name>Task 2: Add logging to handleCacheAlbumCoverArt</name>
  <files>src/lib/queue/processors/cache-processor.ts</files>
  <action>
1. Change function signature:
   export async function handleCacheAlbumCoverArt(
     job: Job<CacheAlbumCoverArtJobData>
   ): Promise<any>

2. At start of function (inside try block):
   const data = job.data;
   const { albumId } = data;
   const startTime = Date.now();
   const enrichmentLogger = createEnrichmentLogger(prisma);

3. After "Album not found" error, before throw:
   await enrichmentLogger.logEnrichment({
     entityType: 'ALBUM',
     entityId: albumId,
     operation: JOB_TYPES.CACHE_ALBUM_COVER_ART,
     sources: ['CLOUDFLARE'],
     status: 'FAILED',
     reason: 'Album not found in database',
     fieldsEnriched: [],
     errorMessage: 'Album not found',
     errorCode: 'ALBUM_NOT_FOUND',
     durationMs: Date.now() - startTime,
     apiCallCount: 0,
     metadata: { requestedAlbumId: albumId },
     jobId: job.id,
     parentJobId: data.parentJobId || null,
     isRootJob: !data.parentJobId,
     triggeredBy: 'system',
   });

4. After "Already cached" return:
   await enrichmentLogger.logEnrichment({
     entityType: 'ALBUM',
     entityId: albumId,
     operation: JOB_TYPES.CACHE_ALBUM_COVER_ART,
     sources: ['CLOUDFLARE'],
     status: 'SKIPPED',
     reason: 'Album cover art already cached in Cloudflare',
     fieldsEnriched: [],
     durationMs: Date.now() - startTime,
     apiCallCount: 0,
     metadata: {
       albumTitle: album.title,
       existingCloudflareImageId: album.cloudflareImageId,
     },
     jobId: job.id,
     parentJobId: data.parentJobId || null,
     isRootJob: !data.parentJobId,
     triggeredBy: 'system',
   });

5. After "No cover art URL" return:
   await enrichmentLogger.logEnrichment({
     entityType: 'ALBUM',
     entityId: albumId,
     operation: JOB_TYPES.CACHE_ALBUM_COVER_ART,
     sources: ['CLOUDFLARE'],
     status: 'SKIPPED',
     reason: 'No source cover art URL available for album',
     fieldsEnriched: [],
     durationMs: Date.now() - startTime,
     apiCallCount: 0,
     metadata: { albumTitle: album.title },
     jobId: job.id,
     parentJobId: data.parentJobId || null,
     isRootJob: !data.parentJobId,
     triggeredBy: 'system',
   });

6. After "Failed to fetch image" (result is null):
   await enrichmentLogger.logEnrichment({
     entityType: 'ALBUM',
     entityId: albumId,
     operation: JOB_TYPES.CACHE_ALBUM_COVER_ART,
     sources: ['CLOUDFLARE'],
     status: 'FAILED',
     reason: 'Failed to fetch cover art from source (404 or invalid URL)',
     fieldsEnriched: [],
     errorMessage: 'Cover art fetch failed',
     errorCode: 'IMAGE_FETCH_FAILED',
     durationMs: Date.now() - startTime,
     apiCallCount: 1,
     metadata: {
       albumTitle: album.title,
       sourceUrl: album.coverArtUrl,
     },
     jobId: job.id,
     parentJobId: data.parentJobId || null,
     isRootJob: !data.parentJobId,
     triggeredBy: 'system',
   });

7. After successful caching (before return):
   await enrichmentLogger.logEnrichment({
     entityType: 'ALBUM',
     entityId: albumId,
     operation: JOB_TYPES.CACHE_ALBUM_COVER_ART,
     sources: ['CLOUDFLARE'],
     status: 'SUCCESS',
     reason: 'Successfully cached album cover art to Cloudflare CDN',
     fieldsEnriched: ['cloudflareImageId'],
     dataQualityBefore: 'MEDIUM',
     dataQualityAfter: 'HIGH',
     durationMs: Date.now() - startTime,
     apiCallCount: 1,
     metadata: {
       albumTitle: album.title,
       beforeUrl: album.coverArtUrl,
       afterUrl: result.url,
       cloudflareImageId: result.id,
       cacheLocation: 'cloudflare_images',
     },
     jobId: job.id,
     parentJobId: data.parentJobId || null,
     isRootJob: !data.parentJobId,
     triggeredBy: 'system',
   });

8. In catch block, log failure:
   await enrichmentLogger.logEnrichment({
     entityType: 'ALBUM',
     entityId: albumId,
     operation: JOB_TYPES.CACHE_ALBUM_COVER_ART,
     sources: ['CLOUDFLARE'],
     status: 'FAILED',
     reason: 'Unexpected error during caching operation',
     fieldsEnriched: [],
     errorMessage: errorMessage,
     errorCode: 'CACHE_ERROR',
     durationMs: Date.now() - startTime,
     apiCallCount: 1,
     metadata: { error: errorMessage },
     jobId: job.id,
     parentJobId: data.parentJobId || null,
     isRootJob: !data.parentJobId,
     triggeredBy: 'system',
   });
  </action>
  <verify>
1. handleCacheAlbumCoverArt accepts Job<CacheAlbumCoverArtJobData>
2. All 6 code paths log: not found, already cached, no URL, fetch failed, success, error
3. Metadata includes album title and image URLs
  </verify>
  <done>CACHE_ALBUM_COVER_ART logs all outcomes with comprehensive metadata</done>
</task>

</tasks>

<verification>
1. Both cache handlers accept Job<T> parameter
2. handleCacheArtistImage logs 6 outcomes
3. handleCacheAlbumCoverArt logs 6 outcomes
4. All log entries include parentJobId and isRootJob
5. Metadata captures before/after URLs, Cloudflare IDs, entity names
6. pnpm type-check passes
</verification>

<success_criteria>
- Requirements LINK-06 and LINK-07 satisfied
- Cache handlers create EnrichmentLog entries for all outcomes
- Metadata includes comprehensive image info for timeline UI
- pnpm type-check passes
</success_criteria>

<output>
After completion, create .planning/phases/16-job-linking/16-05-SUMMARY.md
</output>
