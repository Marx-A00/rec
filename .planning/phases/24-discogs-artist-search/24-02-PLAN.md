---
phase: 24-discogs-artist-search
plan: 02
type: execute
wave: 2
depends_on: ['24-01']
files_modified:
  - src/graphql/schema.graphql
  - src/lib/graphql/resolvers/queries.ts
  - src/graphql/queries/artistCorrection.graphql
  - src/generated/graphql.ts
autonomous: true

must_haves:
  truths:
    - 'artistCorrectionSearch GraphQL query accepts source parameter'
    - 'Resolver routes to QueuedDiscogsService when source is DISCOGS'
    - 'Discogs results return same GraphQL shape as MusicBrainz results'
  artifacts:
    - path: 'src/graphql/schema.graphql'
      provides: 'source parameter on artistCorrectionSearch'
      contains: 'source: CorrectionSource'
    - path: 'src/lib/graphql/resolvers/queries.ts'
      provides: 'Source-aware routing in artistCorrectionSearch resolver'
      contains: 'getQueuedDiscogsService'
    - path: 'src/graphql/queries/artistCorrection.graphql'
      provides: 'source variable in client query'
      contains: '$source: CorrectionSource'
  key_links:
    - from: 'src/lib/graphql/resolvers/queries.ts'
      to: 'src/lib/discogs/queued-service.ts'
      via: 'getQueuedDiscogsService import'
      pattern: 'getQueuedDiscogsService.*searchArtists'
    - from: 'src/graphql/queries/artistCorrection.graphql'
      to: 'src/graphql/schema.graphql'
      via: 'CorrectionSource type usage'
      pattern: 'source:'
---

<objective>
Extend GraphQL layer to support Discogs as artist correction source.

Purpose: Allow frontend to request Discogs artist search via existing artistCorrectionSearch query.
Output: GraphQL schema with source parameter, resolver routing to QueuedDiscogsService.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/24-discogs-artist-search/24-CONTEXT.md
@.planning/phases/24-discogs-artist-search/24-01-SUMMARY.md

<!-- Existing GraphQL patterns -->
@src/graphql/schema.graphql
@src/lib/graphql/resolvers/queries.ts
@src/graphql/queries/artistCorrection.graphql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add source parameter and field to artistCorrectionSearch schema</name>
  <files>
    src/graphql/schema.graphql
  </files>
  <action>
1. Find the artistCorrectionSearch query definition in schema.graphql (around line 2670):
   ```graphql
   artistCorrectionSearch(
     query: String!
     limit: Int
   ): ArtistCorrectionSearchResponse!
   ```

2. Add source parameter with default:
   ```graphql
   """
   Search MusicBrainz or Discogs for artist correction candidates
   """
   artistCorrectionSearch(
     query: String!
     limit: Int
     """
     Data source to search (default: MUSICBRAINZ)
     """
     source: CorrectionSource = MUSICBRAINZ
   ): ArtistCorrectionSearchResponse!
   ```

3. The CorrectionSource enum already exists from Phase 22 (album search):
   ```graphql
   enum CorrectionSource {
     MUSICBRAINZ
     DISCOGS
   }
   ```

4. **CRITICAL:** Add source field to ArtistCorrectionSearchResult type. Find the type definition (around line 2700) and add after topReleases:
   ```graphql
   type ArtistCorrectionSearchResult {
     artistMbid: String!
     name: String!
     sortName: String
     disambiguation: String
     type: String
     country: String
     area: String
     beginDate: String
     endDate: String
     ended: Boolean
     gender: String
     mbScore: Int
     topReleases: [ArtistTopRelease!]
     """
     Data source this result came from (musicbrainz or discogs)
     """
     source: String
   }
   ```

   This source field is REQUIRED for frontend visual distinction (orange accent for Discogs).
  </action>
  <verify>
Schema validates: `pnpm codegen` succeeds
Source field exists: `grep -q "source: String" src/graphql/schema.graphql`
  </verify>
  <done>
artistCorrectionSearch query accepts source parameter AND ArtistCorrectionSearchResult type includes source field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update resolver to route by source</name>
  <files>
    src/lib/graphql/resolvers/queries.ts
  </files>
  <action>
1. The import for getQueuedDiscogsService should already exist from album search. Verify it's present:
   ```typescript
   import { getQueuedDiscogsService } from '@/lib/discogs/queued-service';
   ```

2. Find the artistCorrectionSearch resolver (around line 2868). Update the function signature to accept source:

   ```typescript
   artistCorrectionSearch: async (_, { query, limit, source }, { user }) => {
   ```

3. Add source-based routing AFTER the authorization checks, BEFORE the existing MusicBrainz search:

   ```typescript
   // Route to Discogs if source is DISCOGS
   if (source === GqlCorrectionSource.Discogs) {
     const queuedDiscogsService = getQueuedDiscogsService();
     const response = await queuedDiscogsService.searchArtists({
       artistName: query,
       limit: limit ?? 10,
     });

     return {
       results: response.results.map(result => ({
         artistMbid: result.artistMbid,
         name: result.name,
         sortName: result.sortName,
         disambiguation: result.disambiguation ?? null,
         type: result.type ?? null,
         country: result.country ?? null,
         area: result.area ?? null,
         beginDate: result.beginDate ?? null,
         endDate: result.endDate ?? null,
         ended: result.ended ?? null,
         gender: result.gender ?? null,
         mbScore: result.mbScore,
         topReleases: result.topReleases ?? null,
         source: result.source ?? 'discogs',
       })),
       hasMore: false, // Discogs search doesn't support pagination
       query,
     };
   }

   // Existing MusicBrainz logic continues below...
   ```

4. Add source field to MusicBrainz results mapping (after the existing mapping):
   ```typescript
   // In existing results.map() for MusicBrainz:
   source: 'musicbrainz',
   ```
  </action>
  <verify>
TypeScript compiles: `pnpm type-check`
  </verify>
  <done>
Resolver routes to QueuedDiscogsService.searchArtists() when source is DISCOGS.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update client query and regenerate types</name>
  <files>
    src/graphql/queries/artistCorrection.graphql
    src/generated/graphql.ts
  </files>
  <action>
1. Update the SearchArtistCorrectionCandidates query in artistCorrection.graphql to include source:

   ```graphql
   query SearchArtistCorrectionCandidates(
     $query: String!
     $limit: Int
     $source: CorrectionSource
   ) {
     artistCorrectionSearch(query: $query, limit: $limit, source: $source) {
       results {
         artistMbid
         name
         sortName
         disambiguation
         type
         country
         area
         beginDate
         endDate
         ended
         gender
         mbScore
         topReleases {
           title
           year
           type
         }
         source
       }
       hasMore
       query
     }
   }
   ```

2. Run codegen to regenerate types:
   ```bash
   pnpm codegen
   ```

3. Verify generated types include:
   - source parameter in useSearchArtistCorrectionCandidatesQuery variables
   - source field in ArtistCorrectionSearchResult type
  </action>
  <verify>
`pnpm codegen` completes successfully
`grep -q "source" src/graphql/queries/artistCorrection.graphql` returns 0
  </verify>
  <done>
GraphQL types regenerated with source parameter available for frontend use.
  </done>
</task>

</tasks>

<verification>
1. `pnpm codegen` succeeds without errors
2. `pnpm type-check` passes
3. artistCorrectionSearch query has source parameter in schema
4. Resolver has conditional branch for source === DISCOGS
5. Resolver calls queuedDiscogsService.searchArtists
6. Client query includes source variable
</verification>

<success_criteria>
- GraphQL schema accepts source parameter on artistCorrectionSearch
- Resolver routes to QueuedDiscogsService for DISCOGS source
- Discogs results match ArtistCorrectionSearchResult shape
- All generated types compile
</success_criteria>

<output>
After completion, create `.planning/phases/24-discogs-artist-search/24-02-SUMMARY.md`
</output>
