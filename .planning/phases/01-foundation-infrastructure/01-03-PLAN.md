---
phase: 01-foundation-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/musicbrainz/errors.ts
  - src/lib/musicbrainz/index.ts
  - src/lib/queue/processors/musicbrainz-processor.ts
autonomous: true

must_haves:
  truths:
    - "API errors are categorized (rate limit, not found, network, unknown)"
    - "Error responses include retry guidance"
    - "Queue statistics include position information for debugging"
  artifacts:
    - path: "src/lib/musicbrainz/errors.ts"
      provides: "Structured error types for MusicBrainz API failures"
      contains: "MusicBrainzError"
    - path: "src/lib/musicbrainz/queue-service.ts"
      provides: "Queue position observable via getQueuePosition method"
      contains: "getQueuePosition"
  key_links:
    - from: "src/lib/queue/processors/musicbrainz-processor.ts"
      to: "src/lib/musicbrainz/errors.ts"
      via: "import error types"
      pattern: "import.*MusicBrainz.*Error.*from"
---

<objective>
Establish structured error handling patterns for MusicBrainz API failures and add queue position observability.

Purpose: Admin correction workflow needs clear error feedback (why a search failed, when to retry) and queue visibility for debugging slow responses.
Output: Enhanced errors.ts with categorized errors, queue position method, improved error handling in processors.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md

# Depends on Plan 01 for priority tiers (uses PRIORITY_TIERS in queue inspection)
@src/lib/musicbrainz/errors.ts
@src/lib/musicbrainz/queue-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance errors.ts with structured error types</name>
  <files>src/lib/musicbrainz/errors.ts, src/lib/musicbrainz/index.ts</files>
  <action>
Update src/lib/musicbrainz/errors.ts to add structured error types.

First, check what already exists in errors.ts and extend it. Add:

```typescript
/**
 * Error categories for MusicBrainz API failures
 */
export type MusicBrainzErrorCode = 
  | 'RATE_LIMITED'      // 503 or 429 - too many requests
  | 'NOT_FOUND'         // 404 - MBID doesn't exist
  | 'INVALID_MBID'      // 400 - malformed MBID
  | 'NETWORK_ERROR'     // Connection failed
  | 'TIMEOUT'           // Request timed out
  | 'SERVICE_ERROR'     // 5xx server error (not rate limit)
  | 'UNKNOWN';          // Unclassified error

/**
 * Structured MusicBrainz API error
 */
export class MusicBrainzApiError extends Error {
  constructor(
    message: string,
    public readonly code: MusicBrainzErrorCode,
    public readonly statusCode?: number,
    public readonly retryable: boolean = false,
    public readonly retryAfterMs?: number
  ) {
    super(message);
    this.name = 'MusicBrainzApiError';
  }

  /**
   * Create error from HTTP response status
   */
  static fromStatus(status: number, message?: string): MusicBrainzApiError {
    switch (status) {
      case 400:
        return new MusicBrainzApiError(
          message || 'Invalid request (possibly malformed MBID)',
          'INVALID_MBID',
          status,
          false
        );
      case 404:
        return new MusicBrainzApiError(
          message || 'Entity not found',
          'NOT_FOUND',
          status,
          false
        );
      case 429:
      case 503:
        return new MusicBrainzApiError(
          message || 'Rate limited - too many requests',
          'RATE_LIMITED',
          status,
          true,
          5000 // Suggest 5 second wait
        );
      case 500:
      case 502:
      case 504:
        return new MusicBrainzApiError(
          message || 'MusicBrainz service error',
          'SERVICE_ERROR',
          status,
          true,
          10000 // Suggest 10 second wait
        );
      default:
        return new MusicBrainzApiError(
          message || `HTTP error ${status}`,
          'UNKNOWN',
          status,
          status >= 500
        );
    }
  }

  /**
   * Create error from network/timeout issues
   */
  static networkError(message: string): MusicBrainzApiError {
    return new MusicBrainzApiError(
      message,
      'NETWORK_ERROR',
      undefined,
      true,
      3000
    );
  }

  static timeout(message: string = 'Request timed out'): MusicBrainzApiError {
    return new MusicBrainzApiError(
      message,
      'TIMEOUT',
      undefined,
      true,
      5000
    );
  }
}

/**
 * Type guard to check if error is MusicBrainzApiError
 */
export function isMusicBrainzApiError(error: unknown): error is MusicBrainzApiError {
  return error instanceof MusicBrainzApiError;
}
```

Export these from src/lib/musicbrainz/index.ts:
```typescript
export { 
  MusicBrainzApiError, 
  isMusicBrainzApiError,
  type MusicBrainzErrorCode 
} from './errors';
```

If errors.ts already has content, add these new exports WITHOUT removing existing code.
  </action>
  <verify>
Run `pnpm type-check` to verify no type errors.
File src/lib/musicbrainz/errors.ts contains MusicBrainzApiError class.
Exports available from src/lib/musicbrainz/index.ts.
  </verify>
  <done>
MusicBrainzApiError class exists with code, statusCode, retryable, retryAfterMs properties.
Factory methods (fromStatus, networkError, timeout) create appropriate error types.
Type guard isMusicBrainzApiError available for error handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add queue position observability to queue-service.ts</name>
  <files>src/lib/musicbrainz/queue-service.ts</files>
  <action>
Add a method to QueuedMusicBrainzService for observing queue position.

Add this method to the class:

```typescript
/**
 * Get current queue position for a specific job
 * Useful for showing "Your request is #3 in queue" in UI
 */
async getQueuePosition(jobId: string): Promise<{
  position: number;
  waitingCount: number;
  activeCount: number;
  estimatedWaitMs: number;
} | null> {
  try {
    const waiting = await this.queue.getQueue().getWaiting();
    const active = await this.queue.getQueue().getActive();
    
    const position = waiting.findIndex(job => job.id === jobId);
    
    if (position === -1) {
      // Job not in waiting queue - might be active or completed
      const isActive = active.some(job => job.id === jobId);
      if (isActive) {
        return {
          position: 0, // Currently processing
          waitingCount: waiting.length,
          activeCount: active.length,
          estimatedWaitMs: 0,
        };
      }
      return null; // Job not found
    }
    
    // Position is 1-indexed for user display
    // Estimated wait = position * 1000ms (1 req/sec rate limit)
    return {
      position: position + 1,
      waitingCount: waiting.length,
      activeCount: active.length,
      estimatedWaitMs: (position + 1) * 1000,
    };
  } catch (error) {
    console.error('Failed to get queue position:', error);
    return null;
  }
}

/**
 * Get summary of queue state by priority tier
 * Useful for admin dashboard monitoring
 */
async getQueueSummary(): Promise<{
  byPriority: Record<number, number>;
  total: number;
  oldestJobAge: number | null;
}> {
  const waiting = await this.queue.getQueue().getWaiting();
  
  const byPriority: Record<number, number> = {};
  let oldestTimestamp: number | null = null;
  
  for (const job of waiting) {
    const priority = job.opts?.priority ?? 0;
    byPriority[priority] = (byPriority[priority] || 0) + 1;
    
    if (job.timestamp && (!oldestTimestamp || job.timestamp < oldestTimestamp)) {
      oldestTimestamp = job.timestamp;
    }
  }
  
  return {
    byPriority,
    total: waiting.length,
    oldestJobAge: oldestTimestamp ? Date.now() - oldestTimestamp : null,
  };
}
```

These methods allow:
- UI to show "Your search is #3 in queue, ~3 seconds remaining"
- Admin dashboard to see queue breakdown by priority tier
- Debugging slow responses by inspecting queue state
  </action>
  <verify>
Run `pnpm type-check` to verify no type errors.
Run `pnpm lint` to check for style issues.
Grep for "getQueuePosition" in queue-service.ts to confirm method exists.
  </verify>
  <done>
getQueuePosition method returns position, counts, and estimated wait time.
getQueueSummary method returns breakdown by priority tier.
Both methods handle errors gracefully (return null or empty data).
  </done>
</task>

<task type="auto">
  <name>Task 3: Use structured errors in processor error handling</name>
  <files>src/lib/queue/processors/musicbrainz-processor.ts</files>
  <action>
Update the main processor function to use structured error types.

1. Add import at top (if not already present):
```typescript
import { MusicBrainzApiError, isMusicBrainzApiError } from '../../musicbrainz';
```

2. Find the main `processMusicBrainzJob` function (or wherever errors are caught) and enhance error handling:

When catching errors, convert them to structured format:
```typescript
catch (error) {
  // Convert to structured error if not already
  let apiError: MusicBrainzApiError;
  
  if (isMusicBrainzApiError(error)) {
    apiError = error;
  } else if (error instanceof Error) {
    // Check for common error patterns
    const message = error.message.toLowerCase();
    if (message.includes('timeout') || message.includes('timed out')) {
      apiError = MusicBrainzApiError.timeout(error.message);
    } else if (message.includes('network') || message.includes('econnrefused') || message.includes('fetch failed')) {
      apiError = MusicBrainzApiError.networkError(error.message);
    } else {
      apiError = new MusicBrainzApiError(error.message, 'UNKNOWN', undefined, false);
    }
  } else {
    apiError = new MusicBrainzApiError(String(error), 'UNKNOWN', undefined, false);
  }
  
  return {
    success: false,
    error: {
      message: apiError.message,
      code: apiError.code,
      retryable: apiError.retryable,
      retryAfterMs: apiError.retryAfterMs,
    },
  };
}
```

This ensures all job results have consistent error structure that the UI can interpret.

Do NOT modify individual handlers - just the main processor's error handling wrapper.
  </action>
  <verify>
Run `pnpm type-check` to verify no type errors.
Run `pnpm lint` to check for style issues.
Grep for "MusicBrainzApiError" in musicbrainz-processor.ts to confirm usage.
  </verify>
  <done>
Processor converts all errors to MusicBrainzApiError format.
Job results include error.code and error.retryable for UI interpretation.
Error patterns (timeout, network) are detected and categorized.
  </done>
</task>

</tasks>

<verification>
1. `pnpm type-check` passes with no errors
2. `pnpm lint` passes with no errors
3. MusicBrainzApiError class with factory methods exists
4. getQueuePosition and getQueueSummary methods exist in queue-service
5. Processor error handling uses structured error types
</verification>

<success_criteria>
- MusicBrainzApiError categorizes errors by code (RATE_LIMITED, NOT_FOUND, etc.)
- Errors include retryable flag and suggested retry delay
- Queue position observable for debugging slow responses
- Queue summary shows breakdown by priority tier
- All job errors have consistent structure for UI interpretation
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-03-SUMMARY.md`
</output>
