---
phase: 23-discogs-album-apply
plan: 03
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - src/graphql/schema.graphql
  - src/lib/graphql/resolvers/queries.ts
  - src/lib/graphql/resolvers/mutations.ts
  - src/graphql/queries/correction.graphql
autonomous: true

must_haves:
  truths:
    - "CorrectionPreviewInput has source field in GraphQL schema"
    - "correctionPreview resolver routes Discogs source to Discogs fetch path"
    - "applyCorrection works correctly with Discogs source previews"
    - "Frontend can pass source parameter when calling correctionPreview"
  artifacts:
    - path: "src/graphql/schema.graphql"
      provides: "source field on CorrectionPreviewInput"
      contains: "source: CorrectionSource"
    - path: "src/lib/graphql/resolvers/queries.ts"
      provides: "Source-aware correctionPreview resolver"
      contains: "getQueuedDiscogsService"
    - path: "src/graphql/queries/correction.graphql"
      provides: "Updated query with source parameter"
      contains: "source"
  key_links:
    - from: "src/lib/graphql/resolvers/queries.ts"
      to: "src/lib/correction/preview/preview-service.ts"
      via: "passes source to generatePreview"
      pattern: "generatePreview.*source"
    - from: "src/lib/graphql/resolvers/queries.ts"
      to: "src/lib/discogs/queued-service.ts"
      via: "calls getMaster for Discogs source"
      pattern: "getMaster"
---

<objective>
Extend GraphQL layer for Discogs correction previews.

Purpose: Enable the frontend to request correction previews from Discogs source. The resolver routes requests to the appropriate service based on the source parameter.

Output: GraphQL schema, queries, and resolvers support source parameter for correction previews.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-discogs-album-apply/23-RESEARCH.md
@.planning/phases/23-discogs-album-apply/23-CONTEXT.md
@.planning/phases/23-discogs-album-apply/23-01-SUMMARY.md

@src/graphql/schema.graphql
@src/lib/graphql/resolvers/queries.ts
@src/lib/graphql/resolvers/mutations.ts
@src/graphql/queries/correction.graphql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add source field to CorrectionPreviewInput in GraphQL schema</name>
  <files>src/graphql/schema.graphql</files>
  <action>
Find the CorrectionPreviewInput definition and add source field:

"""
Input for correction preview operation.
"""
input CorrectionPreviewInput {
  """
  Album ID to preview corrections for
  """
  albumId: UUID!
  """
  Selected release group MBID from search results (or Discogs master ID for Discogs source)
  """
  releaseGroupMbid: String!
  """
  Data source (default: MUSICBRAINZ)
  """
  source: CorrectionSource = MUSICBRAINZ
}

The CorrectionSource enum already exists (added in Phase 22):
enum CorrectionSource {
  MUSICBRAINZ
  DISCOGS
}

If it doesn't exist, add it before CorrectionPreviewInput.
  </action>
  <verify>pnpm codegen runs successfully</verify>
  <done>CorrectionPreviewInput has source field with default MUSICBRAINZ</done>
</task>

<task type="auto">
  <name>Task 2: Update correctionPreview resolver for Discogs source</name>
  <files>src/lib/graphql/resolvers/queries.ts</files>
  <action>
Find the correctionPreview resolver and update it to handle Discogs source.

1. Add import for Discogs service near other correction imports:
import { getQueuedDiscogsService } from '@/lib/discogs/queued-service';
import { mapMasterToCorrectionSearchResult } from '@/lib/discogs/mappers';

2. Update the resolver to extract and use source:

correctionPreview: async (_, { input }, { user, prisma }) => {
  // ... existing auth checks ...

  try {
    const { albumId, releaseGroupMbid, source } = input;
    const correctionSource = source?.toLowerCase() || 'musicbrainz';

    // Get album with tracks (existing code)
    const album = await prisma.album.findUnique({
      where: { id: albumId },
      include: {
        tracks: { orderBy: [{ discNumber: 'asc' }, { trackNumber: 'asc' }] },
        artists: { include: { artist: true }, orderBy: { position: 'asc' } },
      },
    });

    if (!album) {
      throw new GraphQLError('Album not found: ' + albumId, {
        extensions: { code: 'NOT_FOUND' },
      });
    }

    // Fetch source result based on correction source
    let scoredResult;
    if (correctionSource === 'discogs') {
      // Discogs path: fetch master and map to search result format
      const discogsService = getQueuedDiscogsService();
      const master = await discogsService.getMaster(releaseGroupMbid, PRIORITY_TIERS.ADMIN);
      scoredResult = mapMasterToCorrectionSearchResult(master);
    } else {
      // MusicBrainz path (existing code)
      const searchService = getCorrectionSearchService();
      try {
        scoredResult = await searchService.getByMbid(releaseGroupMbid);
      } catch (error) {
        throw new GraphQLError('Release group not found: ' + releaseGroupMbid, {
          extensions: { code: 'NOT_FOUND' },
        });
      }
    }

    const releaseMbid = releaseGroupMbid;

    // Generate preview with source parameter
    const previewService = getCorrectionPreviewService();
    const preview = await previewService.generatePreview(
      albumId,
      scoredResult,
      releaseMbid,
      correctionSource as 'musicbrainz' | 'discogs'
    );

    // Transform to GraphQL format (existing code)
    return {
      albumId: albumId,
      albumTitle: album.title,
      albumUpdatedAt: album.updatedAt,
      sourceResult: transformScoredResult(scoredResult),
      mbReleaseData: preview.mbReleaseData
        ? transformMBReleaseData(preview.mbReleaseData)
        : null,
      fieldDiffs: preview.fieldDiffs,
      artistDiff: { ... },  // existing
      trackDiffs: preview.trackDiffs || [],
      trackSummary: { ... },  // existing
      coverArt: { ... },  // existing
      summary: { ... },  // existing
    };
  } catch (error) {
    // ... existing error handling ...
  }
},

Make sure PRIORITY_TIERS is imported from '@/lib/queue'.
  </action>
  <verify>pnpm type-check passes</verify>
  <done>correctionPreview resolver routes Discogs source to getMaster and uses source in generatePreview</done>
</task>

<task type="auto">
  <name>Task 3: Update correction.graphql query and regenerate types</name>
  <files>src/graphql/queries/correction.graphql</files>
  <action>
Find the CORRECTION_PREVIEW query (or similar) and add source parameter.

Look for a query like:
query CorrectionPreview($input: CorrectionPreviewInput!) {
  correctionPreview(input: $input) {
    ...
  }
}

The input type CorrectionPreviewInput already has source as optional field with default.
No changes needed to the query itself since source is optional.

However, verify that the CorrectionSearchResult type in schema has the source field that mapMasterToCorrectionSearchResult adds:

Find CorrectionSearchResult type in schema.graphql and ensure it has:
"""
Data source for this result
"""
source: String

If source field is missing from CorrectionSearchResult, add it.

Then run codegen:
pnpm codegen

This regenerates the TypeScript types to include the source parameter.
  </action>
  <verify>
1. pnpm codegen runs without errors
2. Generated types include source parameter in CorrectionPreviewInput
3. pnpm type-check passes
  </verify>
  <done>GraphQL types regenerated with source support, frontend can pass source parameter</done>
</task>

</tasks>

<verification>
- [ ] pnpm codegen runs successfully
- [ ] pnpm type-check passes
- [ ] CorrectionPreviewInput has source field in generated types
- [ ] Resolver imports Discogs service
- [ ] Resolver conditionally fetches from Discogs when source is DISCOGS
- [ ] Preview generated with correct source parameter
</verification>

<success_criteria>
GraphQL layer supports Discogs correction previews:
- Schema has source field on CorrectionPreviewInput
- Resolver routes to appropriate data source
- Frontend can request Discogs previews by passing source: DISCOGS
- Types are regenerated and type-safe
</success_criteria>

<output>
After completion, create .planning/phases/23-discogs-album-apply/23-03-SUMMARY.md
</output>
