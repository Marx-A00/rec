---
phase: 23-discogs-album-apply
plan: 04
type: execute
wave: 1
depends_on: ["23-01", "23-02", "23-03"]
files_modified:
  - src/components/admin/correction/preview/PreviewView.tsx
  - src/graphql/schema.graphql
  - src/graphql/mutations/correctionApply.graphql
  - src/lib/graphql/resolvers/mutations.ts
  - src/components/admin/correction/CorrectionModal.tsx
  - src/generated/graphql.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Preview query includes source parameter from store"
    - "Apply mutation includes source parameter in input"
    - "Apply resolver routes to Discogs fetch when source is DISCOGS"
    - "Discogs corrections apply end-to-end"
  artifacts:
    - path: "src/components/admin/correction/preview/PreviewView.tsx"
      provides: "Source-aware preview query"
      contains: "source: correctionSource"
    - path: "src/graphql/schema.graphql"
      provides: "CorrectionApplyInput with source field"
      contains: "source: CorrectionSource"
    - path: "src/lib/graphql/resolvers/mutations.ts"
      provides: "Discogs-aware correctionApply resolver"
      contains: "getQueuedDiscogsService"
  key_links:
    - from: "src/components/admin/correction/preview/PreviewView.tsx"
      to: "correctionPreview query"
      via: "source field in input"
      pattern: 'source:.*correctionSource'
    - from: "src/components/admin/correction/CorrectionModal.tsx"
      to: "correctionApply mutation"
      via: "source field in input"
      pattern: 'source:.*correctionSource'
    - from: "src/lib/graphql/resolvers/mutations.ts"
      to: "QueuedDiscogsService"
      via: "conditional fetch"
      pattern: "source.*discogs.*getMaster|getMaster.*source.*discogs"
---

<objective>
Close two critical wiring gaps preventing Discogs corrections from working end-to-end.

Purpose: Phase 23 backend infrastructure is complete but frontend/resolver layers are not passing the source parameter, causing all corrections to use MusicBrainz path regardless of user selection.

Output: Working Discogs album correction flow from preview to apply.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-discogs-album-apply/23-VERIFICATION.md
@.planning/phases/23-discogs-album-apply/23-03-SUMMARY.md

@src/components/admin/correction/preview/PreviewView.tsx
@src/components/admin/correction/CorrectionModal.tsx
@src/graphql/schema.graphql
@src/lib/graphql/resolvers/mutations.ts
@src/lib/correction/preview/preview-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire source parameter in PreviewView query</name>
  <files>src/components/admin/correction/preview/PreviewView.tsx</files>
  <action>
Fix the preview query to include the source parameter from the store.

On line 67, the query input is:
```typescript
{ input: { albumId, releaseGroupMbid: selectedMbid! } }
```

Change to include source:
```typescript
{ input: { albumId, releaseGroupMbid: selectedMbid!, source: correctionSource.toUpperCase() as CorrectionSource } }
```

Add import at top if not present:
```typescript
import { CorrectionSource } from '@/generated/graphql';
```

The `correctionSource` state is already read from the store on line 62.
  </action>
  <verify>
Run `pnpm type-check` - should pass with no errors in PreviewView.tsx.
Grep for `source:.*correctionSource` in PreviewView.tsx confirms the wiring.
  </verify>
  <done>PreviewView.tsx passes source parameter to useGetCorrectionPreviewQuery.</done>
</task>

<task type="auto">
  <name>Task 2: Add source field to CorrectionApplyInput and wire resolver</name>
  <files>
    src/graphql/schema.graphql
    src/graphql/mutations/correctionApply.graphql
    src/lib/graphql/resolvers/mutations.ts
  </files>
  <action>
**Step 1: Update schema.graphql**

Find `input CorrectionApplyInput` (around line 1725) and add source field:
```graphql
input CorrectionApplyInput {
  """
  Album ID to apply correction to
  """
  albumId: UUID!
  """
  Selected release group MBID (or Discogs master ID)
  """
  releaseGroupMbid: String!
  """
  Field selections determining which changes to apply
  """
  selections: FieldSelectionsInput!
  """
  Expected album updatedAt timestamp for optimistic locking
  """
  expectedUpdatedAt: DateTime!
  """
  Source of correction data (defaults to MusicBrainz)
  """
  source: CorrectionSource = MUSICBRAINZ
}
```

**Step 2: Update correctionApply.graphql mutation**

The mutation file does not need changes - it uses `$input: CorrectionApplyInput!` which will automatically include the new field.

**Step 3: Update mutations.ts resolver**

In the `correctionApply` resolver (around line 2793):

1. Extract source from input (with default):
```typescript
const { albumId, releaseGroupMbid, selections, expectedUpdatedAt, source } = input;
const normalizedSource = (source?.toLowerCase() ?? 'musicbrainz') as 'musicbrainz' | 'discogs';
```

2. Replace the hardcoded MusicBrainz fetch block (lines 2835-2847) with source-conditional logic:
```typescript
// Fetch release data based on source
let scoredResult;
try {
  if (normalizedSource === 'discogs') {
    // Fetch Discogs master and map to CorrectionSearchResult
    const discogsService = getQueuedDiscogsService();
    const master = await discogsService.getMaster(releaseGroupMbid, PRIORITY_TIERS.ADMIN);
    const baseResult = mapMasterToCorrectionSearchResult(master);
    // Wrap with default scoring (same as correctionPreview resolver)
    scoredResult = {
      ...baseResult,
      normalizedScore: 1.0,
      displayScore: 100,
      isLowConfidence: false,
      scoringStrategy: 'normalized' as const,
      breakdown: {
        titleScore: 100,
        artistScore: 100,
        yearScore: 100,
        mbScore: 0,
        confidenceTier: 'high' as const,
      },
    };
  } else {
    // MusicBrainz path (existing)
    const searchService = getCorrectionSearchService();
    scoredResult = await searchService.getByMbid(releaseGroupMbid);
  }
} catch (error) {
  return {
    success: false,
    code: 'NOT_FOUND',
    message: `Release not found: ${releaseGroupMbid}`,
  };
}
```

3. Add required imports at top of file:
```typescript
import { getQueuedDiscogsService } from '@/lib/discogs/queued-service';
import { mapMasterToCorrectionSearchResult } from '@/lib/discogs/mappers';
import { PRIORITY_TIERS } from '@/lib/queue/priority';
```

4. Update generatePreview call to pass source (around line 2851):
```typescript
const preview = await previewService.generatePreview(
  albumId,
  scoredResult,
  releaseGroupMbid,
  normalizedSource
);
```
  </action>
  <verify>
Run `pnpm codegen` - should complete without errors.
Run `pnpm type-check` - should pass.
Grep for `getQueuedDiscogsService` in mutations.ts confirms Discogs service is imported and used.
Grep for `source: CorrectionSource` in schema.graphql confirms field added.
  </verify>
  <done>CorrectionApplyInput has source field; resolver conditionally routes to Discogs.</done>
</task>

<task type="auto">
  <name>Task 3: Wire source parameter in CorrectionModal apply mutation</name>
  <files>src/components/admin/correction/CorrectionModal.tsx</files>
  <action>
Update the handleApply function to include source in the mutation input.

Find the applyMutation.mutate call (around line 448):
```typescript
applyMutation.mutate({
  input: {
    albumId,
    releaseGroupMbid: previewData.sourceResult.releaseGroupMbid,
    selections: graphqlSelections,
    expectedUpdatedAt,
  },
});
```

Add source field:
```typescript
applyMutation.mutate({
  input: {
    albumId,
    releaseGroupMbid: previewData.sourceResult.releaseGroupMbid,
    selections: graphqlSelections,
    expectedUpdatedAt,
    source: correctionSource.toUpperCase() as CorrectionSource,
  },
});
```

The `correctionSource` state needs to be read from the store. Find where `store` is defined (around line 107) and add:
```typescript
const correctionSource = store(s => s.correctionSource);
```

Add import if not present:
```typescript
import { CorrectionSource } from '@/generated/graphql';
```
  </action>
  <verify>
Run `pnpm type-check` - should pass with no errors in CorrectionModal.tsx.
Grep for `source:.*correctionSource` in CorrectionModal.tsx confirms the wiring.
  </verify>
  <done>CorrectionModal.tsx passes source parameter to correctionApply mutation.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Run `pnpm codegen && pnpm type-check` - both must pass
2. Grep verification:
   - `grep -n "source:.*correctionSource" src/components/admin/correction/preview/PreviewView.tsx` - shows wiring
   - `grep -n "source:.*correctionSource" src/components/admin/correction/CorrectionModal.tsx` - shows wiring
   - `grep -n "getQueuedDiscogsService" src/lib/graphql/resolvers/mutations.ts` - confirms Discogs import
   - `grep -n "source: CorrectionSource" src/graphql/schema.graphql` - confirms schema update
3. All gaps from 23-VERIFICATION.md are addressed
</verification>

<success_criteria>
- PreviewView.tsx includes source in query input
- CorrectionApplyInput in schema.graphql has source field with MUSICBRAINZ default
- correctionApply resolver conditionally fetches from Discogs when source is DISCOGS
- CorrectionModal.tsx includes source in mutation input
- pnpm codegen runs successfully
- pnpm type-check passes
- No regressions in MusicBrainz correction flow (default behavior unchanged)
</success_criteria>

<output>
After completion, create `.planning/phases/23-discogs-album-apply/23-04-SUMMARY.md`
</output>
