---
phase: 23-discogs-album-apply
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/queue/jobs.ts
  - src/lib/discogs/queued-service.ts
  - src/lib/queue/processors/discogs-processor.ts
  - src/workers/queue-worker.ts
autonomous: true

must_haves:
  truths:
    - "QueuedDiscogsService has getMaster() method callable from services"
    - "DISCOGS_GET_MASTER job type exists and worker can process it"
    - "getMaster() returns full DiscogsMaster with tracklist and images"
  artifacts:
    - path: "src/lib/queue/jobs.ts"
      provides: "DISCOGS_GET_MASTER job type constant and data interface"
      contains: "DISCOGS_GET_MASTER"
    - path: "src/lib/discogs/queued-service.ts"
      provides: "getMaster() method for fetching master by ID"
      exports: ["QueuedDiscogsService", "getQueuedDiscogsService"]
    - path: "src/lib/queue/processors/discogs-processor.ts"
      provides: "handleDiscogsGetMaster job handler"
      exports: ["handleDiscogsGetMaster"]
  key_links:
    - from: "src/lib/discogs/queued-service.ts"
      to: "src/lib/queue/jobs.ts"
      via: "imports JOB_TYPES.DISCOGS_GET_MASTER"
      pattern: "JOB_TYPES\\.DISCOGS_GET_MASTER"
    - from: "src/workers/queue-worker.ts"
      to: "src/lib/queue/processors/discogs-processor.ts"
      via: "routes DISCOGS_GET_MASTER to handler"
      pattern: "handleDiscogsGetMaster"
---

<objective>
Add DISCOGS_GET_MASTER queue job type and QueuedDiscogsService.getMaster() method.

Purpose: Enable fetching full Discogs master data (with tracklist) for preview generation. This mirrors the existing QueuedMusicBrainzService.getRelease() pattern used for MusicBrainz previews.

Output: Working queue infrastructure for fetching Discogs master details by ID with rate limiting.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-discogs-album-apply/23-RESEARCH.md
@.planning/phases/23-discogs-album-apply/23-CONTEXT.md
@.planning/phases/22-discogs-album-search/22-01-SUMMARY.md

@src/lib/queue/jobs.ts
@src/lib/discogs/queued-service.ts
@src/lib/queue/processors/discogs-processor.ts
@src/workers/queue-worker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DISCOGS_GET_MASTER job type and data interface</name>
  <files>src/lib/queue/jobs.ts</files>
  <action>
Add DISCOGS_GET_MASTER to JOB_TYPES constant object (after DISCOGS_SEARCH_ALBUM):

DISCOGS_GET_MASTER: 'discogs:get-master',

Add DiscogsGetMasterJobData interface (after DiscogsSearchAlbumJobData):

export interface DiscogsGetMasterJobData {
  /** Discogs master ID to fetch */
  masterId: string;
  /** Request ID for tracking */
  requestId?: string;
  /** Parent job ID for job linking */
  parentJobId?: string;
}

This follows the existing pattern from DiscogsGetArtistJobData.
  </action>
  <verify>TypeScript compiles: pnpm type-check passes</verify>
  <done>JOB_TYPES includes DISCOGS_GET_MASTER, DiscogsGetMasterJobData interface exported</done>
</task>

<task type="auto">
  <name>Task 2: Add getMaster() method to QueuedDiscogsService</name>
  <files>src/lib/discogs/queued-service.ts</files>
  <action>
Add getMaster() method to QueuedDiscogsService class, following the pattern of searchAlbums().

Import the job type at top if needed, and add DiscogsMaster type import:
import type { DiscogsMaster } from '@/types/discogs/master';

Add method after searchAlbums():

/**
 * Fetch a Discogs master by ID
 * Returns full master data including tracklist and images
 */
async getMaster(
  masterId: string,
  priority: number = PRIORITY_TIERS.ADMIN
): Promise<DiscogsMaster> {
  this.ensureInitialized();

  console.log(
    chalk.cyan('[QueuedDiscogsService] Queuing master fetch for ID ' + masterId)
  );

  try {
    const job = await this.queue.addJob(
      JOB_TYPES.DISCOGS_GET_MASTER,
      {
        masterId,
        requestId: 'discogs-master-' + masterId + '-' + Date.now(),
      },
      {
        priority,
        requestId: 'discogs-master-' + masterId,
      }
    );

    const result = await this.waitForJobViaEvents(job.id!);
    return result as DiscogsMaster;
  } catch (error) {
    console.error('[QueuedDiscogsService] Master fetch failed:', error);
    throw new Error(
      'Failed to fetch Discogs master: ' +
        (error instanceof Error ? error.message : 'Unknown error')
    );
  }
}
  </action>
  <verify>TypeScript compiles: pnpm type-check passes</verify>
  <done>QueuedDiscogsService.getMaster() method exists and accepts masterId + priority parameters</done>
</task>

<task type="auto">
  <name>Task 3: Add handleDiscogsGetMaster processor and wire to worker</name>
  <files>src/lib/queue/processors/discogs-processor.ts, src/workers/queue-worker.ts</files>
  <action>
**In discogs-processor.ts:**

Add DiscogsGetMasterJobData to imports from '../jobs'.

Add handleDiscogsGetMaster function after handleDiscogsSearchAlbum:

/**
 * Fetch full Discogs master data by ID
 * Used by admin correction preview via QueuedDiscogsService
 */
export async function handleDiscogsGetMaster(
  job: Job<DiscogsGetMasterJobData>
): Promise<unknown> {
  const data = job.data;
  const startTime = Date.now();

  console.log('[Discogs Get Master] Fetching master ID: ' + data.masterId);

  try {
    // Initialize Discogs client via dynamic import (ESM-friendly)
    const Discogs = await import('disconnect');
    const discogsClient = new Discogs.default.Client({
      userAgent: 'RecProject/1.0 +https://rec-music.org',
      consumerKey: process.env.CONSUMER_KEY!,
      consumerSecret: process.env.CONSUMER_SECRET!,
    }).database();

    // Fetch master
    const master = await discogsClient.getMaster(parseInt(data.masterId, 10));

    const duration = Date.now() - startTime;
    const year = master.year || 'unknown year';
    console.log('[Discogs Get Master] Fetched "' + master.title + '" (' + year + ') in ' + duration + 'ms');

    // Return full master object
    return master;
  } catch (error) {
    console.error('[Discogs Get Master] Failed for ID ' + data.masterId + ':', error);
    throw error;
  }
}

**In queue-worker.ts:**

Add handleDiscogsGetMaster to discogs-processor imports.

Add DiscogsGetMasterJobData to imports from '@/lib/queue/jobs'.

Add the case in the switch statement (after DISCOGS_SEARCH_ALBUM):
case JOB_TYPES.DISCOGS_GET_MASTER:
  return handleDiscogsGetMaster(job as Job<DiscogsGetMasterJobData>);
  </action>
  <verify>
1. TypeScript compiles: pnpm type-check passes
2. Worker imports resolve correctly
  </verify>
  <done>handleDiscogsGetMaster handler exists and is wired to queue worker for DISCOGS_GET_MASTER job type</done>
</task>

</tasks>

<verification>
- [ ] pnpm type-check passes
- [ ] JOB_TYPES.DISCOGS_GET_MASTER exists
- [ ] QueuedDiscogsService.getMaster() method exists
- [ ] handleDiscogsGetMaster processor exists
- [ ] Worker routes DISCOGS_GET_MASTER to handler
</verification>

<success_criteria>
The queue infrastructure for fetching Discogs master data is complete:
- Job type constant and data interface defined
- QueuedDiscogsService has getMaster() method
- Processor handler fetches from Discogs API
- Worker routes jobs to handler
</success_criteria>

<output>
After completion, create .planning/phases/23-discogs-album-apply/23-01-SUMMARY.md
</output>
