---
phase: 23-discogs-album-apply
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - src/lib/correction/preview/preview-service.ts
  - src/lib/correction/preview/types.ts
  - src/lib/correction/apply/apply-service.ts
  - src/lib/correction/apply/field-selector.ts
autonomous: true

must_haves:
  truths:
    - "CorrectionPreviewService.generatePreview() accepts source parameter"
    - "Discogs masters are fetched via QueuedDiscogsService.getMaster()"
    - "Apply service stores discogsId when source is discogs"
    - "Enrichment log records correct source (musicbrainz or discogs)"
  artifacts:
    - path: "src/lib/correction/preview/preview-service.ts"
      provides: "Discogs-aware preview generation with fetchDiscogsReleaseData"
      contains: "fetchDiscogsReleaseData"
    - path: "src/lib/correction/preview/types.ts"
      provides: "CorrectionSource type for source parameter"
      contains: "CorrectionSource"
    - path: "src/lib/correction/apply/apply-service.ts"
      provides: "Source-aware external ID storage"
      contains: "discogsId"
    - path: "src/lib/correction/apply/field-selector.ts"
      provides: "Source-conditional ID building"
      contains: "discogsId"
  key_links:
    - from: "src/lib/correction/preview/preview-service.ts"
      to: "src/lib/discogs/queued-service.ts"
      via: "imports and calls getQueuedDiscogsService().getMaster()"
      pattern: "getQueuedDiscogsService"
    - from: "src/lib/correction/apply/apply-service.ts"
      to: "src/lib/correction/preview/types.ts"
      via: "reads preview.sourceResult.source"
      pattern: "sourceResult\\.source"
---

<objective>
Extend preview and apply services for Discogs source support.

Purpose: Enable generating correction previews from Discogs master data and applying corrections that store discogsId instead of musicbrainzId. This makes the existing preview/apply infrastructure source-agnostic.

Output: Preview service can fetch and transform Discogs data; apply service stores correct external ID based on source.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-discogs-album-apply/23-RESEARCH.md
@.planning/phases/23-discogs-album-apply/23-CONTEXT.md
@.planning/phases/23-discogs-album-apply/23-01-SUMMARY.md

@src/lib/correction/preview/preview-service.ts
@src/lib/correction/preview/types.ts
@src/lib/correction/apply/apply-service.ts
@src/lib/correction/apply/field-selector.ts
@src/lib/discogs/queued-service.ts
@src/types/discogs/master.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CorrectionSource type and update preview service signature</name>
  <files>src/lib/correction/preview/types.ts, src/lib/correction/preview/preview-service.ts</files>
  <action>
**In src/lib/correction/preview/types.ts:**

Add CorrectionSource type near the top (after imports):

/** Source for correction data - determines which external service to query */
export type CorrectionSource = 'musicbrainz' | 'discogs';

**In src/lib/correction/preview/preview-service.ts:**

1. Add import for CorrectionSource:
import type { CorrectionSource, ... } from './types';

2. Add import for Discogs service:
import { getQueuedDiscogsService } from '@/lib/discogs/queued-service';

3. Add import for DiscogsMaster type:
import type { DiscogsMaster } from '@/types/discogs/master';

4. Update generatePreview method signature to accept source parameter with default:

async generatePreview(
  albumId: string,
  searchResult: ScoredSearchResult,
  releaseMbid: string,
  source: CorrectionSource = 'musicbrainz'
): Promise<CorrectionPreview> {
  ...
}

5. Inside generatePreview, add conditional fetch based on source. Replace the existing mbReleaseData fetch with:

// Fetch source data based on correction source
let mbReleaseData: MBReleaseData | null;
if (source === 'discogs') {
  mbReleaseData = await this.fetchDiscogsReleaseData(releaseMbid);
} else {
  mbReleaseData = await this.fetchMBReleaseData(releaseMbid);
}

6. Update generateFieldDiffs call to pass source:

const fieldDiffs = this.generateFieldDiffs(
  currentAlbum,
  mbReleaseData,
  searchResult.releaseGroupMbid,
  source
);
  </action>
  <verify>TypeScript compiles: pnpm type-check passes (may have errors until Task 2)</verify>
  <done>generatePreview accepts source parameter and conditionally routes to Discogs/MB fetch</done>
</task>

<task type="auto">
  <name>Task 2: Add fetchDiscogsReleaseData method and update field diff logic</name>
  <files>src/lib/correction/preview/preview-service.ts</files>
  <action>
Add fetchDiscogsReleaseData private method after fetchMBReleaseData:

/**
 * Fetch Discogs master data and transform to MBReleaseData format.
 * Uses QueuedDiscogsService for rate-limited API access.
 */
private async fetchDiscogsReleaseData(
  discogsMasterId: string
): Promise<MBReleaseData | null> {
  try {
    const discogsService = getQueuedDiscogsService();
    const master = await discogsService.getMaster(
      discogsMasterId,
      PRIORITY_TIERS.ADMIN
    );

    return this.transformDiscogsMaster(master);
  } catch (error) {
    console.error('Failed to fetch Discogs master data:', error);
    return null;
  }
}

/**
 * Transform Discogs master to MBReleaseData format for unified processing.
 */
private transformDiscogsMaster(master: DiscogsMaster): MBReleaseData {
  return {
    id: master.id.toString(),
    title: master.title,
    // Year-only date with Jan 1 fallback per CONTEXT.md
    date: master.year ? master.year.toString() + '-01-01' : undefined,
    // Discogs masters don't have country or barcode
    country: undefined,
    barcode: undefined,
    // Map tracklist to media format
    media: this.mapDiscogsTracklist(master.tracklist || []),
    // Map artist credits
    artistCredit: (master.artists || []).map(a => ({
      name: a.name,
      joinphrase: a.join || '',
      artist: {
        id: a.id.toString(),
        name: a.name,
        sortName: undefined,
        disambiguation: undefined,
      },
    })),
  };
}

/**
 * Map Discogs tracklist to MBMedium[] format.
 * Handles Discogs position strings (1, 2, A1, B2, etc.)
 */
private mapDiscogsTracklist(
  tracklist: DiscogsMaster['tracklist']
): MBReleaseData['media'] {
  if (!tracklist || tracklist.length === 0) {
    return [];
  }

  // Group tracks by disc (parse position strings)
  const discMap = new Map<number, Array<{
    position: string;
    title: string;
    duration: string;
    trackNum: number;
  }>>();

  tracklist.forEach((track, idx) => {
    const disc = this.parseDiscNumber(track.position);
    const trackNum = this.parseTrackNumber(track.position, idx);

    if (!discMap.has(disc)) {
      discMap.set(disc, []);
    }
    discMap.get(disc)!.push({
      position: track.position,
      title: track.title,
      duration: track.duration || '',
      trackNum,
    });
  });

  // Convert to MBMedium format
  return Array.from(discMap.entries()).map(([discNum, tracks]) => ({
    position: discNum,
    format: undefined,
    trackCount: tracks.length,
    tracks: tracks.map(track => ({
      position: track.trackNum,
      recording: {
        id: '', // Discogs tracks don't have IDs
        title: track.title,
        length: this.parseDuration(track.duration),
        position: track.trackNum,
      },
    })),
  }));
}

/**
 * Parse disc number from Discogs position string.
 * "1" or "2" = disc 1, "A1" = disc 1, "B1" = disc 2, etc.
 */
private parseDiscNumber(position: string): number {
  if (!position) return 1;
  const match = position.match(/^([A-Z])?(\d+)/i);
  if (!match) return 1;

  if (match[1]) {
    // Letter prefix: A=1, B=2, C=3, etc.
    return match[1].toUpperCase().charCodeAt(0) - 64;
  }
  return 1;
}

/**
 * Parse track number from Discogs position string.
 */
private parseTrackNumber(position: string, fallbackIdx: number): number {
  if (!position) return fallbackIdx + 1;
  const match = position.match(/(\d+)$/);
  return match ? parseInt(match[1], 10) : fallbackIdx + 1;
}

/**
 * Convert Discogs duration string (MM:SS) to milliseconds.
 */
private parseDuration(duration: string): number | undefined {
  if (!duration) return undefined;
  const parts = duration.split(':');
  if (parts.length === 2) {
    const minutes = parseInt(parts[0], 10);
    const seconds = parseInt(parts[1], 10);
    if (!isNaN(minutes) && !isNaN(seconds)) {
      return (minutes * 60 + seconds) * 1000;
    }
  }
  return undefined;
}

Then update generateFieldDiffs signature to accept source and add source-conditional external ID comparison:

private generateFieldDiffs(
  currentAlbum: Album,
  mbData: MBReleaseData | null,
  releaseGroupMbid?: string,
  source: CorrectionSource = 'musicbrainz'
): FieldDiff[] {
  const diffs: FieldDiff[] = [];

  // Title
  diffs.push(
    this.diffEngine.compareText('title', currentAlbum.title, mbData?.title || null)
  );

  // Release date
  diffs.push(
    this.diffEngine.compareDate(currentAlbum.releaseDate, mbData?.date || null)
  );

  // Country (only for MusicBrainz - Discogs masters don't have country)
  if (source === 'musicbrainz') {
    diffs.push(
      this.diffEngine.compareText('country', currentAlbum.releaseCountry, mbData?.country || null)
    );
  }

  // Barcode (only for MusicBrainz - Discogs masters don't have barcode)
  if (source === 'musicbrainz') {
    diffs.push(
      this.diffEngine.compareText('barcode', currentAlbum.barcode, mbData?.barcode || null)
    );
  }

  // External ID (conditional on source)
  if (source === 'musicbrainz') {
    diffs.push(
      this.diffEngine.compareExternalId('musicbrainzId', currentAlbum.musicbrainzId, releaseGroupMbid || null)
    );
  } else if (source === 'discogs') {
    diffs.push(
      this.diffEngine.compareExternalId('discogsId', currentAlbum.discogsId, releaseGroupMbid || null)
    );
  }

  return diffs;
}
  </action>
  <verify>TypeScript compiles: pnpm type-check passes</verify>
  <done>fetchDiscogsReleaseData method fetches and transforms Discogs master data, field diffs are source-aware</done>
</task>

<task type="auto">
  <name>Task 3: Update apply service and field-selector for Discogs source</name>
  <files>src/lib/correction/apply/apply-service.ts, src/lib/correction/apply/field-selector.ts</files>
  <action>
**In src/lib/correction/apply/field-selector.ts:**

Update buildAlbumUpdateData to handle source-conditional external ID:

Find the External IDs section and replace it with source-aware logic:

// =========================================
// External IDs (source-conditional)
// =========================================

// Determine source from preview (default to musicbrainz for backward compatibility)
const source = preview.sourceResult.source || 'musicbrainz';

if (source === 'musicbrainz' && selections.externalIds.musicbrainzId) {
  data.musicbrainzId = preview.sourceResult.releaseGroupMbid;
  hasChanges = true;
} else if (source === 'discogs' && selections.externalIds.discogsId) {
  data.discogsId = preview.sourceResult.releaseGroupMbid;
  hasChanges = true;
}

**In src/lib/correction/apply/apply-service.ts:**

1. Update logCorrection method to record correct source. Find the enrichment log creation and update the sources array:

// Determine source from preview
const source = preview.sourceResult.source || 'musicbrainz';

await this.prisma.enrichmentLog.create({
  data: {
    entityType: 'ALBUM',
    albumId,
    userId: adminUserId,
    operation: 'admin_correction',
    status: 'SUCCESS',
    sources: [source],  // Use actual source instead of hardcoded ['musicbrainz']
    ...rest
  }
});

2. Update buildAppliedChanges to include discogsId in externalIds when source is discogs:

Find the externalIds logic and update:

const source = preview.sourceResult.source || 'musicbrainz';
const externalIds: string[] = [];

if (source === 'musicbrainz' && selections.externalIds.musicbrainzId &&
    beforeAlbum.musicbrainzId !== afterAlbum.musicbrainzId) {
  externalIds.push('musicbrainzId');
} else if (source === 'discogs' && selections.externalIds.discogsId &&
    beforeAlbum.discogsId !== afterAlbum.discogsId) {
  externalIds.push('discogsId');
}

3. Update buildAuditPayload to include discogsId in externalIds delta:

Find the externalIds section in buildAuditPayload and update:

const source = preview.sourceResult.source || 'musicbrainz';
const externalIds: FieldDelta[] = [];

if (source === 'musicbrainz' && selections.externalIds.musicbrainzId &&
    beforeAlbum.musicbrainzId !== afterAlbum.musicbrainzId) {
  externalIds.push({
    field: 'musicbrainzId',
    before: beforeAlbum.musicbrainzId,
    after: afterAlbum.musicbrainzId,
  });
} else if (source === 'discogs' && selections.externalIds.discogsId &&
    beforeAlbum.discogsId !== afterAlbum.discogsId) {
  externalIds.push({
    field: 'discogsId',
    before: beforeAlbum.discogsId,
    after: afterAlbum.discogsId,
  });
}
  </action>
  <verify>TypeScript compiles: pnpm type-check passes</verify>
  <done>Apply service stores discogsId when source is discogs, enrichment log records correct source</done>
</task>

</tasks>

<verification>
- [ ] pnpm type-check passes
- [ ] generatePreview accepts source parameter
- [ ] fetchDiscogsReleaseData method exists
- [ ] Field diffs are source-conditional (country/barcode only for MB)
- [ ] buildAlbumUpdateData stores discogsId when source is discogs
- [ ] Enrichment log uses correct source value
</verification>

<success_criteria>
Preview and apply services are source-agnostic:
- Preview can fetch from MusicBrainz or Discogs based on source parameter
- Discogs master data is transformed to common format for diff generation
- Apply service stores correct external ID based on source
- Audit logging records actual data source
</success_criteria>

<output>
After completion, create .planning/phases/23-discogs-album-apply/23-02-SUMMARY.md
</output>
