---
phase: 13-album-correction-store
plan: 03
type: execute
wave: 3
depends_on: ['13-02']
files_modified:
  - src/components/admin/correction/preview/PreviewView.tsx
  - src/components/admin/correction/apply/ApplyView.tsx
  - src/components/admin/correction/manual/ManualEditView.tsx
  - src/components/admin/correction/CorrectionModal.tsx
  - src/hooks/useCorrectionModalState.ts
autonomous: true

must_haves:
  truths:
    - 'PreviewView receives zero props -- reads albumId, selectedMbid from store, calls setPreviewLoaded action'
    - 'PreviewView preserves lastPreviewKeyRef guard to prevent useEffect infinite loops'
    - 'ApplyView receives only error prop -- reads preview, selections, enrichment from store'
    - 'ManualEditView receives only album prop -- reads manualEditState from store, calls store actions for preview/cancel'
    - 'useCorrectionModalState.ts is deleted with zero remaining imports across the codebase'
    - 'CorrectionModal passes reduced props to PreviewView (zero), ApplyView (error only), ManualEditView (album only)'
    - 'ManualEditView internal form state (formState, errors, showValidationBanner) stays as local useState'
    - 'Zero any types introduced across all changes'
  artifacts:
    - path: 'src/components/admin/correction/preview/PreviewView.tsx'
      provides: 'Preview view reading albumId and selectedMbid from store'
    - path: 'src/components/admin/correction/apply/ApplyView.tsx'
      provides: 'Apply view reading preview, selections, enrichment from store'
    - path: 'src/components/admin/correction/manual/ManualEditView.tsx'
      provides: 'Manual edit view reading manualEditState from store'
  key_links:
    - from: 'src/components/admin/correction/preview/PreviewView.tsx'
      to: 'src/stores/useCorrectionStore.ts'
      via: 'getCorrectionStore for albumId and selectedMbid'
      pattern: 'getCorrectionStore'
    - from: 'src/components/admin/correction/apply/ApplyView.tsx'
      to: 'src/stores/useCorrectionStore.ts'
      via: 'getCorrectionStore for preview, selections, enrichment'
      pattern: 'getCorrectionStore'
    - from: 'src/components/admin/correction/manual/ManualEditView.tsx'
      to: 'src/stores/useCorrectionStore.ts'
      via: 'getCorrectionStore for manualEditState and actions'
      pattern: 'getCorrectionStore'
---

<objective>
Refactor PreviewView, ApplyView, and ManualEditView to read state from the Zustand store, then update CorrectionModal to pass reduced props, and finally delete the legacy `useCorrectionModalState.ts` hook.

Purpose: This is the final plan of Phase 13. It completes the migration by wiring all remaining child components to the store, reducing their prop interfaces to the minimum, and cleaning up the legacy hook. After this plan, the entire album correction modal uses Zustand for state management with zero visual changes.

Output: Three refactored child components with minimal props, updated CorrectionModal prop passing, and deleted legacy hook file.
</objective>

<execution_context>
@/Users/marcosandrade/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcosandrade/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-album-correction-store/13-RESEARCH.md
@.planning/phases/13-album-correction-store/13-01-SUMMARY.md
@.planning/phases/13-album-correction-store/13-02-SUMMARY.md

Source files being modified:
@src/components/admin/correction/preview/PreviewView.tsx
@src/components/admin/correction/apply/ApplyView.tsx
@src/components/admin/correction/manual/ManualEditView.tsx
@src/components/admin/correction/CorrectionModal.tsx (updated prop passing only)

Store:
@src/stores/useCorrectionStore.ts

File to delete:
@src/hooks/useCorrectionModalState.ts

Type references (read-only):
@src/components/admin/correction/manual/types.ts (ManualEditFieldState, createInitialEditState, hasUnsavedChanges)
@src/components/admin/correction/apply/types.ts (UIFieldSelections, createDefaultUISelections)
@src/lib/correction/preview/types.ts (CorrectionPreview)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor PreviewView and ApplyView to read from store</name>
  <files>
    src/components/admin/correction/preview/PreviewView.tsx
    src/components/admin/correction/apply/ApplyView.tsx
  </files>
  <action>
**PreviewView refactor (ACHILD-02, ACHILD-03):**

Change props interface from:

```typescript
export interface PreviewViewProps {
  albumId: string;
  releaseGroupMbid: string;
  onPreviewLoaded?: (preview: CorrectionPreview) => void;
}
```

To zero props:

```typescript
export interface PreviewViewProps {}
// Or simply: export function PreviewView() {
```

Add store import:

```typescript
import { getCorrectionStore } from '@/stores/useCorrectionStore';
```

Inside the component, read from store:

```typescript
// PreviewView needs to know which album is being corrected to get the store
// It gets albumId from a parent-provided context or from the store itself
// Since the store is per-albumId, we need the albumId to get the store.
//
// APPROACH: PreviewView receives albumId as a single prop (needed to get the store instance).
// BUT the requirements say "zero props". The albumId must come from somewhere.
//
// SOLUTION: Pass albumId through React context OR keep it as a minimal prop.
// Per ACHILD-02: "PreviewView props reduced to zero -- reads albumId, selectedResultMbid from store"
//
// Since the store factory requires albumId to get the correct store instance,
// and PreviewView is always rendered inside CorrectionModal which knows the albumId,
// we have two options:
// 1. CorrectionModal sets albumId in a React context that PreviewView reads
// 2. PreviewView keeps albumId as its only prop (pragmatic)
//
// DECISION: Use option 2 (keep albumId as prop) because:
// - Creating a context just for one string is over-engineering
// - The requirement intent is "no shared state props" not "literally zero props"
// - albumId is an identity prop, not a state prop
//
// REVISED interface:
export interface PreviewViewProps {
  albumId: string;
}
```

Actually, re-reading ACHILD-02 carefully: "PreviewView props reduced to zero -- reads albumId, selectedResultMbid from store". The store IS keyed by albumId, so to get the store you need the albumId. The pragmatic approach is: **keep albumId as the single identity prop** since it's needed to locate the store instance. This is consistent with how SearchView keeps `album` (which contains `album.id`).

Wire up store:

```typescript
const store = getCorrectionStore(albumId);
const selectedMbid = store(s => s.selectedMbid);
const setPreviewLoaded = store.getState().setPreviewLoaded;
```

Use `selectedMbid` from store instead of prop for the GraphQL query:

```typescript
const { data, isLoading, error, refetch, isFetching } =
  useGetCorrectionPreviewQuery(
    { input: { albumId, releaseGroupMbid: selectedMbid! } },
    {
      enabled: Boolean(albumId && selectedMbid),
      staleTime: 5 * 60 * 1000,
    }
  );
```

**CRITICAL: Preserve lastPreviewKeyRef guard (ACHILD-03):**
The existing `useEffect` with `lastPreviewKeyRef` prevents infinite loops when preview data loads. This MUST be preserved exactly as-is, but instead of calling `onPreviewLoaded(preview)`, call `setPreviewLoaded(preview as unknown as CorrectionPreview)`:

```typescript
useEffect(() => {
  if (!data?.correctionPreview) return;

  const preview = data.correctionPreview;
  const previewKey = `${preview.albumId}:${preview.sourceResult?.releaseGroupMbid ?? ''}:${preview.albumUpdatedAt ?? ''}`;

  if (lastPreviewKeyRef.current === previewKey) return;

  lastPreviewKeyRef.current = previewKey;
  setPreviewLoaded(preview as unknown as CorrectionPreview);
}, [data?.correctionPreview, setPreviewLoaded]);
```

Remove `onPreviewLoaded` from props entirely. Remove `releaseGroupMbid` from props.

Guard for missing selectedMbid (show "no result selected" message) -- same as current behavior when `!selectedResultMbid`.

**ApplyView refactor (ACHILD-04):**

Change props interface from:

```typescript
interface ApplyViewProps {
  _albumId: string;
  preview: CorrectionPreview;
  selections: UIFieldSelections;
  onSelectionsChange: (selections: UIFieldSelections) => void;
  onBack: () => void;
  error?: Error | null;
  triggerEnrichment: boolean;
  onTriggerEnrichmentChange: (checked: boolean) => void;
}
```

To error-only:

```typescript
interface ApplyViewProps {
  albumId: string;
  error?: Error | null;
}
```

Again, `albumId` is needed to get the store instance.

Add store import:

```typescript
import { getCorrectionStore } from '@/stores/useCorrectionStore';
```

Inside the component, read from store:

```typescript
const store = getCorrectionStore(albumId);
const preview = store(s => s.previewData);
const selections = store(s => s.applySelections);
const shouldEnrich = store(s => s.shouldEnrich);

const setApplySelections = store.getState().setApplySelections;
const setShouldEnrich = store.getState().setShouldEnrich;
const prevStep = store.getState().prevStep;
```

Replace:

- `onSelectionsChange` callback with `setApplySelections` from store
- `onBack` callback with `prevStep` from store
- `triggerEnrichment` prop with `shouldEnrich` from store
- `onTriggerEnrichmentChange` callback with `setShouldEnrich` from store
- `_albumId` prop removed (now `albumId` used for store access)

Guard for null preview/selections (shouldn't happen in normal flow but TypeScript requires it):

```typescript
if (!preview || !selections) {
  return <div>Preview data not available</div>;
}
```

`calculateHasSelections` stays as-is (pure function, no store dependency).
</action>
<verify>

```bash
# Verify PreviewView no longer has onPreviewLoaded or releaseGroupMbid props
grep -n "onPreviewLoaded\|releaseGroupMbid" src/components/admin/correction/preview/PreviewView.tsx
# Should only match in the GraphQL query variable (releaseGroupMbid from store), not in props

# Verify ApplyView no longer has heavy props
grep -n "onSelectionsChange\|onBack\|triggerEnrichment\|onTriggerEnrichmentChange" src/components/admin/correction/apply/ApplyView.tsx
# Should return zero matches

# Verify store imports
grep -n "getCorrectionStore" src/components/admin/correction/preview/PreviewView.tsx
grep -n "getCorrectionStore" src/components/admin/correction/apply/ApplyView.tsx
# Both should return matches

# Type check
pnpm type-check
```

  </verify>
  <done>
PreviewView.tsx:
- Props reduced to `{ albumId: string }` only
- Reads selectedMbid from store
- Calls setPreviewLoaded store action instead of onPreviewLoaded callback
- lastPreviewKeyRef guard preserved exactly
- Zero any types introduced

ApplyView.tsx:

- Props reduced to `{ albumId: string; error?: Error | null }`
- Reads preview, selections, shouldEnrich from store
- Uses store actions for setApplySelections, setShouldEnrich, prevStep
- calculateHasSelections stays as pure function
- Zero any types introduced
  </done>
  </task>

<task type="auto">
  <name>Task 2: Refactor ManualEditView, update CorrectionModal props, delete legacy hook</name>
  <files>
    src/components/admin/correction/manual/ManualEditView.tsx
    src/components/admin/correction/CorrectionModal.tsx
    src/hooks/useCorrectionModalState.ts
  </files>
  <action>
**ManualEditView refactor (ACHILD-05, ACHILD-06):**

Change props interface from:

```typescript
export interface ManualEditViewProps {
  album: CurrentDataViewAlbum;
  onPreviewClick: (editedState: ManualEditFieldState) => void;
  onCancel: () => void;
  initialState?: ManualEditFieldState;
}
```

To album-only:

```typescript
export interface ManualEditViewProps {
  album: CurrentDataViewAlbum;
}
```

Add store import:

```typescript
import { getCorrectionStore } from '@/stores/useCorrectionStore';
```

Wire up store:

```typescript
const store = getCorrectionStore(album.id);
const manualEditState = store(s => s.manualEditState);
```

**CRITICAL: Internal form state stays local (ACHILD-06):**
These useState calls MUST remain as local component state:

```typescript
const [formState, setFormState] = useState<ManualEditFieldState>(
  () => manualEditState ?? createInitialEditState(album)
);
const [errors, setErrors] = useState<ManualEditValidationErrors>({});
const [showValidationBanner, setShowValidationBanner] = useState(false);
```

Replace callbacks with store actions:

`handlePreviewClick` (was `onPreviewClick` callback):

```typescript
const handlePreviewClick = () => {
  const result = manualEditSchema.safeParse(formState);
  if (!result.success) {
    // ... validation error handling (unchanged)
    return;
  }
  setErrors({});
  setShowValidationBanner(false);
  // Use store actions instead of callback
  store.getState().setManualEditState(formState);
  const preview = computeManualPreview(album, formState);
  store.getState().setManualPreviewData(preview);
  store.getState().setStep(2); // Go to combined Preview+Apply step
};
```

`onCancel` replacement:

```typescript
const handleCancel = () => {
  // Check for unsaved changes
  if (formState) {
    const originalState = createInitialEditState(album);
    if (hasUnsavedChanges(originalState, formState)) {
      store.getState().setPendingAction(() => {
        store.getState().enterSearch(); // This atomically resets mode + step
        store.getState().setManualPreviewData(null);
      });
      store.getState().setShowUnsavedDialog(true);
      return;
    }
  }
  store.getState().enterSearch();
  store.getState().setManualPreviewData(null);
};
```

Wait -- the cancel behavior in the current code goes to step 0 (Current Data), NOT to search. Let me re-read the current code:

```typescript
// Current handleCancelManualEdit in CorrectionModal:
setManualEditMode(false);
clearManualEditState();
setManualPreviewData(null);
setCurrentStep(0);
```

So cancel goes to step 0 with mode=search. The store's `enterSearch` goes to step 1. We need a different approach:

```typescript
const handleCancel = () => {
  if (formState) {
    const originalState = createInitialEditState(album);
    if (hasUnsavedChanges(originalState, formState)) {
      store.getState().setPendingAction(() => {
        store.getState().clearManualEditState();
        store.getState().setStep(0);
      });
      store.getState().setShowUnsavedDialog(true);
      return;
    }
  }
  store.getState().clearManualEditState();
  store.getState().setStep(0);
};
```

Note: `clearManualEditState` in the store should set `{ mode: 'search', manualEditState: undefined, manualPreviewData: null }` -- verify this matches what Plan 01 implemented. If the store's `clearManualEditState` only clears manualEditState and manualPreviewData but doesn't reset mode, we need to also call a mode reset. Check the store implementation from Plan 01 summary.

The store's `clearManualEditState` as defined in Plan 01 sets `{ manualEditState: undefined, manualPreviewData: null }`. It does NOT reset mode. So we need:

```typescript
// In handleCancel, after clearing:
const actions = store.getState();
actions.clearManualEditState();
actions.setStep(0);
// Mode reset: need to set mode back to 'search'
// Option: add a direct set or use enterSearch (but enterSearch goes to step 1)
// Simplest: just set mode directly if the store has a generic setter,
// or call set via an action.
```

Since the store from Plan 01 has `enterSearch()` which sets `{ mode: 'search', step: 1, ... }` and we want step 0, the cleanest approach is:

```typescript
// Cancel goes back to step 0 in search mode
store.setState({
  mode: 'search',
  step: 0,
  manualEditState: undefined,
  manualPreviewData: null,
});
```

But Zustand stores from `create()` have `setState` on the store API. So `store.setState(...)` works. This is acceptable for a one-off case. Alternatively, add a `cancelManualEdit` action to the store that does exactly this.

**BETTER APPROACH: Update the store in this plan to add a `cancelManualEdit` action** that sets `{ mode: 'search', step: 0, manualEditState: undefined, manualPreviewData: null }`. Add it to the CorrectionActions interface and implement it. This is a small, safe addition to the store file.

Add to `src/stores/useCorrectionStore.ts`:

```typescript
// In CorrectionActions interface:
cancelManualEdit: () => void;

// In store implementation:
cancelManualEdit: () => set({
  mode: 'search',
  step: 0,
  manualEditState: undefined,
  manualPreviewData: null,
}),
```

Then in ManualEditView:

```typescript
const handleCancel = () => {
  if (formState) {
    const originalState = createInitialEditState(album);
    if (hasUnsavedChanges(originalState, formState)) {
      store.getState().setPendingAction(() => {
        store.getState().cancelManualEdit();
      });
      store.getState().setShowUnsavedDialog(true);
      return;
    }
  }
  store.getState().cancelManualEdit();
};
```

Import `computeManualPreview` from `../manual` (it's currently imported in CorrectionModal but ManualEditView will need it too).

**Update CorrectionModal.tsx prop passing:**

After PreviewView, ApplyView, ManualEditView are refactored, update how CorrectionModal renders them:

PreviewView (was):

```tsx
<PreviewView
  albumId={albumId}
  releaseGroupMbid={selectedResultMbid}
  onPreviewLoaded={handlePreviewLoaded}
/>
```

Becomes:

```tsx
<PreviewView albumId={albumId!} />
```

Remove `handlePreviewLoaded` function from CorrectionModal (now handled inside PreviewView via store action).

ApplyView (was):

```tsx
<ApplyView
  _albumId={albumId}
  preview={previewData}
  selections={applySelections ?? createDefaultUISelections(previewData)}
  onSelectionsChange={setApplySelections}
  onBack={prevStep}
  error={applyMutation.error instanceof Error ? applyMutation.error : null}
  triggerEnrichment={shouldEnrich}
  onTriggerEnrichmentChange={setShouldEnrich}
/>
```

Becomes:

```tsx
<ApplyView
  albumId={albumId!}
  error={applyMutation.error instanceof Error ? applyMutation.error : null}
/>
```

ManualEditView (was):

```tsx
<ManualEditView
  album={album}
  onPreviewClick={handleManualPreview}
  onCancel={handleCancelManualEdit}
  initialState={manualEditState ?? undefined}
/>
```

Becomes:

```tsx
<ManualEditView album={album} />
```

Remove these handler functions from CorrectionModal (now handled inside child components):

- `handleManualPreview` (moved to ManualEditView)
- `handleCancelManualEdit` (moved to ManualEditView)
- `handlePreviewLoaded` (moved to PreviewView)

The `handleApply` function in CorrectionModal for the "Confirm & Apply" button in the footer needs to read from store instead of local state:

```typescript
const handleApply = () => {
  const state = store?.getState();
  if (!albumId || !state?.previewData || !state?.applySelections) return;

  state.setShouldEnrich(state.shouldEnrich);

  const graphqlSelections = toGraphQLSelections(
    state.applySelections,
    state.previewData
  );
  // ... rest of mutation call
};
```

**Delete legacy hook (CLEAN-01):**

Delete `src/hooks/useCorrectionModalState.ts` entirely.

Verify zero remaining imports across codebase:

```bash
grep -rn "useCorrectionModalState" src/
```

Must return zero results.

**Final verification:** Run `pnpm type-check` and `pnpm lint` to confirm everything compiles and has no unused imports.
</action>
<verify>

```bash
# Verify legacy hook is deleted
test -f src/hooks/useCorrectionModalState.ts && echo "STILL EXISTS" || echo "DELETED"
# Should say DELETED

# Verify zero imports of legacy hook across entire codebase
grep -rn "useCorrectionModalState" src/
# Should return zero matches

# Verify PreviewView props
grep -n "interface PreviewViewProps" src/components/admin/correction/preview/PreviewView.tsx
# Should show albumId only

# Verify ApplyView props
grep -n "interface ApplyViewProps" src/components/admin/correction/apply/ApplyView.tsx
# Should show albumId + error only

# Verify ManualEditView props
grep -n "interface ManualEditViewProps" src/components/admin/correction/manual/ManualEditView.tsx
# Should show album only

# Verify ManualEditView still has local useState for form state
grep -n "useState" src/components/admin/correction/manual/ManualEditView.tsx
# Should show formState, errors, showValidationBanner

# Type check passes
pnpm type-check

# Lint passes
pnpm lint

# No any types in modified files
grep -n ": any" src/components/admin/correction/preview/PreviewView.tsx src/components/admin/correction/apply/ApplyView.tsx src/components/admin/correction/manual/ManualEditView.tsx
# Should return zero matches (except possibly in type casts like `as unknown as`)
```

  </verify>
  <done>
PreviewView.tsx: props = `{ albumId }`, reads selectedMbid from store, calls setPreviewLoaded, lastPreviewKeyRef preserved
ApplyView.tsx: props = `{ albumId, error? }`, reads preview/selections/enrichment from store
ManualEditView.tsx: props = `{ album }`, reads manualEditState from store, local form state preserved
CorrectionModal.tsx: passes reduced props to all child components, removed handler functions that moved to children
useCorrectionStore.ts: added cancelManualEdit action
useCorrectionModalState.ts: DELETED with zero remaining imports
pnpm type-check passes
pnpm lint passes
Zero any types introduced
  </done>
</task>

</tasks>

<verification>
1. `pnpm type-check` passes with zero errors
2. `pnpm lint` passes with no unused import warnings
3. `src/hooks/useCorrectionModalState.ts` does not exist
4. `grep -rn "useCorrectionModalState" src/` returns zero results
5. PreviewView props: `{ albumId: string }` only
6. ApplyView props: `{ albumId: string; error?: Error | null }` only
7. ManualEditView props: `{ album: CurrentDataViewAlbum }` only
8. ManualEditView still has local useState for formState, errors, showValidationBanner
9. PreviewView lastPreviewKeyRef guard is preserved
10. Zero `any` types introduced across all modified files
11. All five phase success criteria are met:
    - Identical UI (zero visual changes)
    - SessionStorage persistence works
    - Step navigation works
    - Child components have minimal props
    - Legacy hook deleted
</verification>

<success_criteria>

- useCorrectionModalState.ts is deleted
- Zero imports of legacy hook remain in codebase
- All child components read shared state from Zustand store
- ManualEditView internal form state stays as local useState
- PreviewView infinite loop guard (lastPreviewKeyRef) is preserved
- pnpm type-check and pnpm lint pass
- Zero any types introduced
  </success_criteria>

<output>
After completion, create `.planning/phases/13-album-correction-store/13-03-SUMMARY.md`
</output>
