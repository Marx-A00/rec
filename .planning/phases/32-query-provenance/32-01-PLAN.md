---
phase: 32-query-provenance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/graphql/schema.graphql
  - src/lib/graphql/resolvers/queries.ts
  - src/graphql/queries/llamaLogChain.graphql
  - src/generated/graphql.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Query llamaLogChain exists and accepts entityType + entityId"
    - "Chain returns logs in reverse chronological order (newest first)"
    - "Chain can filter by category array"
    - "Chain returns pagination metadata (totalCount, cursor, hasMore)"
    - "Non-existent entity throws GraphQL error"
  artifacts:
    - path: "src/graphql/schema.graphql"
      provides: "llamaLogChain query definition and LlamaLogChainResponse type"
      contains: "llamaLogChain"
    - path: "src/lib/graphql/resolvers/queries.ts"
      provides: "llamaLogChain resolver implementation"
      contains: "llamaLogChain:"
    - path: "src/graphql/queries/llamaLogChain.graphql"
      provides: "Client query for provenance chain"
      contains: "query GetLlamaLogChain"
  key_links:
    - from: "src/graphql/queries/llamaLogChain.graphql"
      to: "src/graphql/schema.graphql"
      via: "GraphQL query definition"
      pattern: "llamaLogChain"
    - from: "src/lib/graphql/resolvers/queries.ts"
      to: "prisma.llamaLog"
      via: "Database query"
      pattern: "prisma\\.llamaLog\\.(findMany|count)"
---

<objective>
Implement GraphQL query `llamaLogChain` that returns the complete provenance chain for any entity (Album, Artist, Track).

Purpose: Answer "How did this entity get into the database, and what happened to it afterward?" Returns root creation event plus all related operations with pagination.

Output: Working GraphQL query with cursor pagination, category filtering, date range filtering, and proper entity validation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-query-provenance/32-CONTEXT.md
@.planning/phases/32-query-provenance/32-RESEARCH.md

# Key source files
@src/graphql/schema.graphql
@src/lib/graphql/resolvers/queries.ts
@src/graphql/queries/enrichment.graphql
</context>

<tasks>

<task type="auto">
  <name>Task 1: GraphQL schema additions</name>
  <files>src/graphql/schema.graphql</files>
  <action>
Add the following to the GraphQL schema:

1. Add `rootJobId` field to the LlamaLog type (after `parentJobId`):
   ```graphql
   rootJobId: String # Root job ID for provenance chain queries
   ```

2. Add `LlamaLogChainResponse` type (near other LlamaLog types around line 1830):
   ```graphql
   type LlamaLogChainResponse {
     logs: [LlamaLog!]!
     totalCount: Int!
     cursor: String
     hasMore: Boolean!
   }
   ```

3. Add `llamaLogChain` query to the Query type (in the "Enrichment Logging queries" section after `llamaLogs`):
   ```graphql
   # Provenance chain for entity lifecycle tracking
   llamaLogChain(
     entityType: EnrichmentEntityType!
     entityId: UUID!
     categories: [LlamaLogCategory!]
     startDate: DateTime
     endDate: DateTime
     limit: Int = 20
     cursor: String
   ): LlamaLogChainResponse!
   ```

Place types logically with existing LlamaLog-related definitions.
  </action>
  <verify>Search schema for "llamaLogChain" and "LlamaLogChainResponse" - both should exist</verify>
  <done>GraphQL schema contains llamaLogChain query definition, LlamaLogChainResponse type, and rootJobId field on LlamaLog</done>
</task>

<task type="auto">
  <name>Task 2: Resolver implementation</name>
  <files>src/lib/graphql/resolvers/queries.ts</files>
  <action>
Add `llamaLogChain` resolver to the Query resolvers (after the existing `llamaLogs` resolver).

Implementation follows RESEARCH.md patterns:

```typescript
llamaLogChain: async (_, args, { prisma }) => {
  const {
    entityType,
    entityId,
    categories,
    startDate,
    endDate,
    limit = 20,
    cursor,
  } = args;

  // 1. Validate entity exists
  const entityTable = entityType.toLowerCase() as 'album' | 'artist' | 'track';
  
  // Album has 'title', Artist has 'name', Track has 'title'
  const nameField = entityTable === 'artist' ? 'name' : 'title';
  
  const entity = await prisma[entityTable].findUnique({
    where: { id: entityId },
    select: { id: true, [nameField]: true },
  });

  if (!entity) {
    throw new GraphQLError(`${entityType} not found: ${entityId}`, {
      extensions: { code: 'NOT_FOUND' },
    });
  }

  // 2. Build where clause using typed ID field for index usage
  const typedIdField = `${entityTable}Id` as 'albumId' | 'artistId' | 'trackId';
  
  // Use OR to match both typed ID field and generic entityId (for historical data)
  const baseWhere = {
    OR: [
      { [typedIdField]: entityId },
      { entityId: entityId, entityType },
    ],
  };

  // Build date filter (merge gte/lte if both provided)
  const dateFilter: Record<string, Date> = {};
  if (startDate) dateFilter.gte = startDate;
  if (endDate) dateFilter.lte = endDate;

  const where = {
    ...baseWhere,
    ...(categories && categories.length > 0 && { category: { in: categories } }),
    ...(Object.keys(dateFilter).length > 0 && { createdAt: dateFilter }),
  };

  // 3. Fetch logs and count in parallel
  const [logs, totalCount] = await Promise.all([
    prisma.llamaLog.findMany({
      take: limit + 1,
      skip: cursor ? 1 : 0,
      cursor: cursor ? { id: cursor } : undefined,
      orderBy: [{ createdAt: 'desc' }, { id: 'desc' }],
      where,
    }),
    prisma.llamaLog.count({ where }),
  ]);

  // 4. Compute pagination metadata
  const hasMore = logs.length > limit;
  const items = hasMore ? logs.slice(0, -1) : logs;
  const nextCursor = hasMore && items.length > 0 ? items[items.length - 1].id : null;

  return {
    logs: items.map(log => ({ ...log, children: null })),
    totalCount,
    cursor: nextCursor,
    hasMore,
  };
},
```

Key implementation notes:
- Uses typed ID fields (albumId/artistId/trackId) for better index usage
- Falls back to generic entityId for pre-Phase 29 historical data
- Includes stable sort (createdAt + id) to prevent pagination issues
- Maps logs with `children: null` to match LlamaLog type expectations
- GraphQLError import already exists at top of file
  </action>
  <verify>
Run type check: `pnpm type-check` should pass (may have pre-existing errors unrelated to this change)
Search for "llamaLogChain:" in queries.ts - resolver should exist
  </verify>
  <done>llamaLogChain resolver implemented with entity validation, cursor pagination, category filtering, and date range filtering</done>
</task>

<task type="auto">
  <name>Task 3: Client query and codegen</name>
  <files>src/graphql/queries/llamaLogChain.graphql, src/generated/graphql.ts</files>
  <action>
1. Create new file `src/graphql/queries/llamaLogChain.graphql`:

```graphql
query GetLlamaLogChain(
  $entityType: EnrichmentEntityType!
  $entityId: UUID!
  $categories: [LlamaLogCategory!]
  $startDate: DateTime
  $endDate: DateTime
  $limit: Int = 20
  $cursor: String
) {
  llamaLogChain(
    entityType: $entityType
    entityId: $entityId
    categories: $categories
    startDate: $startDate
    endDate: $endDate
    limit: $limit
    cursor: $cursor
  ) {
    logs {
      id
      entityType
      entityId
      operation
      sources
      status
      category
      reason
      fieldsEnriched
      dataQualityBefore
      dataQualityAfter
      errorMessage
      errorCode
      durationMs
      apiCallCount
      metadata
      createdAt
      jobId
      parentJobId
      rootJobId
    }
    totalCount
    cursor
    hasMore
  }
}
```

2. Run codegen: `pnpm codegen`

This regenerates `src/generated/graphql.ts` with:
- `GetLlamaLogChainQuery` type
- `GetLlamaLogChainQueryVariables` type
- `useGetLlamaLogChainQuery` hook
- `LlamaLogChainResponse` type
  </action>
  <verify>
Run `pnpm codegen` - should complete successfully
Search generated/graphql.ts for "LlamaLogChainResponse" - type should exist
Search generated/graphql.ts for "useGetLlamaLogChainQuery" - hook should exist
  </verify>
  <done>Client query file created, codegen successful, generated types include LlamaLogChainResponse and useGetLlamaLogChainQuery hook</done>
</task>

</tasks>

<verification>
Run verification commands:

1. Type check passes:
   ```bash
   pnpm type-check
   ```

2. Schema validates:
   ```bash
   npx prisma validate
   ```

3. GraphQL codegen succeeds:
   ```bash
   pnpm codegen
   ```

4. Grep checks:
   ```bash
   grep "llamaLogChain" src/graphql/schema.graphql
   grep "llamaLogChain:" src/lib/graphql/resolvers/queries.ts
   grep "LlamaLogChainResponse" src/generated/graphql.ts
   ```
</verification>

<success_criteria>
1. **Query exists:** `llamaLogChain` query defined in GraphQL schema with all parameters (entityType, entityId, categories, startDate, endDate, limit, cursor)
2. **Response type exists:** `LlamaLogChainResponse` type with logs, totalCount, cursor, hasMore fields
3. **Resolver works:** Resolver validates entity exists, queries logs with filters, returns paginated results
4. **Client query exists:** `llamaLogChain.graphql` file with complete query fields
5. **Types generated:** `pnpm codegen` produces `useGetLlamaLogChainQuery` hook and related types
6. **rootJobId exposed:** LlamaLog type includes rootJobId field for chain queries
</success_criteria>

<output>
After completion, create `.planning/phases/32-query-provenance/32-01-SUMMARY.md`
</output>
