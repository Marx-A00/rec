---
phase: 11-artist-correction
plan: 03
type: execute
wave: 2
depends_on: ['11-01', '11-02']
files_modified:
  - src/lib/correction/artist/apply/types.ts
  - src/lib/correction/artist/apply/apply-service.ts
  - src/graphql/schema.graphql
  - src/lib/graphql/resolvers/queries.ts
  - src/lib/graphql/resolvers/mutations.ts
  - src/graphql/queries/artistCorrection.graphql
autonomous: true

must_haves:
  truths:
    - 'Artist corrections are applied atomically with optimistic locking'
    - 'Corrections are logged in enrichment_logs with admin user ID'
    - 'GraphQL exposes artist correction search, preview, and apply operations'
  artifacts:
    - path: 'src/lib/correction/artist/apply/types.ts'
      provides: 'ArtistApplyInput, ArtistFieldSelections, ArtistApplyResult types'
      exports:
        ['ArtistApplyInput', 'ArtistFieldSelections', 'ArtistApplyResult']
    - path: 'src/lib/correction/artist/apply/apply-service.ts'
      provides: 'ArtistCorrectionApplyService class'
      exports: ['ArtistCorrectionApplyService']
    - path: 'src/graphql/schema.graphql'
      provides: 'Artist correction types and operations'
      contains: 'artistCorrectionSearch'
    - path: 'src/graphql/queries/artistCorrection.graphql'
      provides: 'Client queries for artist correction'
      contains: 'SearchArtistCorrectionCandidates'
  key_links:
    - from: 'src/lib/correction/artist/apply/apply-service.ts'
      to: 'prisma.artist.update'
      via: 'Atomic artist update'
      pattern: "prisma\\.artist\\.update"
    - from: 'src/lib/correction/artist/apply/apply-service.ts'
      to: 'prisma.enrichmentLog.create'
      via: 'Audit logging'
      pattern: "prisma\\.enrichmentLog\\.create"
    - from: 'src/lib/graphql/resolvers/queries.ts'
      to: 'src/lib/correction/artist/search-service.ts'
      via: 'artistCorrectionSearch resolver'
      pattern: 'ArtistCorrectionSearchService'
---

<objective>
Create the artist apply service with audit logging and extend GraphQL schema for artist correction operations.

Purpose: Enable atomic application of artist corrections with full audit trail, exposed via GraphQL API.
Output: ArtistCorrectionApplyService with optimistic locking, GraphQL schema with search/preview/apply operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-artist-correction/11-RESEARCH.md
@.planning/phases/11-artist-correction/11-CONTEXT.md
@.planning/phases/11-artist-correction/11-01-SUMMARY.md
@.planning/phases/11-artist-correction/11-02-SUMMARY.md

# Album apply service and GraphQL for pattern reference

@src/lib/correction/apply/types.ts
@src/lib/correction/apply/apply-service.ts
@src/graphql/schema.graphql
@src/lib/graphql/resolvers/queries.ts
@src/lib/graphql/resolvers/mutations.ts
@src/graphql/queries/correctionSearch.graphql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create artist apply types and service</name>
  <files>
    src/lib/correction/artist/apply/types.ts
    src/lib/correction/artist/apply/apply-service.ts
  </files>
  <action>
Create apply types and service for artist corrections, mirroring album apply pattern.

In types.ts, define:

- ArtistMetadataSelections: { name?: boolean, disambiguation?: boolean, countryCode?: boolean, artistType?: boolean, area?: boolean, beginDate?: boolean, endDate?: boolean, gender?: boolean }
- ArtistExternalIdSelections: { musicbrainzId?: boolean, ipi?: boolean, isni?: boolean }
- ArtistFieldSelections: { metadata: ArtistMetadataSelections, externalIds: ArtistExternalIdSelections }
- ArtistApplyInput: { artistId, preview: ArtistCorrectionPreview, selections: ArtistFieldSelections, expectedUpdatedAt: Date, adminUserId }
- ArtistApplyResult: { success: boolean, artist?: Artist, changes?: ArtistAppliedChanges, affectedAlbumCount?: number, error?: { code, message } }

In apply-service.ts, create ArtistCorrectionApplyService:

1. applyCorrection(input: ArtistApplyInput): Promise<ArtistApplyResult>
   - Fetch current artist for audit "before" state
   - Run transaction with Serializable isolation:
     - Optimistic locking: check expectedUpdatedAt matches current.updatedAt
     - Build update data from selections + preview.mbArtistData
     - Update artist with dataQuality: 'HIGH', enrichmentStatus: 'COMPLETED'
     - Count affected albums via albumArtist
   - Post-transaction: log to enrichmentLog with entityType: 'ARTIST'

2. buildArtistUpdateData(preview, selections) helper:
   - Only include fields where selection is true
   - Map mbArtistData fields to Prisma update shape

3. logCorrection(artistId, adminUserId, before, after, selections) helper:
   - Create enrichmentLog with operation: 'admin_correction'
   - Store before/after state in metadata JSON

4. Error handling: StaleDataError for optimistic lock failures

Export: ArtistCorrectionApplyService and getArtistCorrectionApplyService factory
</action>
<verify>Run `pnpm type-check` - apply service compiles</verify>
<done>ArtistCorrectionApplyService.applyCorrection() applies changes atomically with audit logging</done>
</task>

<task type="auto">
  <name>Task 2: Extend GraphQL schema and resolvers</name>
  <files>
    src/graphql/schema.graphql
    src/lib/graphql/resolvers/queries.ts
    src/lib/graphql/resolvers/mutations.ts
    src/graphql/queries/artistCorrection.graphql
  </files>
  <action>
Extend GraphQL schema with artist correction types and operations.

In schema.graphql, add near existing correction types:

- ArtistSearchResult type (mirrors service type)
- ArtistCorrectionSearchResponse type
- ArtistFieldDiff type
- ArtistCorrectionPreview type (with albumCount!)
- ArtistFieldSelections input
- ArtistCorrectionApplyInput input
- ArtistCorrectionApplyResult type

Add Query operations:

- artistCorrectionSearch(query: String!, limit: Int): ArtistCorrectionSearchResponse!
- artistCorrectionPreview(artistId: UUID!, artistMbid: UUID!): ArtistCorrectionPreview!

Add Mutation:

- artistCorrectionApply(input: ArtistCorrectionApplyInput!): ArtistCorrectionApplyResult!

In queries.ts, add resolvers:

- artistCorrectionSearch: call ArtistCorrectionSearchService.search()
- artistCorrectionPreview: call ArtistCorrectionPreviewService.generatePreview()
- Both require admin role check

In mutations.ts, add resolver:

- artistCorrectionApply: call ArtistCorrectionApplyService.applyCorrection()
- Require admin role check, extract userId from context

In artistCorrection.graphql, create client queries:

- SearchArtistCorrectionCandidates query
- GetArtistCorrectionPreview query
- ApplyArtistCorrection mutation
  Use prefixes to avoid collision with album correction operations.
  </action>
  <verify>Run `pnpm codegen` - generates without errors, then `pnpm type-check`</verify>
  <done>GraphQL operations for artist correction available and codegen generates hooks</done>
  </task>

</tasks>

<verification>
```bash
pnpm codegen
pnpm type-check
# Both should pass

# Manual verification:

# - Check schema includes artistCorrectionSearch, artistCorrectionPreview, artistCorrectionApply

# - Check generated/graphql.ts includes useSearchArtistCorrectionCandidatesQuery

# - Check resolvers have admin role checks

```
</verification>

<success_criteria>
1. ArtistCorrectionApplyService uses Serializable isolation and optimistic locking
2. Corrections logged to enrichment_logs with entityType: 'ARTIST'
3. GraphQL schema has all three operations (search, preview, apply)
4. Codegen produces React Query hooks for client use
5. Admin role enforced on all operations
</success_criteria>

<output>
After completion, create `.planning/phases/11-artist-correction/11-03-SUMMARY.md`
</output>
```
