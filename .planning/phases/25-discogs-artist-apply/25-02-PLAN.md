---
phase: 25-discogs-artist-apply
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/correction/artist/apply/apply-service.ts
  - src/lib/correction/artist/apply/types.ts
autonomous: true

must_haves:
  truths:
    - "ArtistExternalIdSelections includes discogsId field"
    - "Apply service stores discogsId when source is discogs"
    - "Enrichment log records correct source (musicbrainz or discogs)"
    - "CACHE_ARTIST_IMAGE job queued when imageUrl changes"
    - "Artist.source field updated based on correction source"
  artifacts:
    - path: "src/lib/correction/artist/apply/apply-service.ts"
      provides: "Source-aware external ID storage and image caching"
      contains: "discogsId"
    - path: "src/lib/correction/artist/apply/types.ts"
      provides: "discogsId in ArtistExternalIdSelections"
      contains: "discogsId"
  key_links:
    - from: "src/lib/correction/artist/apply/apply-service.ts"
      to: "src/lib/queue/musicbrainz-queue.ts"
      via: "queues CACHE_ARTIST_IMAGE job"
      pattern: "CACHE_ARTIST_IMAGE"
---

<objective>
Extend artist apply service for Discogs source support.

Purpose: Enable applying artist corrections from Discogs, storing discogsId instead of musicbrainzId and queuing image upload to Cloudflare. The apply service needs to handle source-conditional external ID storage and image caching.

Output: Apply service can store Discogs artist ID when source is discogs, queue Cloudflare image upload, and log the correct source in enrichment logs.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-discogs-artist-apply/25-RESEARCH.md
@.planning/phases/25-discogs-artist-apply/25-CONTEXT.md
@.planning/phases/23-discogs-album-apply/23-02-SUMMARY.md

@src/lib/correction/artist/apply/apply-service.ts
@src/lib/correction/artist/apply/types.ts
@src/lib/correction/artist/preview/types.ts
@src/lib/queue/musicbrainz-queue.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add discogsId to field selection types</name>
  <files>src/lib/correction/artist/apply/types.ts</files>
  <action>
**Update ArtistExternalIdSelections interface** (around line 42):

Add discogsId field after musicbrainzId:

```typescript
export interface ArtistExternalIdSelections {
  /** MusicBrainz artist ID */
  musicbrainzId?: boolean;
  /** Discogs artist ID */
  discogsId?: boolean;
  /** IPI code (Interested Parties Information) */
  ipi?: boolean;
  /** ISNI code (International Standard Name Identifier) */
  isni?: boolean;
}
```

**Update createDefaultArtistSelections function** (around line 60):

Add discogsId to externalIds:

```typescript
export function createDefaultArtistSelections(): ArtistFieldSelections {
  return {
    metadata: {
      name: true,
      disambiguation: true,
      countryCode: true,
      artistType: true,
      area: true,
      beginDate: true,
      endDate: true,
      gender: true,
    },
    externalIds: {
      musicbrainzId: true,
      discogsId: true,  // Add this
      ipi: true,
      isni: true,
    },
  };
}
```

**Add imageUrl to ArtistMetadataSelections** (around line 21):

```typescript
export interface ArtistMetadataSelections {
  /** Artist name */
  name?: boolean;
  /** Disambiguation comment */
  disambiguation?: boolean;
  /** ISO 3166-1 alpha-2 country code */
  countryCode?: boolean;
  /** Artist type (Person, Group, Orchestra, etc.) */
  artistType?: boolean;
  /** Area/city of origin */
  area?: boolean;
  /** Begin date (birth/formation) */
  beginDate?: boolean;
  /** End date (death/dissolution) */
  endDate?: boolean;
  /** Gender (only meaningful for Person type) */
  gender?: boolean;
  /** Image URL */
  imageUrl?: boolean;  // Add this
}
```

And add imageUrl: true to createDefaultArtistSelections metadata.
  </action>
  <verify>pnpm type-check passes</verify>
  <done>ArtistExternalIdSelections includes discogsId, ArtistMetadataSelections includes imageUrl</done>
</task>

<task type="auto">
  <name>Task 2: Update apply service for source-conditional external ID storage</name>
  <files>src/lib/correction/artist/apply/apply-service.ts</files>
  <action>
**1. Add imports at top of file:**

```typescript
import { getMusicBrainzQueue, JOB_TYPES } from '@/lib/queue';
import type { CorrectionSource } from '../preview/types';
```

**2. Update buildArtistUpdateData method** (around line 168):

Add source parameter and make external ID storage source-conditional. Update the entire method:

```typescript
private buildArtistUpdateData(
  preview: ArtistCorrectionPreview,
  selections: ArtistFieldSelections
): Prisma.ArtistUpdateInput {
  const updateData: Prisma.ArtistUpdateInput = {};
  const mbData = preview.mbArtistData;
  
  // Determine source - check if mbData.id looks like a Discogs ID (numeric string)
  // or MusicBrainz ID (UUID format). Default to musicbrainz for backward compatibility.
  const isDiscogs = mbData?.id && /^\d+$/.test(mbData.id);
  const source: CorrectionSource = isDiscogs ? 'discogs' : 'musicbrainz';

  if (!mbData) {
    return updateData;
  }

  // Metadata fields
  if (selections.metadata.name && mbData.name) {
    updateData.name = mbData.name;
  }
  if (selections.metadata.disambiguation) {
    updateData.biography = mbData.disambiguation ?? null;
  }
  if (selections.metadata.countryCode && source === 'musicbrainz') {
    updateData.countryCode = mbData.country ?? null;
  }
  if (selections.metadata.artistType && source === 'musicbrainz') {
    updateData.artistType = mbData.type ?? null;
  }
  if (selections.metadata.area && source === 'musicbrainz') {
    updateData.area = mbData.area?.name ?? null;
  }
  if (selections.metadata.beginDate && source === 'musicbrainz') {
    // Store begin year as formedYear if available
    const beginYear = mbData.lifeSpan?.begin
      ? parseInt(mbData.lifeSpan.begin.substring(0, 4), 10)
      : null;
    if (beginYear && !isNaN(beginYear)) {
      updateData.formedYear = beginYear;
    }
  }

  // External ID fields (source-conditional)
  if (source === 'musicbrainz' && selections.externalIds.musicbrainzId && mbData.id) {
    updateData.musicbrainzId = mbData.id;
    updateData.source = 'MUSICBRAINZ';
  } else if (source === 'discogs' && selections.externalIds.discogsId && mbData.id) {
    updateData.discogsId = mbData.id;  // Already string (numeric)
    updateData.source = 'DISCOGS';
  }

  return updateData;
}
```

**3. Update logCorrection method** (around line 220):

Add preview parameter and use actual source in enrichment log:

```typescript
private async logCorrection(
  artistId: string,
  adminUserId: string,
  beforeArtist: Artist,
  afterArtist: Artist,
  selections: ArtistFieldSelections,
  preview: ArtistCorrectionPreview  // Add this parameter
): Promise<void> {
  try {
    // Determine source from preview
    const isDiscogs = preview.mbArtistData?.id && /^\d+$/.test(preview.mbArtistData.id);
    const source = isDiscogs ? 'discogs' : 'musicbrainz';
    
    // Build audit payload with only changed fields
    const auditPayload = this.buildAuditPayload(
      beforeArtist,
      afterArtist,
      selections,
      source  // Pass source
    );

    // Build list of changed field names
    const changedFields = this.getChangedFieldNames(auditPayload);

    await this.prisma.enrichmentLog.create({
      data: {
        entityType: 'ARTIST',
        artistId,
        userId: adminUserId,
        operation: 'admin_correction',
        status: 'SUCCESS',
        sources: [source],  // Use actual source instead of hardcoded
        fieldsEnriched: changedFields,
        dataQualityBefore: beforeArtist.dataQuality,
        dataQualityAfter: 'HIGH',
        metadata: auditPayload as unknown as Prisma.JsonObject,
        triggeredBy: 'admin_ui',
      },
    });
  } catch (error) {
    // Log warning but don't fail the correction
    console.warn(
      '[ArtistCorrectionApplyService] Failed to log correction:',
      error
    );
  }
}
```

**4. Update applyCorrection to pass preview to logCorrection** (around line 100):

Find the logCorrection call and update it:

```typescript
// Log correction (outside transaction - logging failure should not fail correction)
await this.logCorrection(
  artistId,
  adminUserId,
  beforeArtist,
  afterArtist!,
  selections,
  preview  // Add preview parameter
);
```
  </action>
  <verify>pnpm type-check passes</verify>
  <done>Apply service stores discogsId when source is discogs, enrichment log records correct source</done>
</task>

<task type="auto">
  <name>Task 3: Add Cloudflare image upload queueing and update audit logging</name>
  <files>src/lib/correction/artist/apply/apply-service.ts</files>
  <action>
**1. Add image upload queueing method** (after logCorrection method):

```typescript
/**
 * Queue Cloudflare image caching for the artist.
 * Uses CACHE_ARTIST_IMAGE job via BullMQ.
 */
private async queueImageUpload(artistId: string): Promise<void> {
  try {
    const queue = getMusicBrainzQueue();
    
    await queue.addJob(
      JOB_TYPES.CACHE_ARTIST_IMAGE,
      {
        artistId,
        requestId: `artist-correction-${artistId}-${Date.now()}`,
      },
      {
        priority: 6, // Medium priority for admin corrections
        attempts: 3,
        backoff: { type: 'exponential', delay: 2000 },
      }
    );
    
    console.log(`[ArtistCorrectionApplyService] Queued image caching for artist ${artistId}`);
  } catch (error) {
    // Log warning but don't fail the correction
    console.warn(
      '[ArtistCorrectionApplyService] Failed to queue image caching:',
      error
    );
  }
}
```

**2. Update applyCorrection to queue image upload** (in the post-transaction phase, after logCorrection):

```typescript
// Queue Cloudflare image caching if imageUrl changed
const imageChanged = 
  afterArtist?.imageUrl && 
  beforeArtist.imageUrl !== afterArtist.imageUrl;
if (imageChanged) {
  await this.queueImageUpload(artistId);
}
```

**3. Update buildAuditPayload to include discogsId** (around line 250):

Add source parameter and handle discogsId in externalIds:

```typescript
private buildAuditPayload(
  beforeArtist: Artist,
  afterArtist: Artist,
  selections: ArtistFieldSelections,
  source: 'musicbrainz' | 'discogs' = 'musicbrainz'  // Add parameter
): ArtistAuditLogPayload {
  // Metadata field deltas (existing code)
  const metadata: ArtistFieldDelta[] = [];
  // ... existing metadata delta code ...

  // External ID deltas (update for source-conditional)
  const externalIds: ArtistFieldDelta[] = [];
  
  if (source === 'musicbrainz' && 
      selections.externalIds.musicbrainzId &&
      beforeArtist.musicbrainzId !== afterArtist.musicbrainzId) {
    externalIds.push({
      field: 'musicbrainzId',
      before: beforeArtist.musicbrainzId,
      after: afterArtist.musicbrainzId,
    });
  } else if (source === 'discogs' && 
             selections.externalIds.discogsId &&
             beforeArtist.discogsId !== afterArtist.discogsId) {
    externalIds.push({
      field: 'discogsId',
      before: beforeArtist.discogsId,
      after: afterArtist.discogsId,
    });
  }

  return { metadata, externalIds };
}
```

**4. Update buildAppliedChanges to include discogsId** (around line 290):

Add source parameter and handle discogsId:

```typescript
private buildAppliedChanges(
  beforeArtist: Artist,
  afterArtist: Artist,
  affectedAlbumCount: number,
  selections: ArtistFieldSelections,
  source: 'musicbrainz' | 'discogs' = 'musicbrainz'  // Add parameter
): ArtistAppliedChanges {
  // ... existing metadata code ...

  const externalIds: string[] = [];
  
  if (source === 'musicbrainz' &&
      selections.externalIds.musicbrainzId &&
      beforeArtist.musicbrainzId !== afterArtist.musicbrainzId) {
    externalIds.push('musicbrainzId');
  } else if (source === 'discogs' &&
             selections.externalIds.discogsId &&
             beforeArtist.discogsId !== afterArtist.discogsId) {
    externalIds.push('discogsId');
  }

  return {
    metadata,
    externalIds,
    affectedAlbumCount,
    dataQualityBefore: beforeArtist.dataQuality ?? 'LOW',
    dataQualityAfter: 'HIGH',
  };
}
```

**5. Update the call to buildAppliedChanges in applyCorrection** to pass source:

Determine source from preview and pass it:

```typescript
// Determine source from preview
const isDiscogs = preview.mbArtistData?.id && /^\d+$/.test(preview.mbArtistData.id);
const source: 'musicbrainz' | 'discogs' = isDiscogs ? 'discogs' : 'musicbrainz';

// Build response
const changes = this.buildAppliedChanges(
  beforeArtist,
  afterArtist!,
  result.affectedAlbumCount,
  selections,
  source  // Add source parameter
);
```
  </action>
  <verify>pnpm type-check passes</verify>
  <done>Image caching queued on imageUrl change, audit logging includes discogsId correctly</done>
</task>

</tasks>

<verification>
- [ ] pnpm type-check passes
- [ ] ArtistExternalIdSelections has discogsId field
- [ ] ArtistMetadataSelections has imageUrl field
- [ ] buildArtistUpdateData stores discogsId when source is discogs
- [ ] buildArtistUpdateData sets Artist.source to DISCOGS when source is discogs
- [ ] logCorrection uses actual source (not hardcoded 'musicbrainz')
- [ ] queueImageUpload method exists and queues CACHE_ARTIST_IMAGE
- [ ] Audit logging includes discogsId in externalIds when applicable
</verification>

<success_criteria>
Artist apply service is source-agnostic:
- Can store either musicbrainzId or discogsId based on source
- Artist.source field updated to reflect data source
- Enrichment log records correct source
- Cloudflare image caching queued when imageUrl changes
- Audit trail correctly tracks discogsId changes
</success_criteria>

<output>
After completion, create .planning/phases/25-discogs-artist-apply/25-02-SUMMARY.md
</output>
