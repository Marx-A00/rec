---
phase: 36-image-reveal-engine
plan: 02
type: execute
wave: 2
depends_on: ["36-01"]
files_modified:
  - src/components/uncover/RevealCanvas.tsx
  - src/hooks/useRevealImage.ts
autonomous: true

must_haves:
  truths:
    - "Canvas displays pixelated album art at stage 1"
    - "Revealed tiles show clear image, unrevealed show pixelated"
    - "Stage 6 shows fully clear image"
    - "Canvas scales correctly on retina displays"
  artifacts:
    - path: "src/components/uncover/RevealCanvas.tsx"
      provides: "Canvas-based pixelation renderer"
      min_lines: 100
    - path: "src/hooks/useRevealImage.ts"
      provides: "Hook for reveal state and tile computation"
      exports: ["useRevealImage"]
  key_links:
    - from: "src/components/uncover/RevealCanvas.tsx"
      to: "src/lib/uncover/reveal-pattern.ts"
      via: "imports getTilesForStage"
      pattern: "import.*reveal-pattern"
    - from: "src/components/uncover/RevealCanvas.tsx"
      to: "src/hooks/useRevealImage.ts"
      via: "uses hook for tile state"
      pattern: "useRevealImage"
---

<objective>
Build the canvas-based pixelation renderer that displays album art with tile-based progressive reveal.

Purpose: Implement REVEAL-01 (pixelation style) and REVEAL-05 (6 stages) requirements using Canvas API.
Output: RevealCanvas component and useRevealImage hook for managing reveal state.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/36-image-reveal-engine/36-CONTEXT.md
@.planning/phases/36-image-reveal-engine/36-RESEARCH.md
@.planning/phases/36-image-reveal-engine/36-01-SUMMARY.md
@src/lib/uncover/seeded-random.ts
@src/lib/uncover/reveal-pattern.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useRevealImage hook</name>
  <files>
    - src/hooks/useRevealImage.ts
  </files>
  <action>
Create src/hooks/useRevealImage.ts that manages reveal state:

```typescript
interface UseRevealImageOptions {
  challengeId: string;       // For deterministic seed
  stage: number;             // Current reveal stage (1-6)
  totalStages?: number;      // Default 6
}

interface UseRevealImageResult {
  revealedTiles: Tile[];     // Tiles to show clear
  allTiles: Tile[];          // All 256 tiles in reveal order
  revealProgress: number;    // 0-1 percentage revealed
  seed: string;              // The seed used for ordering
}
```

Implementation:
1. Generate seed from challengeId: `uncover-${challengeId}`
2. Use useMemo to generate tile grid once
3. Use useMemo to compute ordered tiles (distance ordering + shuffle with seed)
4. Use useMemo to compute revealed tiles for current stage
5. Compute revealProgress as revealedTiles.length / allTiles.length

Import from:
- src/lib/uncover/reveal-pattern.ts: generateTileGrid, orderTilesByDistance, shuffleTilesWithSeed, getTilesForStage

Add JSDoc documentation.
  </action>
  <verify>
`pnpm type-check` passes
  </verify>
  <done>
useRevealImage hook returns computed tile state for a given stage and challengeId.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RevealCanvas component</name>
  <files>
    - src/components/uncover/RevealCanvas.tsx
  </files>
  <action>
Create src/components/uncover/RevealCanvas.tsx:

```typescript
'use client';

interface RevealCanvasProps {
  imageUrl: string;          // Album art URL
  challengeId: string;       // For deterministic reveal order
  stage: number;             // Current reveal stage (1-6)
  className?: string;        // For sizing
  onLoad?: () => void;       // When image loads
  onError?: () => void;      // When image fails
}
```

Implementation details:

1. **Image loading:**
   - Use native `new Image()` constructor (NOT Next.js Image)
   - Set `crossOrigin = 'anonymous'` for CORS
   - Track loading state with useState
   - Call onLoad/onError callbacks

2. **Canvas setup:**
   - Use useRef for canvas element
   - Use ResizeObserver for responsive sizing
   - Handle devicePixelRatio for retina displays:
     ```typescript
     const dpr = window.devicePixelRatio || 1;
     canvas.width = rect.width * dpr;
     canvas.height = rect.height * dpr;
     canvas.style.width = `${rect.width}px`;
     canvas.style.height = `${rect.height}px`;
     ctx.scale(dpr, dpr);
     ```

3. **Tile-based pixelation rendering:**
   - Get tiles from useRevealImage hook
   - Draw pixelated base layer first:
     ```typescript
     ctx.imageSmoothingEnabled = false;
     const pixelSize = 16; // Fixed pixelation for unrevealed
     ctx.drawImage(img, 0, 0, width/pixelSize, height/pixelSize);
     ctx.drawImage(canvas, 0, 0, width/pixelSize, height/pixelSize, 0, 0, width, height);
     ```
   - Then draw clear tiles over revealed regions:
     ```typescript
     ctx.imageSmoothingEnabled = true;
     for (const tile of revealedTiles) {
       const tileWidth = width / 16;
       const tileHeight = height / 16;
       ctx.drawImage(
         img,
         tile.x * tileWidth, tile.y * tileHeight, tileWidth, tileHeight, // source
         tile.x * tileWidth, tile.y * tileHeight, tileWidth, tileHeight  // dest
       );
     }
     ```

4. **Cleanup:**
   - Return cleanup function from useEffect for ResizeObserver
   - Clean up image loading if component unmounts

5. **Styling:**
   - Canvas fills container via CSS (aspect-ratio: 1)
   - Apply className for external sizing control

Add loading skeleton while image loads.
  </action>
  <verify>
`pnpm type-check` passes
`pnpm lint` passes
  </verify>
  <done>
RevealCanvas component renders canvas with tile-based pixelation reveal at any stage 1-6.
  </done>
</task>

</tasks>

<verification>
1. `pnpm type-check` passes
2. `pnpm lint` passes
3. Component can be imported without errors
4. Hook returns correct tile counts per stage (stage 1 ~16%, stage 6 100%)
</verification>

<success_criteria>
1. useRevealImage hook computes tiles based on challengeId and stage
2. Same challengeId always produces same tile ordering
3. RevealCanvas displays pixelated base with clear revealed tiles
4. Canvas scales properly on retina displays
5. ResizeObserver handles responsive sizing
</success_criteria>

<output>
After completion, create `.planning/phases/36-image-reveal-engine/36-02-SUMMARY.md`
</output>
