---
phase: 22-discogs-album-search
plan: 02
type: execute
wave: 2
depends_on: ['22-01']
files_modified:
  - src/graphql/schema.graphql
  - src/lib/graphql/resolvers/queries.ts
  - src/graphql/queries/correctionSearch.graphql
autonomous: true

must_haves:
  truths:
    - 'GraphQL correctionSearch accepts source parameter'
    - 'Resolver routes to QueuedDiscogsService when source is DISCOGS'
    - 'Discogs results return same GraphQL shape as MusicBrainz results'
  artifacts:
    - path: 'src/graphql/schema.graphql'
      provides: 'CorrectionSource enum and source field on input'
      contains: 'source: CorrectionSource'
    - path: 'src/lib/graphql/resolvers/queries.ts'
      provides: 'Source-aware routing in correctionSearch resolver'
      contains: 'getQueuedDiscogsService'
  key_links:
    - from: 'src/lib/graphql/resolvers/queries.ts'
      to: 'src/lib/discogs/queued-service.ts'
      via: 'getQueuedDiscogsService import'
      pattern: 'getQueuedDiscogsService'
    - from: 'src/graphql/queries/correctionSearch.graphql'
      to: 'src/graphql/schema.graphql'
      via: 'CorrectionSource type usage'
      pattern: 'source:'
---

<objective>
Extend GraphQL layer to support Discogs as a correction source.

Purpose: Allow frontend to request Discogs album search via existing correctionSearch query.
Output: GraphQL schema with source parameter, resolver routing to QueuedDiscogsService.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-discogs-album-search/22-CONTEXT.md
@.planning/phases/22-discogs-album-search/22-01-SUMMARY.md

<!-- Existing GraphQL patterns -->

@src/graphql/schema.graphql
@src/lib/graphql/resolvers/queries.ts
@src/graphql/queries/correctionSearch.graphql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CorrectionSource enum and extend input</name>
  <files>
    src/graphql/schema.graphql
  </files>
  <action>
1. Add CorrectionSource enum near other enums (after ScoringStrategy enum):
   ```graphql
   """
   Source for correction data.
   """
   enum CorrectionSource {
     MUSICBRAINZ
     DISCOGS
   }
   ```

2. Add source field to CorrectionSearchInput (after existing fields):

   ```graphql
   """
   Data source to search (default: MUSICBRAINZ)
   """
   source: CorrectionSource = MUSICBRAINZ
   ```

3. Ensure ScoredSearchResult has source field in schema (check if already there, it should map to the types.ts source field). If not present, add:
   ```graphql
   """
   Data source this result came from
   """
   source: String!
   ```
   (This should already exist from the existing schema supporting MusicBrainz)
   </action>
   <verify>
   Schema validates: `pnpm codegen` succeeds
   </verify>
   <done>
   CorrectionSource enum defined, CorrectionSearchInput accepts source parameter with MUSICBRAINZ default.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Update resolver to route by source via QueuedDiscogsService</name>
  <files>
    src/lib/graphql/resolvers/queries.ts
  </files>
  <action>
1. Add import at top of file:
   ```typescript
   import { getQueuedDiscogsService } from '@/lib/discogs/queued-service';
   ```

2. In the correctionSearch resolver, after extracting input fields, add source extraction:

   ```typescript
   const { source = 'MUSICBRAINZ' } = input;
   ```

3. Add conditional routing based on source. Before the existing MusicBrainz search logic:

   ```typescript
   // Route to Discogs via queue if source is DISCOGS
   if (source === 'DISCOGS') {
     const queuedDiscogsService = getQueuedDiscogsService();
     const discogsResponse = await queuedDiscogsService.searchAlbums({
       albumId: input.albumId,
       albumTitle: searchAlbumTitle,
       artistName: searchArtistName,
       limit: limit ?? 10,
     });

     // Transform Discogs results to GraphQL format
     // Discogs doesn't have scoring, so wrap each result as a single-item group
     const transformedResults = discogsResponse.results.map(result => ({
       releaseGroupMbid: result.releaseGroupMbid,
       primaryResult: {
         ...result,
         normalizedScore: 1.0,
         displayScore: 100,
         breakdown: {
           titleScore: 1.0,
           artistScore: 1.0,
           yearScore: 1.0,
           mbScore: 1.0,
           confidenceTier: 'HIGH',
         },
         isLowConfidence: false,
       },
       alternateVersions: [],
       versionCount: 1,
       bestScore: 1.0,
     }));

     return {
       results: transformedResults,
       totalGroups: transformedResults.length,
       hasMore: discogsResponse.hasMore,
       query: {
         albumTitle: discogsResponse.query.albumTitle ?? null,
         artistName: discogsResponse.query.artistName ?? null,
         yearFilter: null,
       },
       scoring: {
         strategy: 'NORMALIZED',
         threshold: 0.5,
         lowConfidenceCount: 0,
       },
     };
   }

   // Existing MusicBrainz logic continues below...
   ```

4. Keep all existing MusicBrainz logic unchanged (it's the else branch implicitly).

NOTE: The resolver calls getQueuedDiscogsService() which internally uses the queue infrastructure. This satisfies ALB-02 requirement for rate-limited queue access.
</action>
<verify>
TypeScript compiles: `pnpm type-check`
Codegen succeeds: `pnpm codegen`
</verify>
<done>
Resolver routes to QueuedDiscogsService when source is DISCOGS, uses queue infrastructure, returns same GraphQL shape as MusicBrainz.
</done>
</task>

<task type="auto">
  <name>Task 3: Regenerate GraphQL types</name>
  <files>
    src/generated/graphql.ts
  </files>
  <action>
1. Run codegen to regenerate types with new CorrectionSource enum:
   ```bash
   pnpm codegen
   ```

2. Verify generated types include:
   - CorrectionSource enum type
   - source field on CorrectionSearchInput type
   - Updated useSearchCorrectionCandidatesQuery hook accepts source in input

3. The existing correctionSearch.graphql query should work without modification since source has a default value. However, to explicitly pass source from frontend, the query file can optionally be updated to include source in the input. This is handled in Plan 03.
   </action>
   <verify>
   `pnpm codegen` completes successfully
   `grep -q "CorrectionSource" src/generated/graphql.ts` returns 0
   </verify>
   <done>
   GraphQL types regenerated with CorrectionSource enum available for frontend use.
   </done>
   </task>

</tasks>

<verification>
1. `pnpm codegen` succeeds without errors
2. `pnpm type-check` passes
3. CorrectionSource enum exists in generated types
4. Resolver imports getQueuedDiscogsService
5. Resolver has conditional branch for source === 'DISCOGS'
6. Resolver calls queuedDiscogsService.searchAlbums (not direct service)
</verification>

<success_criteria>

- GraphQL schema accepts source parameter on correctionSearch
- Resolver routes to QueuedDiscogsService for DISCOGS source (uses queue infrastructure)
- Discogs results wrapped in same GroupedSearchResult shape
- All generated types compile
  </success_criteria>

<output>
After completion, create `.planning/phases/22-discogs-album-search/22-02-SUMMARY.md`
</output>
