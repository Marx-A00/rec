---
phase: 22-discogs-album-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/queue/jobs.ts
  - src/lib/queue/processors/discogs-processor.ts
  - src/lib/discogs/mappers.ts
  - src/lib/discogs/queued-service.ts
  - src/lib/correction/types.ts
autonomous: true

must_haves:
  truths:
    - "DISCOGS_SEARCH_ALBUM job type exists and is processed by queue worker"
    - "Search results include full master data (not just search stubs)"
    - "Mapper converts Discogs fields to CorrectionSearchResult format"
    - "QueuedDiscogsService provides same interface pattern as QueuedMusicBrainzService"
  artifacts:
    - path: "src/lib/discogs/mappers.ts"
      provides: "Shared mapper function for master-to-correction-result"
      exports: ["mapMasterToCorrectionSearchResult"]
    - path: "src/lib/discogs/queued-service.ts"
      provides: "Queue-integrated Discogs service"
      exports: ["QueuedDiscogsService", "getQueuedDiscogsService"]
    - path: "src/lib/queue/jobs.ts"
      provides: "DISCOGS_SEARCH_ALBUM job type and data interface"
      contains: "DISCOGS_SEARCH_ALBUM"
    - path: "src/lib/queue/processors/discogs-processor.ts"
      provides: "Album search handler function"
      contains: "handleDiscogsSearchAlbum"
  key_links:
    - from: "src/lib/queue/processors/discogs-processor.ts"
      to: "src/lib/discogs/mappers.ts"
      via: "mapMasterToCorrectionSearchResult import"
      pattern: "mapMasterToCorrectionSearchResult"
    - from: "src/lib/discogs/queued-service.ts"
      to: "src/lib/queue/jobs.ts"
      via: "DISCOGS_SEARCH_ALBUM job type"
      pattern: "DISCOGS_SEARCH_ALBUM"
    - from: "src/lib/discogs/queued-service.ts"
      to: "src/lib/correction/types.ts"
      via: "CorrectionSearchResult return type"
      pattern: "CorrectionSearchResult"
---

<objective>
Add Discogs album search infrastructure to the queue system.

Purpose: Enable admin correction modal to search Discogs for albums via rate-limited queue.
Output: Working queue job type, processor handler, shared mapper, and QueuedDiscogsService for GraphQL resolver.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-discogs-album-search/22-CONTEXT.md
@.planning/phases/22-discogs-album-search/22-RESEARCH.md

<!-- Existing patterns to follow -->
@src/lib/queue/jobs.ts
@src/lib/queue/processors/discogs-processor.ts
@src/lib/discogs/mappers.ts
@src/lib/correction/types.ts
@src/types/discogs/master.ts
@src/lib/musicbrainz/queue-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DISCOGS_SEARCH_ALBUM job type and handler</name>
  <files>
    src/lib/queue/jobs.ts
    src/lib/queue/processors/discogs-processor.ts
  </files>
  <action>
1. In `jobs.ts`, add to JOB_TYPES constant:
   ```typescript
   DISCOGS_SEARCH_ALBUM: 'discogs:search-album',
   ```

2. In `jobs.ts`, add new interface after DiscogsGetArtistJobData:
   ```typescript
   export interface DiscogsSearchAlbumJobData {
     albumId: string;           // Local database album ID (for logging)
     albumTitle?: string;       // Album title to search
     artistName?: string;       // Artist name filter (optional)
     limit?: number;            // Results per page (default 10)
     requestId?: string;        // Request tracking
     parentJobId?: string;      // Job chain tracking
   }
   ```

3. Add DiscogsSearchAlbumJobData to MusicBrainzJobData union type (or create DiscogsJobData union if separate).

4. In `discogs-processor.ts`, add new handler function `handleDiscogsSearchAlbum`:
   - Initialize disconnect client (same pattern as handleDiscogsSearchArtist)
   - Build search options: `{ type: 'master', per_page: limit, release_title: albumTitle, artist: artistName }`
   - Execute `discogsClient.search(searchOptions)`
   - For each result, fetch full master via `discogsClient.getMaster(result.id)`
   - Import and call `mapMasterToCorrectionSearchResult` from `@/lib/discogs/mappers`
   - Return { albumId, action: 'search_complete', resultsCount, results }

NOTE: The handler does NOT implement mapping logic. It calls the shared mapper from mappers.ts (Task 2).
  </action>
  <verify>
TypeScript compiles without errors: `pnpm type-check`
  </verify>
  <done>
DISCOGS_SEARCH_ALBUM job type defined with data interface, handler function processes search and calls shared mapper.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add shared mapper and extend CorrectionSearchResult</name>
  <files>
    src/lib/discogs/mappers.ts
    src/lib/correction/types.ts
  </files>
  <action>
1. In `src/lib/correction/types.ts`, update the `source` field in CorrectionSearchResult to be a union type:
   ```typescript
   source: 'musicbrainz' | 'discogs';
   ```

2. In `src/lib/discogs/mappers.ts`, add new export function `mapMasterToCorrectionSearchResult`:
   ```typescript
   import type { CorrectionSearchResult, CorrectionArtistCredit } from '@/lib/correction/types';
   import type { DiscogsMaster } from '@/types/discogs/master';

   export function mapMasterToCorrectionSearchResult(master: DiscogsMaster): CorrectionSearchResult {
     const artistCredits: CorrectionArtistCredit[] = master.artists.map(a => ({
       mbid: a.id.toString(),
       name: a.name,
     }));

     const primaryArtistName = master.artists.map(a => a.name).join(', ');

     // Merge genres + styles per CONTEXT.md
     const genres = [
       ...(master.genres || []),
       ...(master.styles || []),
     ];

     // Get cover art (first image)
     const coverImage = master.images?.[0];

     return {
       releaseGroupMbid: master.id.toString(),
       title: master.title,
       disambiguation: undefined,
       artistCredits,
       primaryArtistName: primaryArtistName || 'Unknown Artist',
       firstReleaseDate: master.year?.toString(),
       primaryType: 'Album',
       secondaryTypes: [],
       mbScore: 100, // Discogs has no relevance score
       coverArtUrl: coverImage?.uri || null,
       source: 'discogs',
     };
   }
   ```

3. This single mapper is used by BOTH the queue handler (Task 1) and QueuedDiscogsService (Task 3). No duplicate logic.
  </action>
  <verify>
TypeScript compiles without errors: `pnpm type-check`
  </verify>
  <done>
CorrectionSearchResult.source accepts 'discogs' value, shared mapper function exported from mappers.ts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create QueuedDiscogsService</name>
  <files>
    src/lib/discogs/queued-service.ts
  </files>
  <action>
1. Create new file `src/lib/discogs/queued-service.ts`

2. Follow the QueuedMusicBrainzService pattern from `src/lib/musicbrainz/queue-service.ts`:
   ```typescript
   import { QueueEvents } from 'bullmq';
   import { getMusicBrainzQueue, JOB_TYPES, PRIORITY_TIERS } from '@/lib/queue';
   import { createRedisConnection } from '@/lib/queue/redis';
   import type { CorrectionSearchResult } from '@/lib/correction/types';

   export interface DiscogsAlbumSearchOptions {
     albumId: string;
     albumTitle?: string;
     artistName?: string;
     limit?: number;
   }

   export interface DiscogsAlbumSearchResponse {
     results: CorrectionSearchResult[];
     hasMore: boolean;
     query: {
       albumTitle?: string;
       artistName?: string;
     };
   }

   export class QueuedDiscogsService {
     private queue = getMusicBrainzQueue();
     private queueEvents: QueueEvents | null = null;
     private pendingJobs = new Map<
       string,
       { resolve: (value: unknown) => void; reject: (reason?: unknown) => void }
     >();

     private ensureInitialized() {
       if (!this.queueEvents) {
         this.queueEvents = new QueueEvents('musicbrainz', {
           connection: createRedisConnection(),
         });
         this.setupEventListeners();
       }
     }

     private setupEventListeners(): void {
       if (!this.queueEvents) return;
       
       this.queueEvents.on('completed', ({ jobId, returnvalue }) => {
         const result = typeof returnvalue === 'string' 
           ? JSON.parse(returnvalue) 
           : returnvalue;
         const pending = this.pendingJobs.get(jobId);
         if (pending) {
           pending.resolve(result);
           this.pendingJobs.delete(jobId);
         }
       });

       this.queueEvents.on('failed', ({ jobId, failedReason }) => {
         const pending = this.pendingJobs.get(jobId);
         if (pending) {
           pending.reject(new Error(failedReason));
           this.pendingJobs.delete(jobId);
         }
       });
     }

     async searchAlbums(options: DiscogsAlbumSearchOptions): Promise<DiscogsAlbumSearchResponse> {
       this.ensureInitialized();
       const limit = options.limit ?? 10;

       const job = await this.queue.add(
         JOB_TYPES.DISCOGS_SEARCH_ALBUM,
         {
           albumId: options.albumId,
           albumTitle: options.albumTitle,
           artistName: options.artistName,
           limit,
         },
         {
           priority: PRIORITY_TIERS.USER_INTERACTIVE,
         }
       );

       // Wait for job completion
       const result = await new Promise<{ results: CorrectionSearchResult[] }>((resolve, reject) => {
         this.pendingJobs.set(job.id!, { resolve, reject });
       });

       return {
         results: result.results,
         hasMore: result.results.length >= limit,
         query: {
           albumTitle: options.albumTitle,
           artistName: options.artistName,
         },
       };
     }
   }

   // Singleton (HMR-safe)
   const globalForDiscogs = globalThis as unknown as {
     queuedDiscogsService: QueuedDiscogsService | undefined;
   };

   export function getQueuedDiscogsService(): QueuedDiscogsService {
     if (!globalForDiscogs.queuedDiscogsService) {
       globalForDiscogs.queuedDiscogsService = new QueuedDiscogsService();
     }
     return globalForDiscogs.queuedDiscogsService;
   }
   ```

3. The service adds jobs to the queue with DISCOGS_SEARCH_ALBUM type, waits for completion via QueueEvents, and returns the results. The actual search logic + mapping happens in the queue handler (discogs-processor.ts).
  </action>
  <verify>
TypeScript compiles: `pnpm type-check`
File exists: `ls src/lib/discogs/queued-service.ts`
  </verify>
  <done>
QueuedDiscogsService wraps queue job submission, matches QueuedMusicBrainzService pattern. GraphQL resolver will call this service.
  </done>
</task>

</tasks>

<verification>
1. `pnpm type-check` passes with no errors
2. `pnpm lint` passes (or only unrelated warnings)
3. JOB_TYPES.DISCOGS_SEARCH_ALBUM is defined
4. handleDiscogsSearchAlbum function exists in discogs-processor.ts
5. mapMasterToCorrectionSearchResult exported from mappers.ts
6. QueuedDiscogsService exports from queued-service.ts
7. CorrectionSearchResult.source accepts 'discogs'
</verification>

<success_criteria>
- DISCOGS_SEARCH_ALBUM job type registered in jobs.ts
- Queue handler fetches masters and calls shared mapper
- QueuedDiscogsService wraps queue job for resolver use
- Shared mapper in mappers.ts (no duplicate logic)
- All types compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/22-discogs-album-search/22-01-SUMMARY.md`
</output>
