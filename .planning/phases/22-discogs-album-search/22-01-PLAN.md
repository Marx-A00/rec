---
phase: 22-discogs-album-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/queue/jobs.ts
  - src/lib/queue/processors/discogs-processor.ts
  - src/lib/discogs/album-search-service.ts
  - src/lib/correction/types.ts
autonomous: true

must_haves:
  truths:
    - "DISCOGS_SEARCH_ALBUM job type exists and is processed by queue worker"
    - "Search results include full master data (not just search stubs)"
    - "Mapper converts Discogs fields to CorrectionSearchResult format"
  artifacts:
    - path: "src/lib/discogs/album-search-service.ts"
      provides: "Discogs album search service"
      exports: ["DiscogsAlbumSearchService", "getDiscogsAlbumSearchService"]
    - path: "src/lib/queue/jobs.ts"
      provides: "DISCOGS_SEARCH_ALBUM job type and data interface"
      contains: "DISCOGS_SEARCH_ALBUM"
    - path: "src/lib/queue/processors/discogs-processor.ts"
      provides: "Album search handler function"
      contains: "handleDiscogsSearchAlbum"
  key_links:
    - from: "src/lib/queue/processors/discogs-processor.ts"
      to: "disconnect library"
      via: "database().search() and getMaster()"
      pattern: "discogsClient\\.(search|getMaster)"
    - from: "src/lib/discogs/album-search-service.ts"
      to: "src/lib/correction/types.ts"
      via: "CorrectionSearchResult return type"
      pattern: "CorrectionSearchResult"
---

<objective>
Add Discogs album search infrastructure to the queue system.

Purpose: Enable admin correction modal to search Discogs for albums via rate-limited queue.
Output: Working queue job type, processor handler, and search service for Discogs album search.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-discogs-album-search/22-CONTEXT.md
@.planning/phases/22-discogs-album-search/22-RESEARCH.md

<!-- Existing patterns to follow -->
@src/lib/queue/jobs.ts
@src/lib/queue/processors/discogs-processor.ts
@src/lib/discogs/mappers.ts
@src/lib/correction/types.ts
@src/types/discogs/master.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DISCOGS_SEARCH_ALBUM job type and handler</name>
  <files>
    src/lib/queue/jobs.ts
    src/lib/queue/processors/discogs-processor.ts
  </files>
  <action>
1. In `jobs.ts`, add to JOB_TYPES constant:
   ```typescript
   DISCOGS_SEARCH_ALBUM: 'discogs:search-album',
   ```

2. In `jobs.ts`, add new interface after DiscogsGetArtistJobData:
   ```typescript
   export interface DiscogsSearchAlbumJobData {
     albumId: string;           // Local database album ID (for logging)
     albumTitle?: string;       // Album title to search
     artistName?: string;       // Artist name filter (optional)
     limit?: number;            // Results per page (default 10)
     requestId?: string;        // Request tracking
     parentJobId?: string;      // Job chain tracking
   }
   ```

3. Add DiscogsSearchAlbumJobData to MusicBrainzJobData union type.

4. In `discogs-processor.ts`, add new handler function `handleDiscogsSearchAlbum`:
   - Initialize disconnect client (same pattern as handleDiscogsSearchArtist)
   - Build search options: `{ type: 'master', per_page: limit, release_title: albumTitle, artist: artistName }`
   - Execute `discogsClient.search(searchOptions)`
   - For each result, fetch full master via `discogsClient.getMaster(result.id)`
   - Map each master to CorrectionSearchResult format (call mapMasterToCorrectionResult helper)
   - Return { albumId, action: 'search_complete', resultsCount, results }

5. Add helper function `mapMasterToCorrectionResult(master: DiscogsMaster): CorrectionSearchResult`:
   - Extract artistCredits from master.artists
   - Merge genres + styles: `[...(master.genres || []), ...(master.styles || [])]`
   - Year-only date: `master.year ? master.year.toString() : ''`
   - Cover art: `master.images?.[0]?.uri || null`
   - Set `source: 'discogs'` (requires extending CorrectionSearchResult type)
   - Set `mbScore: 100` (Discogs has no relevance score)
   - Use `master.id.toString()` for releaseGroupMbid field
  </action>
  <verify>
TypeScript compiles without errors: `pnpm type-check`
  </verify>
  <done>
DISCOGS_SEARCH_ALBUM job type defined with data interface, handler function processes search and returns mapped CorrectionSearchResult array.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend CorrectionSearchResult for Discogs source</name>
  <files>
    src/lib/correction/types.ts
  </files>
  <action>
1. Update the `source` field in CorrectionSearchResult to be a union type:
   ```typescript
   source: 'musicbrainz' | 'discogs';
   ```

2. Update JSDoc comment to reflect both sources are now supported.

3. No other changes needed â€” the existing interface fields work for both sources:
   - releaseGroupMbid: Will hold Discogs master ID as string
   - title, artistCredits, primaryArtistName: Direct mapping
   - firstReleaseDate: Year-only string for Discogs
   - primaryType: Default to 'Album' for Discogs masters
   - secondaryTypes: Empty array for Discogs (not applicable)
   - mbScore: Always 100 for Discogs (no relevance scoring)
   - coverArtUrl: Discogs image URI
  </action>
  <verify>
TypeScript compiles without errors: `pnpm type-check`
  </verify>
  <done>
CorrectionSearchResult.source accepts 'discogs' value, enabling uniform result handling across sources.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create DiscogsAlbumSearchService</name>
  <files>
    src/lib/discogs/album-search-service.ts
  </files>
  <action>
1. Create new file `src/lib/discogs/album-search-service.ts`

2. Implement service class following CorrectionSearchService pattern:
   ```typescript
   import type { CorrectionSearchResult, CorrectionArtistCredit } from '@/lib/correction/types';
   import type { DiscogsMaster } from '@/types/discogs/master';

   export interface DiscogsAlbumSearchOptions {
     albumTitle?: string;
     artistName?: string;
     limit?: number;
   }

   export interface DiscogsAlbumSearchResponse {
     results: CorrectionSearchResult[];
     hasMore: boolean;
     query: {
       albumTitle?: string;
       artistName?: string;
     };
   }

   export class DiscogsAlbumSearchService {
     private discogsClient: ReturnType<Disconnect.Client['database']> | null = null;

     private async getClient() {
       if (!this.discogsClient) {
         const Discogs = await import('disconnect');
         this.discogsClient = new Discogs.default.Client({
           userAgent: 'RecProject/1.0 +https://rec-music.org',
           consumerKey: process.env.CONSUMER_KEY!,
           consumerSecret: process.env.CONSUMER_SECRET!,
         }).database();
       }
       return this.discogsClient;
     }

     async search(options: DiscogsAlbumSearchOptions): Promise<DiscogsAlbumSearchResponse> {
       const client = await this.getClient();
       const limit = options.limit ?? 10;

       const searchOptions: Record<string, unknown> = {
         type: 'master',
         per_page: limit,
       };

       if (options.albumTitle) {
         searchOptions.release_title = options.albumTitle;
       }
       if (options.artistName) {
         searchOptions.artist = options.artistName;
       }

       const searchResults = await client.search(searchOptions);
       
       // Two-step mapping: search results are minimal, need full master data
       const results = await Promise.all(
         (searchResults.results || []).slice(0, limit).map(async (result) => {
           const master = await client.getMaster(result.id);
           return this.mapMasterToResult(master);
         })
       );

       return {
         results,
         hasMore: (searchResults.results?.length || 0) > limit,
         query: {
           albumTitle: options.albumTitle,
           artistName: options.artistName,
         },
       };
     }

     private mapMasterToResult(master: DiscogsMaster): CorrectionSearchResult {
       const artistCredits: CorrectionArtistCredit[] = master.artists.map(a => ({
         mbid: a.id.toString(),
         name: a.name,
       }));

       const primaryArtistName = master.artists.map(a => a.name).join(', ');

       // Merge genres + styles per CONTEXT.md
       const genres = [
         ...(master.genres || []),
         ...(master.styles || []),
       ];

       // Get cover art (first image)
       const coverImage = master.images?.[0];

       return {
         releaseGroupMbid: master.id.toString(),
         title: master.title,
         disambiguation: undefined,
         artistCredits,
         primaryArtistName: primaryArtistName || 'Unknown Artist',
         firstReleaseDate: master.year?.toString(),
         primaryType: 'Album',
         secondaryTypes: [],
         mbScore: 100,
         coverArtUrl: coverImage?.uri || null,
         source: 'discogs',
       };
     }
   }

   // Singleton (HMR-safe)
   const globalForDiscogs = globalThis as unknown as {
     discogsAlbumSearchService: DiscogsAlbumSearchService | undefined;
   };

   export function getDiscogsAlbumSearchService(): DiscogsAlbumSearchService {
     if (!globalForDiscogs.discogsAlbumSearchService) {
       globalForDiscogs.discogsAlbumSearchService = new DiscogsAlbumSearchService();
     }
     return globalForDiscogs.discogsAlbumSearchService;
   }
   ```

3. Note: The handler in discogs-processor.ts will call this service for the actual search logic. Alternatively, the GraphQL resolver can call this service directly (thin resolver pattern).
  </action>
  <verify>
TypeScript compiles: `pnpm type-check`
File exists: `ls src/lib/discogs/album-search-service.ts`
  </verify>
  <done>
DiscogsAlbumSearchService provides searchable interface matching CorrectionSearchService pattern, with proper master-to-result mapping.
  </done>
</task>

</tasks>

<verification>
1. `pnpm type-check` passes with no errors
2. `pnpm lint` passes (or only unrelated warnings)
3. JOB_TYPES.DISCOGS_SEARCH_ALBUM is defined
4. handleDiscogsSearchAlbum function exists in discogs-processor.ts
5. DiscogsAlbumSearchService exports from album-search-service.ts
6. CorrectionSearchResult.source accepts 'discogs'
</verification>

<success_criteria>
- DISCOGS_SEARCH_ALBUM job type registered in jobs.ts
- Processor handler fetches masters and maps to CorrectionSearchResult
- Service class provides clean interface for GraphQL resolver
- All types compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/22-discogs-album-search/22-01-SUMMARY.md`
</output>
