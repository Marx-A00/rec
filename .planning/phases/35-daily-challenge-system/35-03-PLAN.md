---
phase: 35-daily-challenge-system
plan: 03
type: execute
wave: 3
depends_on: [35-01, 35-02]
files_modified:
  - src/graphql/schema.graphql
  - src/graphql/queries/dailyChallenge.graphql
  - src/lib/graphql/resolvers/queries.ts
  - src/lib/graphql/resolvers/mutations.ts
  - src/generated/graphql.ts
  - src/generated/resolvers-types.ts
autonomous: true

must_haves:
  truths:
    - "dailyChallenge query returns challenge info WITHOUT the answer album"
    - "Admin can add albums to curated list"
    - "Admin can view upcoming challenge schedule"
  artifacts:
    - path: "src/graphql/schema.graphql"
      provides: "DailyChallengeInfo type and queries"
      contains: "dailyChallenge"
    - path: "src/graphql/queries/dailyChallenge.graphql"
      provides: "Client-side GraphQL operations"
    - path: "src/lib/graphql/resolvers/queries.ts"
      provides: "dailyChallenge resolver"
      contains: "dailyChallenge"
  key_links:
    - from: "resolvers/queries.ts"
      to: "challenge-service.ts"
      via: "getOrCreateDailyChallenge import"
      pattern: "import.*from.*daily-challenge"
---

<objective>
Add GraphQL API for daily challenge system - public query for today's challenge and admin operations for managing the curated list.

Purpose: Expose the daily challenge to clients via GraphQL (without revealing the answer), and provide admin operations for managing the curated album list.

Output: GraphQL schema additions, resolvers, and generated client hooks.
</objective>

<execution_context>
@/Users/marcosandrade/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcosandrade/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/35-daily-challenge-system/35-CONTEXT.md
@.planning/phases/35-daily-challenge-system/35-RESEARCH.md
@.planning/phases/35-daily-challenge-system/35-01-SUMMARY.md
@src/graphql/schema.graphql
@src/lib/graphql/resolvers/queries.ts
@src/lib/graphql/resolvers/mutations.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GraphQL schema types and operations</name>
  <files>src/graphql/schema.graphql</files>
  <action>
Add the following to src/graphql/schema.graphql:

1. Add DailyChallengeInfo type (near other game-related types):
```graphql
"""
Daily challenge info - does NOT include the answer album
"""
type DailyChallengeInfo {
  id: UUID!
  date: DateTime!
  maxAttempts: Int!
  totalPlays: Int!
  totalWins: Int!
  avgAttempts: Float
  
  """
  User's session for this challenge (null if not started or not authenticated)
  """
  mySession: UncoverSessionInfo
}

"""
User's session info for a daily challenge
"""
type UncoverSessionInfo {
  id: UUID!
  status: UncoverSessionStatus!
  attemptCount: Int!
  won: Boolean!
  startedAt: DateTime!
  completedAt: DateTime
}

"""
Curated challenge entry for admin management
"""
type CuratedChallengeEntry {
  id: UUID!
  sequence: Int!
  pinnedDate: DateTime
  album: Album!
  createdAt: DateTime!
}

"""
Upcoming challenge preview for admin
"""
type UpcomingChallenge {
  date: DateTime!
  daysSinceEpoch: Int!
  sequence: Int!
  isPinned: Boolean!
  album: Album
}
```

2. Add enum if not exists (check first - may already exist from Phase 33):
```graphql
enum UncoverSessionStatus {
  IN_PROGRESS
  WON
  LOST
}
```

3. Add to Query type:
```graphql
  """
  Get the daily challenge for a date (defaults to today).
  Does NOT expose the answer album - that would spoil the game!
  """
  dailyChallenge(date: DateTime): DailyChallengeInfo!
  
  """
  Admin: Get curated challenge list (ordered)
  """
  curatedChallenges(limit: Int, offset: Int): [CuratedChallengeEntry!]!
  
  """
  Admin: Get count of curated challenges
  """
  curatedChallengeCount: Int!
  
  """
  Admin: Preview upcoming challenges for the next N days
  """
  upcomingChallenges(days: Int!): [UpcomingChallenge!]!
```

4. Add to Mutation type:
```graphql
  """
  Admin: Add an album to the curated challenge list
  """
  addCuratedChallenge(albumId: UUID!, pinnedDate: DateTime): CuratedChallengeEntry!
  
  """
  Admin: Remove an album from the curated challenge list
  """
  removeCuratedChallenge(id: UUID!): Boolean!
  
  """
  Admin: Pin a curated challenge to a specific date
  """
  pinCuratedChallenge(id: UUID!, date: DateTime!): CuratedChallengeEntry!
  
  """
  Admin: Unpin a curated challenge (remove date override)
  """
  unpinCuratedChallenge(id: UUID!): CuratedChallengeEntry!
```
  </action>
  <verify>Run `pnpm codegen` to verify schema is valid and generates types</verify>
  <done>GraphQL schema updated with DailyChallengeInfo type, queries, and mutations</done>
</task>

<task type="auto">
  <name>Task 2: Implement query resolvers</name>
  <files>src/lib/graphql/resolvers/queries.ts</files>
  <action>
Add the following resolvers to src/lib/graphql/resolvers/queries.ts:

1. Add imports at top:
```typescript
import { 
  getOrCreateDailyChallenge, 
  getDailyChallengeInfo 
} from '@/lib/daily-challenge/challenge-service';
import { getSelectionInfo } from '@/lib/daily-challenge/selection-service';
import { toUTCMidnight, getDaysSinceEpoch } from '@/lib/daily-challenge/date-utils';
```

2. Add dailyChallenge resolver:
```typescript
export const dailyChallenge = async (
  _parent: unknown,
  args: { date?: Date | string },
  context: GraphQLContext
) => {
  const targetDate = args.date 
    ? toUTCMidnight(new Date(args.date))
    : toUTCMidnight(new Date());
  
  // Get or create the challenge (this is safe - doesn't expose answer)
  const challenge = await getOrCreateDailyChallenge(targetDate);
  
  // Fetch user's session if authenticated
  let mySession = null;
  if (context.session?.user?.id) {
    const session = await prisma.uncoverSession.findUnique({
      where: {
        challengeId_userId: {
          challengeId: challenge.id,
          userId: context.session.user.id,
        },
      },
    });
    
    if (session) {
      mySession = {
        id: session.id,
        status: session.status,
        attemptCount: session.attemptCount,
        won: session.won,
        startedAt: session.startedAt,
        completedAt: session.completedAt,
      };
    }
  }
  
  // Return challenge info WITHOUT the album (that's the answer!)
  return {
    id: challenge.id,
    date: challenge.date,
    maxAttempts: challenge.maxAttempts,
    totalPlays: challenge.totalPlays,
    totalWins: challenge.totalWins,
    avgAttempts: challenge.avgAttempts,
    mySession,
  };
};
```

3. Add curatedChallenges resolver (admin):
```typescript
export const curatedChallenges = async (
  _parent: unknown,
  args: { limit?: number; offset?: number },
  context: GraphQLContext
) => {
  // Admin check
  if (!context.session?.user?.role || !['ADMIN', 'OWNER'].includes(context.session.user.role)) {
    throw new Error('Admin access required');
  }
  
  const limit = args.limit ?? 50;
  const offset = args.offset ?? 0;
  
  return prisma.curatedChallenge.findMany({
    take: limit,
    skip: offset,
    orderBy: { sequence: 'asc' },
    include: {
      album: {
        include: {
          artists: {
            include: { artist: true },
          },
        },
      },
    },
  });
};
```

4. Add curatedChallengeCount resolver:
```typescript
export const curatedChallengeCount = async (
  _parent: unknown,
  _args: unknown,
  context: GraphQLContext
) => {
  // Admin check
  if (!context.session?.user?.role || !['ADMIN', 'OWNER'].includes(context.session.user.role)) {
    throw new Error('Admin access required');
  }
  
  return prisma.curatedChallenge.count();
};
```

5. Add upcomingChallenges resolver:
```typescript
export const upcomingChallenges = async (
  _parent: unknown,
  args: { days: number },
  context: GraphQLContext
) => {
  // Admin check
  if (!context.session?.user?.role || !['ADMIN', 'OWNER'].includes(context.session.user.role)) {
    throw new Error('Admin access required');
  }
  
  const results = [];
  const today = toUTCMidnight(new Date());
  
  for (let i = 0; i < args.days; i++) {
    const date = new Date(today);
    date.setUTCDate(date.getUTCDate() + i);
    
    const info = await getSelectionInfo(date);
    
    let album = null;
    if (info.albumId) {
      album = await prisma.album.findUnique({
        where: { id: info.albumId },
        include: {
          artists: {
            include: { artist: true },
          },
        },
      });
    }
    
    results.push({
      date: info.date,
      daysSinceEpoch: info.daysSinceEpoch,
      sequence: info.sequence,
      isPinned: info.isPinned,
      album,
    });
  }
  
  return results;
};
```

6. Make sure to export all new resolvers and add them to the resolvers object.
  </action>
  <verify>Run `pnpm type-check` to verify resolver types match schema</verify>
  <done>Query resolvers implemented for dailyChallenge and admin operations</done>
</task>

<task type="auto">
  <name>Task 3: Implement mutation resolvers</name>
  <files>src/lib/graphql/resolvers/mutations.ts</files>
  <action>
Add the following mutation resolvers to src/lib/graphql/resolvers/mutations.ts:

1. Add imports at top:
```typescript
import { toUTCMidnight } from '@/lib/daily-challenge/date-utils';
```

2. Add addCuratedChallenge mutation:
```typescript
export const addCuratedChallenge = async (
  _parent: unknown,
  args: { albumId: string; pinnedDate?: Date | string },
  context: GraphQLContext
) => {
  // Admin check
  if (!context.session?.user?.role || !['ADMIN', 'OWNER'].includes(context.session.user.role)) {
    throw new Error('Admin access required');
  }
  
  // Verify album exists and is eligible
  const album = await prisma.album.findUnique({
    where: { id: args.albumId },
    select: { id: true, gameStatus: true, cloudflareImageId: true },
  });
  
  if (!album) {
    throw new Error('Album not found');
  }
  
  if (album.gameStatus !== 'ELIGIBLE') {
    throw new Error('Album must be marked as ELIGIBLE for game pool before adding to curated list');
  }
  
  if (!album.cloudflareImageId) {
    throw new Error('Album must have cover art (cloudflareImageId) to be added to curated list');
  }
  
  // Check if album already in curated list
  const existing = await prisma.curatedChallenge.findFirst({
    where: { albumId: args.albumId },
  });
  
  if (existing) {
    throw new Error('Album is already in the curated challenge list');
  }
  
  // Get next sequence number
  const maxSeq = await prisma.curatedChallenge.aggregate({
    _max: { sequence: true },
  });
  const nextSequence = (maxSeq._max.sequence ?? -1) + 1;
  
  // Create curated challenge entry
  const pinnedDate = args.pinnedDate 
    ? toUTCMidnight(new Date(args.pinnedDate))
    : null;
  
  const entry = await prisma.curatedChallenge.create({
    data: {
      albumId: args.albumId,
      sequence: nextSequence,
      pinnedDate,
    },
    include: {
      album: {
        include: {
          artists: {
            include: { artist: true },
          },
        },
      },
    },
  });
  
  return entry;
};
```

3. Add removeCuratedChallenge mutation:
```typescript
export const removeCuratedChallenge = async (
  _parent: unknown,
  args: { id: string },
  context: GraphQLContext
) => {
  // Admin check
  if (!context.session?.user?.role || !['ADMIN', 'OWNER'].includes(context.session.user.role)) {
    throw new Error('Admin access required');
  }
  
  const entry = await prisma.curatedChallenge.findUnique({
    where: { id: args.id },
  });
  
  if (!entry) {
    throw new Error('Curated challenge entry not found');
  }
  
  // Delete the entry
  await prisma.curatedChallenge.delete({
    where: { id: args.id },
  });
  
  // Resequence remaining entries to maintain contiguous sequence
  const remaining = await prisma.curatedChallenge.findMany({
    orderBy: { sequence: 'asc' },
    select: { id: true },
  });
  
  // Update sequences to be contiguous (0, 1, 2, ...)
  for (let i = 0; i < remaining.length; i++) {
    await prisma.curatedChallenge.update({
      where: { id: remaining[i].id },
      data: { sequence: i },
    });
  }
  
  return true;
};
```

4. Add pinCuratedChallenge mutation:
```typescript
export const pinCuratedChallenge = async (
  _parent: unknown,
  args: { id: string; date: Date | string },
  context: GraphQLContext
) => {
  // Admin check
  if (!context.session?.user?.role || !['ADMIN', 'OWNER'].includes(context.session.user.role)) {
    throw new Error('Admin access required');
  }
  
  const pinnedDate = toUTCMidnight(new Date(args.date));
  
  // Check if another entry is pinned to this date
  const existingPin = await prisma.curatedChallenge.findFirst({
    where: { 
      pinnedDate,
      id: { not: args.id },
    },
  });
  
  if (existingPin) {
    throw new Error('Another album is already pinned to this date');
  }
  
  return prisma.curatedChallenge.update({
    where: { id: args.id },
    data: { pinnedDate },
    include: {
      album: {
        include: {
          artists: {
            include: { artist: true },
          },
        },
      },
    },
  });
};
```

5. Add unpinCuratedChallenge mutation:
```typescript
export const unpinCuratedChallenge = async (
  _parent: unknown,
  args: { id: string },
  context: GraphQLContext
) => {
  // Admin check
  if (!context.session?.user?.role || !['ADMIN', 'OWNER'].includes(context.session.user.role)) {
    throw new Error('Admin access required');
  }
  
  return prisma.curatedChallenge.update({
    where: { id: args.id },
    data: { pinnedDate: null },
    include: {
      album: {
        include: {
          artists: {
            include: { artist: true },
          },
        },
      },
    },
  });
};
```

6. Export all new mutations and add them to the mutations object.
  </action>
  <verify>Run `pnpm type-check` to verify mutation types match schema</verify>
  <done>Mutation resolvers implemented for curated list management</done>
</task>

<task type="auto">
  <name>Task 4: Create client-side GraphQL queries and run codegen</name>
  <files>src/graphql/queries/dailyChallenge.graphql</files>
  <action>
Create src/graphql/queries/dailyChallenge.graphql with client-side operations:

```graphql
# Daily Challenge Queries and Mutations

query DailyChallenge($date: DateTime) {
  dailyChallenge(date: $date) {
    id
    date
    maxAttempts
    totalPlays
    totalWins
    avgAttempts
    mySession {
      id
      status
      attemptCount
      won
      startedAt
      completedAt
    }
  }
}

# Admin queries
query CuratedChallenges($limit: Int, $offset: Int) {
  curatedChallenges(limit: $limit, offset: $offset) {
    id
    sequence
    pinnedDate
    createdAt
    album {
      id
      name
      cloudflareImageId
      releaseDate
      artists {
        artist {
          id
          name
        }
      }
    }
  }
}

query CuratedChallengeCount {
  curatedChallengeCount
}

query UpcomingChallenges($days: Int!) {
  upcomingChallenges(days: $days) {
    date
    daysSinceEpoch
    sequence
    isPinned
    album {
      id
      name
      cloudflareImageId
      releaseDate
      artists {
        artist {
          id
          name
        }
      }
    }
  }
}

# Admin mutations
mutation AddCuratedChallenge($albumId: UUID!, $pinnedDate: DateTime) {
  addCuratedChallenge(albumId: $albumId, pinnedDate: $pinnedDate) {
    id
    sequence
    pinnedDate
    album {
      id
      name
    }
  }
}

mutation RemoveCuratedChallenge($id: UUID!) {
  removeCuratedChallenge(id: $id)
}

mutation PinCuratedChallenge($id: UUID!, $date: DateTime!) {
  pinCuratedChallenge(id: $id, date: $date) {
    id
    sequence
    pinnedDate
    album {
      id
      name
    }
  }
}

mutation UnpinCuratedChallenge($id: UUID!) {
  unpinCuratedChallenge(id: $id) {
    id
    sequence
    pinnedDate
    album {
      id
      name
    }
  }
}
```

Then run codegen to generate types and hooks:
```bash
pnpm codegen
```

This will generate:
- useDailyChallengeQuery hook
- useCuratedChallengesQuery hook
- useCuratedChallengeCountQuery hook
- useUpcomingChallengesQuery hook
- useAddCuratedChallengeMutation hook
- useRemoveCuratedChallengeMutation hook
- usePinCuratedChallengeMutation hook
- useUnpinCuratedChallengeMutation hook
  </action>
  <verify>
1. Run `pnpm codegen` succeeds
2. Run `pnpm type-check` passes
3. Generated hooks exist in src/generated/graphql.ts
  </verify>
  <done>Client-side GraphQL operations created and React Query hooks generated</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Schema validation: `pnpm codegen` completes without errors
2. Type checking: `pnpm type-check` passes
3. GraphQL operations:
   - dailyChallenge query returns challenge info WITHOUT album answer
   - curatedChallenges query returns ordered list (admin only)
   - upcomingChallenges query shows preview of next N days (admin only)
   - Admin mutations manage curated list entries
4. Generated hooks available in src/generated/graphql.ts
</verification>

<success_criteria>
- dailyChallenge query works for any date (defaults to today)
- Query returns session info if user is authenticated
- Album answer is NOT exposed in any public query
- Admin can view and manage curated challenge list
- Codegen produces working React Query hooks
</success_criteria>

<output>
After completion, create `.planning/phases/35-daily-challenge-system/35-03-SUMMARY.md`
</output>
