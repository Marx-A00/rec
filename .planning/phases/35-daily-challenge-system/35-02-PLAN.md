---
phase: 35-daily-challenge-system
plan: 02
type: execute
wave: 2
depends_on: [35-01]
files_modified:
  - src/lib/daily-challenge/date-utils.ts
  - src/lib/daily-challenge/selection-service.ts
  - src/lib/daily-challenge/challenge-service.ts
autonomous: true

must_haves:
  truths:
    - "Same date always returns same album for all users"
    - "UTC midnight is the reset boundary"
    - "Challenge row created on-demand if it does not exist"
    - "Race conditions handled via unique constraint"
  artifacts:
    - path: "src/lib/daily-challenge/date-utils.ts"
      provides: "UTC date normalization utilities"
      exports: ["toUTCMidnight", "getDaysSinceEpoch"]
    - path: "src/lib/daily-challenge/selection-service.ts"
      provides: "Deterministic album selection from curated list"
      exports: ["selectAlbumForDate"]
    - path: "src/lib/daily-challenge/challenge-service.ts"
      provides: "On-demand challenge creation with race handling"
      exports: ["getOrCreateDailyChallenge", "getTodayChallenge"]
  key_links:
    - from: "challenge-service.ts"
      to: "selection-service.ts"
      via: "selectAlbumForDate import"
      pattern: "import.*selectAlbumForDate.*from.*selection-service"
    - from: "selection-service.ts"
      to: "prisma.curatedChallenge"
      via: "database query"
      pattern: "prisma\\.curatedChallenge\\.(findFirst|findUnique|count)"
    - from: "challenge-service.ts"
      to: "prisma.uncoverChallenge"
      via: "create/findUnique"
      pattern: "prisma\\.uncoverChallenge\\.(create|findUnique)"
---

<objective>
Implement the daily challenge selection and creation service layer.

Purpose: Deterministic album selection from the curated list based on date, with on-demand challenge creation that handles race conditions. This is the core logic that ensures all players see the same album on any given day.

Output: Three service modules - date utilities, selection service, and challenge service.
</objective>

<execution_context>
@/Users/marcosandrade/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcosandrade/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/35-daily-challenge-system/35-CONTEXT.md
@.planning/phases/35-daily-challenge-system/35-RESEARCH.md
@.planning/phases/35-daily-challenge-system/35-01-SUMMARY.md
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create date utilities module</name>
  <files>src/lib/daily-challenge/date-utils.ts</files>
  <action>
Create src/lib/daily-challenge/date-utils.ts with UTC date handling utilities:

```typescript
/**
 * Daily Challenge Date Utilities
 * 
 * All dates for daily challenges are normalized to UTC midnight.
 * This ensures all players worldwide see the same challenge on the same "day".
 */

/**
 * Game epoch start date - used as reference point for day calculations.
 * This is the first day challenges can be generated.
 */
export const GAME_EPOCH = new Date('2026-01-01T00:00:00Z');

/**
 * Convert any date to UTC midnight (00:00:00.000Z).
 * This normalizes dates for consistent challenge keys.
 * 
 * @param date - Any Date object
 * @returns New Date object set to UTC midnight
 */
export function toUTCMidnight(date: Date): Date {
  const utcDate = new Date(date);
  utcDate.setUTCHours(0, 0, 0, 0);
  return utcDate;
}

/**
 * Calculate the number of days since the game epoch.
 * Used for deterministic album selection via modulo arithmetic.
 * 
 * @param date - The date to calculate from (will be normalized to UTC midnight)
 * @returns Number of days since GAME_EPOCH (0 on epoch day, 1 on next day, etc.)
 */
export function getDaysSinceEpoch(date: Date): number {
  const normalizedDate = toUTCMidnight(date);
  const epochTime = GAME_EPOCH.getTime();
  const currentTime = normalizedDate.getTime();
  
  const daysDiff = Math.floor((currentTime - epochTime) / (1000 * 60 * 60 * 24));
  
  // Return 0 for dates before epoch (shouldn't happen in production)
  return Math.max(0, daysDiff);
}

/**
 * Get today's date as UTC midnight.
 * Convenience function for common use case.
 */
export function getToday(): Date {
  return toUTCMidnight(new Date());
}

/**
 * Format a date as YYYY-MM-DD string (UTC).
 * Useful for logging and debugging.
 */
export function formatDateUTC(date: Date): string {
  return date.toISOString().split('T')[0];
}
```

Key points:
- GAME_EPOCH is 2026-01-01 (game launch date)
- All functions work with UTC, never local time
- getDaysSinceEpoch returns 0 for epoch day, 1 for next day, etc.
- Handles edge case of dates before epoch (returns 0)
  </action>
  <verify>File exists and exports toUTCMidnight, getDaysSinceEpoch, getToday, formatDateUTC, GAME_EPOCH</verify>
  <done>Date utilities module created with UTC normalization functions</done>
</task>

<task type="auto">
  <name>Task 2: Create selection service</name>
  <files>src/lib/daily-challenge/selection-service.ts</files>
  <action>
Create src/lib/daily-challenge/selection-service.ts with deterministic album selection:

```typescript
/**
 * Daily Challenge Selection Service
 * 
 * Deterministically selects an album for a given date from the curated challenge list.
 * Uses modulo arithmetic on days-since-epoch for reproducible, debuggable selection.
 */

import { prisma } from '@/lib/db';
import { toUTCMidnight, getDaysSinceEpoch } from './date-utils';

export class NoCuratedAlbumsError extends Error {
  constructor() {
    super('No curated albums available. Admin must add albums to the curated challenge list.');
    this.name = 'NoCuratedAlbumsError';
  }
}

export class AlbumNotFoundError extends Error {
  constructor(sequence: number) {
    super(`No album found at sequence ${sequence}. Curated list may have gaps.`);
    this.name = 'AlbumNotFoundError';
  }
}

/**
 * Select the album ID for a given date.
 * 
 * Selection priority:
 * 1. Admin-pinned album for this specific date (override)
 * 2. Deterministic selection from ordered curated list using date modulo
 * 
 * @param date - The date to select an album for (will be normalized to UTC midnight)
 * @returns Album ID to use for this date's challenge
 * @throws NoCuratedAlbumsError if curated list is empty
 * @throws AlbumNotFoundError if sequence calculation finds no album
 */
export async function selectAlbumForDate(date: Date): Promise<string> {
  const normalizedDate = toUTCMidnight(date);
  
  // 1. Check for admin-pinned album on this date
  const pinned = await prisma.curatedChallenge.findFirst({
    where: { pinnedDate: normalizedDate },
    select: { albumId: true },
  });
  
  if (pinned) {
    return pinned.albumId;
  }
  
  // 2. Deterministic selection from ordered list
  const totalCurated = await prisma.curatedChallenge.count();
  
  if (totalCurated === 0) {
    throw new NoCuratedAlbumsError();
  }
  
  const daysSinceEpoch = getDaysSinceEpoch(normalizedDate);
  const sequence = daysSinceEpoch % totalCurated;
  
  const challenge = await prisma.curatedChallenge.findUnique({
    where: { sequence },
    select: { albumId: true },
  });
  
  if (!challenge) {
    throw new AlbumNotFoundError(sequence);
  }
  
  return challenge.albumId;
}

/**
 * Get information about which album will be selected for a date.
 * Useful for admin preview and debugging.
 * 
 * @param date - The date to check
 * @returns Object with selection details
 */
export async function getSelectionInfo(date: Date): Promise<{
  date: Date;
  daysSinceEpoch: number;
  totalCurated: number;
  sequence: number;
  isPinned: boolean;
  albumId: string | null;
}> {
  const normalizedDate = toUTCMidnight(date);
  const daysSinceEpoch = getDaysSinceEpoch(normalizedDate);
  const totalCurated = await prisma.curatedChallenge.count();
  
  // Check for pinned
  const pinned = await prisma.curatedChallenge.findFirst({
    where: { pinnedDate: normalizedDate },
    select: { albumId: true },
  });
  
  if (pinned) {
    return {
      date: normalizedDate,
      daysSinceEpoch,
      totalCurated,
      sequence: -1, // Not applicable for pinned
      isPinned: true,
      albumId: pinned.albumId,
    };
  }
  
  const sequence = totalCurated > 0 ? daysSinceEpoch % totalCurated : -1;
  const challenge = totalCurated > 0 
    ? await prisma.curatedChallenge.findUnique({
        where: { sequence },
        select: { albumId: true },
      })
    : null;
  
  return {
    date: normalizedDate,
    daysSinceEpoch,
    totalCurated,
    sequence,
    isPinned: false,
    albumId: challenge?.albumId ?? null,
  };
}
```

Key points:
- Checks for pinned date first (admin override)
- Uses modulo for deterministic cycling through curated list
- Custom error types for specific failure modes
- getSelectionInfo for admin debugging/preview
  </action>
  <verify>File exports selectAlbumForDate, getSelectionInfo, NoCuratedAlbumsError, AlbumNotFoundError</verify>
  <done>Selection service created with deterministic date-to-album mapping</done>
</task>

<task type="auto">
  <name>Task 3: Create challenge service</name>
  <files>src/lib/daily-challenge/challenge-service.ts</files>
  <action>
Create src/lib/daily-challenge/challenge-service.ts with on-demand challenge creation:

```typescript
/**
 * Daily Challenge Service
 * 
 * Manages UncoverChallenge records. Creates challenges on-demand
 * when first requested for a date, handling race conditions gracefully.
 */

import { prisma } from '@/lib/db';
import { UncoverChallenge, Prisma } from '@prisma/client';
import { toUTCMidnight, getToday, formatDateUTC } from './date-utils';
import { selectAlbumForDate, NoCuratedAlbumsError, AlbumNotFoundError } from './selection-service';

// Type for challenge with album included (but NOT revealing full album details)
export type DailyChallengeInfo = {
  id: string;
  date: Date;
  maxAttempts: number;
  totalPlays: number;
  totalWins: number;
  avgAttempts: number | null;
  // Note: albumId intentionally NOT exposed - that's the answer!
};

// Full challenge type for internal use only
export type DailyChallengeWithAlbum = UncoverChallenge & {
  album: {
    id: string;
    name: string;
    cloudflareImageId: string | null;
    artists: Array<{
      artist: {
        id: string;
        name: string;
      };
    }>;
  };
};

/**
 * Get or create the challenge for a specific date.
 * 
 * This is the main entry point for retrieving daily challenges.
 * If the challenge doesn't exist, it will be created on-demand
 * using deterministic album selection.
 * 
 * Race condition handling: Uses database unique constraint on date.
 * If two requests try to create simultaneously, one will fail with
 * P2002 error and fall back to reading the created record.
 * 
 * @param date - The date to get/create challenge for (defaults to today)
 * @returns The challenge record with album details (for internal use)
 * @throws NoCuratedAlbumsError if no curated albums exist
 */
export async function getOrCreateDailyChallenge(
  date: Date = new Date()
): Promise<DailyChallengeWithAlbum> {
  const normalizedDate = toUTCMidnight(date);
  
  // Try to find existing challenge
  const existing = await prisma.uncoverChallenge.findUnique({
    where: { date: normalizedDate },
    include: {
      album: {
        include: {
          artists: {
            include: { artist: true },
          },
        },
      },
    },
  });
  
  if (existing) {
    return existing as DailyChallengeWithAlbum;
  }
  
  // Select album deterministically
  const albumId = await selectAlbumForDate(normalizedDate);
  
  // Try to create new challenge
  try {
    const created = await prisma.uncoverChallenge.create({
      data: {
        date: normalizedDate,
        albumId,
        maxAttempts: 6,
      },
      include: {
        album: {
          include: {
            artists: {
              include: { artist: true },
            },
          },
        },
      },
    });
    
    console.log(`[DailyChallenge] Created challenge for ${formatDateUTC(normalizedDate)}`);
    return created as DailyChallengeWithAlbum;
    
  } catch (error) {
    // Handle race condition: another request created it first
    if (
      error instanceof Prisma.PrismaClientKnownRequestError &&
      error.code === 'P2002' // Unique constraint violation
    ) {
      console.log(`[DailyChallenge] Race condition on ${formatDateUTC(normalizedDate)}, fetching existing`);
      
      const raceResolved = await prisma.uncoverChallenge.findUnique({
        where: { date: normalizedDate },
        include: {
          album: {
            include: {
              artists: {
                include: { artist: true },
              },
            },
          },
        },
      });
      
      if (!raceResolved) {
        throw new Error(`Challenge creation race condition unresolved for ${formatDateUTC(normalizedDate)}`);
      }
      
      return raceResolved as DailyChallengeWithAlbum;
    }
    
    throw error;
  }
}

/**
 * Get today's challenge (convenience wrapper).
 */
export async function getTodayChallenge(): Promise<DailyChallengeWithAlbum> {
  return getOrCreateDailyChallenge(getToday());
}

/**
 * Get public challenge info (safe to expose to clients).
 * Does NOT include albumId or album details - that's the answer!
 */
export async function getDailyChallengeInfo(
  date: Date = new Date()
): Promise<DailyChallengeInfo> {
  const challenge = await getOrCreateDailyChallenge(date);
  
  return {
    id: challenge.id,
    date: challenge.date,
    maxAttempts: challenge.maxAttempts,
    totalPlays: challenge.totalPlays,
    totalWins: challenge.totalWins,
    avgAttempts: challenge.avgAttempts,
  };
}

/**
 * Check if a challenge exists for a date (without creating it).
 */
export async function challengeExistsForDate(date: Date): Promise<boolean> {
  const normalizedDate = toUTCMidnight(date);
  const count = await prisma.uncoverChallenge.count({
    where: { date: normalizedDate },
  });
  return count > 0;
}

// Re-export errors for convenience
export { NoCuratedAlbumsError, AlbumNotFoundError };
```

Key points:
- On-demand creation with race condition handling (P2002 catch)
- DailyChallengeInfo type does NOT expose albumId (the answer)
- DailyChallengeWithAlbum for internal use only
- Console logging for observability
- Re-exports errors from selection-service
  </action>
  <verify>
1. File exports getOrCreateDailyChallenge, getTodayChallenge, getDailyChallengeInfo, challengeExistsForDate
2. Run `pnpm type-check` to verify types are correct
  </verify>
  <done>Challenge service created with on-demand creation and race condition handling</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Type check passes: `pnpm type-check`
2. All three files exist in src/lib/daily-challenge/
3. Imports work correctly between modules
4. Service handles edge cases:
   - Empty curated list (throws NoCuratedAlbumsError)
   - Race condition on creation (catches P2002, retries read)
   - Pinned dates override deterministic selection
</verification>

<success_criteria>
- Date utilities normalize to UTC midnight correctly
- Selection service deterministically maps date to album
- Challenge service creates challenges on-demand
- Race conditions handled via unique constraint + P2002 catch
- Public API does not expose album answer
</success_criteria>

<output>
After completion, create `.planning/phases/35-daily-challenge-system/35-02-SUMMARY.md`
</output>
