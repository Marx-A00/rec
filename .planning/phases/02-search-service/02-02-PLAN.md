---
phase: 02-search-service
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/correction/scoring/index.ts
  - src/lib/correction/scoring/types.ts
  - src/lib/correction/scoring/normalized-scorer.ts
  - src/lib/correction/scoring/tiered-scorer.ts
  - src/lib/correction/scoring/weighted-scorer.ts
  - src/lib/correction/types.ts
  - src/lib/correction/index.ts
autonomous: true

must_haves:
  truths:
    - "Three scoring strategies exist: normalized (0-1), tiered (high/medium/low), weighted (0-100)"
    - "All strategies can be selected at runtime via ScoringStrategy type"
    - "Scorer accepts a CorrectionSearchResult and query params, returns scored result"
    - "Score breakdown shows component scores (title, artist, year)"
    - "Results can be flagged as low-confidence based on threshold"
  artifacts:
    - path: "src/lib/correction/scoring/index.ts"
      provides: "Scoring strategy selector and main exports"
      exports: ["SearchScoringService", "ScoringStrategy"]
    - path: "src/lib/correction/scoring/normalized-scorer.ts"
      provides: "0-1 normalized scoring using string-similarity"
    - path: "src/lib/correction/scoring/tiered-scorer.ts"
      provides: "high/medium/low tiered scoring using fuzzysort"
    - path: "src/lib/correction/scoring/weighted-scorer.ts"
      provides: "0-100 weighted multi-signal scoring"
  key_links:
    - from: "src/lib/correction/scoring/normalized-scorer.ts"
      to: "src/lib/utils/string-similarity.ts"
      via: "calculateStringSimilarity import"
      pattern: "calculateStringSimilarity"
    - from: "src/lib/correction/scoring/tiered-scorer.ts"
      to: "fuzzysort"
      via: "fuzzysort import"
      pattern: "import fuzzysort"
---

<objective>
Implement pluggable scoring strategies for correction search results.

Purpose: Admins need to see how well search results match their query. Three strategies allow dev testing to find the best approach: normalized (0-1), tiered confidence levels, and weighted multi-signal. All produce a normalizedScore for sorting plus raw scores for display.

Output: A scoring module with three interchangeable strategies and a service to apply them to search results.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-search-service/02-CONTEXT.md
@.planning/phases/02-search-service/02-RESEARCH.md

# Depends on 02-01 for types
@src/lib/correction/types.ts

# Existing scoring utilities to leverage
@src/lib/utils/string-similarity.ts
@src/lib/utils/fuzzy-match.ts
@src/lib/utils/artist-matching.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scoring types</name>
  <files>src/lib/correction/scoring/types.ts</files>
  <action>
Create type definitions for the scoring system.

```typescript
// src/lib/correction/scoring/types.ts

import type { CorrectionSearchResult } from '../types';

/**
 * Available scoring strategies
 * - normalized: 0-1 scale using string-similarity
 * - tiered: high/medium/low confidence levels
 * - weighted: 0-100 with multiple signals
 */
export type ScoringStrategy = 'normalized' | 'tiered' | 'weighted';

/**
 * Confidence tier for tiered scoring
 */
export type ConfidenceTier = 'high' | 'medium' | 'low' | 'none';

/**
 * Score breakdown showing component scores
 */
export interface ScoreBreakdown {
  /** Title match score (strategy-specific range) */
  titleScore: number;
  /** Artist match score (strategy-specific range) */
  artistScore: number;
  /** Year/date score (strategy-specific range) */
  yearScore: number;
  /** For tiered strategy: confidence level */
  confidenceTier?: ConfidenceTier;
  /** Any additional signals */
  [key: string]: number | string | undefined;
}

/**
 * A search result with scoring applied
 */
export interface ScoredSearchResult extends CorrectionSearchResult {
  /** Normalized score 0-1 for sorting (all strategies produce this) */
  normalizedScore: number;
  /** Raw display score (0-1, 0-100, or tier name depending on strategy) */
  displayScore: number | string;
  /** Component score breakdown for debugging */
  breakdown: ScoreBreakdown;
  /** True if score is below low-confidence threshold */
  isLowConfidence: boolean;
  /** Which strategy produced this score */
  scoringStrategy: ScoringStrategy;
}

/**
 * Interface for scoring strategy implementations
 */
export interface SearchScorer {
  /**
   * Score a single search result
   * @param result - The search result to score
   * @param albumQuery - Original album query
   * @param artistQuery - Original artist query (optional)
   * @returns Scored result with normalized score, display score, and breakdown
   */
  score(
    result: CorrectionSearchResult,
    albumQuery: string,
    artistQuery?: string
  ): ScoredSearchResult;

  /** Strategy identifier */
  readonly strategy: ScoringStrategy;
}

/**
 * Options for scoring service
 */
export interface ScoringOptions {
  /** Which strategy to use */
  strategy?: ScoringStrategy;
  /** Threshold below which results are flagged as low-confidence (0-1 scale) */
  lowConfidenceThreshold?: number;
}
```

Export all types.
  </action>
  <verify>`pnpm type-check` passes</verify>
  <done>Scoring types defined: ScoringStrategy, ScoreBreakdown, ScoredSearchResult, SearchScorer interface</done>
</task>

<task type="auto">
  <name>Task 2: Implement three scoring strategies</name>
  <files>src/lib/correction/scoring/normalized-scorer.ts, src/lib/correction/scoring/tiered-scorer.ts, src/lib/correction/scoring/weighted-scorer.ts</files>
  <action>
Create three scorer implementations following the SearchScorer interface.

**normalized-scorer.ts** - Uses string-similarity.ts (0-1 range):

```typescript
import { calculateStringSimilarity, normalizeString } from '@/lib/utils/string-similarity';
import type { CorrectionSearchResult } from '../types';
import type { SearchScorer, ScoredSearchResult, ScoreBreakdown } from './types';

/**
 * Normalized scorer: 0-1 scale using string similarity
 * Good for: Simple, interpretable scores
 */
export class NormalizedScorer implements SearchScorer {
  readonly strategy = 'normalized' as const;

  score(
    result: CorrectionSearchResult,
    albumQuery: string,
    artistQuery?: string
  ): ScoredSearchResult {
    // Calculate title similarity
    const titleScore = calculateStringSimilarity(result.title, albumQuery);

    // Calculate artist similarity (boost exact matches)
    let artistScore = 0;
    if (artistQuery && result.primaryArtistName) {
      artistScore = calculateStringSimilarity(result.primaryArtistName, artistQuery);
      // Boost if exact match after normalization
      if (normalizeString(result.primaryArtistName) === normalizeString(artistQuery)) {
        artistScore = Math.min(1, artistScore * 1.2);
      }
    }

    // Year score: 1.0 if year present, 0 if not (simple presence check)
    const yearScore = result.firstReleaseDate ? 1.0 : 0;

    // Combine scores with equal weights (per CONTEXT.md)
    const weights = artistQuery ? 3 : 2; // title + artist + year OR title + year
    const normalizedScore = artistQuery
      ? (titleScore + artistScore + yearScore * 0.5) / 2.5
      : (titleScore + yearScore * 0.5) / 1.5;

    const breakdown: ScoreBreakdown = {
      titleScore: Math.round(titleScore * 100) / 100,
      artistScore: Math.round(artistScore * 100) / 100,
      yearScore: yearScore,
    };

    return {
      ...result,
      normalizedScore: Math.round(normalizedScore * 100) / 100,
      displayScore: Math.round(normalizedScore * 100) / 100,
      breakdown,
      isLowConfidence: false, // Set by service
      scoringStrategy: 'normalized',
    };
  }
}
```

**tiered-scorer.ts** - Uses fuzzysort for confidence tiers:

```typescript
import fuzzysort from 'fuzzysort';
import { normalizeString } from '@/lib/utils/string-similarity';
import type { CorrectionSearchResult } from '../types';
import type { SearchScorer, ScoredSearchResult, ScoreBreakdown, ConfidenceTier } from './types';

// Thresholds from existing fuzzy-match.ts pattern
const SCORE_THRESHOLDS = {
  HIGH: -1000,    // fuzzysort score >= -1000
  MEDIUM: -3000,  // fuzzysort score >= -3000
  LOW: -5000,     // fuzzysort score >= -5000
};

function getConfidenceTier(score: number): ConfidenceTier {
  if (score >= SCORE_THRESHOLDS.HIGH) return 'high';
  if (score >= SCORE_THRESHOLDS.MEDIUM) return 'medium';
  if (score >= SCORE_THRESHOLDS.LOW) return 'low';
  return 'none';
}

function tierToNormalized(tier: ConfidenceTier): number {
  switch (tier) {
    case 'high': return 1.0;
    case 'medium': return 0.7;
    case 'low': return 0.4;
    case 'none': return 0.1;
  }
}

/**
 * Tiered scorer: high/medium/low/none confidence levels
 * Good for: Clear categorical feedback to admins
 */
export class TieredScorer implements SearchScorer {
  readonly strategy = 'tiered' as const;

  score(
    result: CorrectionSearchResult,
    albumQuery: string,
    artistQuery?: string
  ): ScoredSearchResult {
    const normalizedTitle = normalizeString(result.title);
    const normalizedQuery = normalizeString(albumQuery);

    // Get fuzzysort score for title
    const titleResult = fuzzysort.single(normalizedQuery, normalizedTitle);
    const titleFuzzyScore = titleResult?.score ?? -10000;
    const titleTier = getConfidenceTier(titleFuzzyScore);

    // Get fuzzysort score for artist if provided
    let artistTier: ConfidenceTier = 'none';
    let artistFuzzyScore = -10000;
    if (artistQuery && result.primaryArtistName) {
      const normalizedArtist = normalizeString(result.primaryArtistName);
      const normalizedArtistQuery = normalizeString(artistQuery);
      const artistResult = fuzzysort.single(normalizedArtistQuery, normalizedArtist);
      artistFuzzyScore = artistResult?.score ?? -10000;
      artistTier = getConfidenceTier(artistFuzzyScore);
    }

    // Combined tier: use the worse of title/artist, but boost if both are good
    let combinedTier: ConfidenceTier;
    if (artistQuery) {
      // Both must be at least medium for high confidence
      if (titleTier === 'high' && artistTier === 'high') {
        combinedTier = 'high';
      } else if (titleTier !== 'none' && artistTier !== 'none') {
        combinedTier = titleTier === 'low' || artistTier === 'low' ? 'low' : 'medium';
      } else {
        combinedTier = 'none';
      }
    } else {
      combinedTier = titleTier;
    }

    const yearScore = result.firstReleaseDate ? 1 : 0;

    const breakdown: ScoreBreakdown = {
      titleScore: titleFuzzyScore,
      artistScore: artistFuzzyScore,
      yearScore,
      confidenceTier: combinedTier,
    };

    return {
      ...result,
      normalizedScore: tierToNormalized(combinedTier),
      displayScore: combinedTier,
      breakdown,
      isLowConfidence: false,
      scoringStrategy: 'tiered',
    };
  }
}
```

**weighted-scorer.ts** - Multi-signal 0-100 scoring (pattern from artist-matching.ts):

```typescript
import { calculateStringSimilarity, normalizeString } from '@/lib/utils/string-similarity';
import type { CorrectionSearchResult } from '../types';
import type { SearchScorer, ScoredSearchResult, ScoreBreakdown } from './types';

/**
 * Weighted scorer: 0-100 scale with multiple signals
 * Good for: Fine-grained ranking with transparent breakdown
 */
export class WeightedScorer implements SearchScorer {
  readonly strategy = 'weighted' as const;

  // Equal weights per CONTEXT.md
  private readonly WEIGHTS = {
    title: 40,      // 40 points max
    artist: 40,     // 40 points max
    year: 10,       // 10 points for having year data
    mbScore: 10,    // 10 points from MB search relevance
  };

  score(
    result: CorrectionSearchResult,
    albumQuery: string,
    artistQuery?: string
  ): ScoredSearchResult {
    // Title match (0-40 points)
    const titleSimilarity = calculateStringSimilarity(result.title, albumQuery);
    const titleScore = titleSimilarity * this.WEIGHTS.title;

    // Artist match (0-40 points) - only if artist query provided
    let artistScore = 0;
    if (artistQuery && result.primaryArtistName) {
      const artistSimilarity = calculateStringSimilarity(result.primaryArtistName, artistQuery);
      artistScore = artistSimilarity * this.WEIGHTS.artist;
      
      // Bonus for exact match
      if (normalizeString(result.primaryArtistName) === normalizeString(artistQuery)) {
        artistScore = Math.min(this.WEIGHTS.artist, artistScore * 1.1);
      }
    } else if (!artistQuery) {
      // If no artist query, redistribute artist weight to title
      const bonusTitleScore = titleSimilarity * (this.WEIGHTS.artist / 2);
      // Don't actually add it - keep scoring consistent
    }

    // Year presence (0-10 points)
    const yearScore = result.firstReleaseDate ? this.WEIGHTS.year : 0;

    // MusicBrainz relevance score (0-10 points) - normalized from 0-100
    const mbScoreNormalized = (result.mbScore / 100) * this.WEIGHTS.mbScore;

    // Calculate total (max depends on whether artist was searched)
    const maxScore = artistQuery 
      ? this.WEIGHTS.title + this.WEIGHTS.artist + this.WEIGHTS.year + this.WEIGHTS.mbScore
      : this.WEIGHTS.title + this.WEIGHTS.year + this.WEIGHTS.mbScore;
    
    const totalScore = artistQuery
      ? titleScore + artistScore + yearScore + mbScoreNormalized
      : titleScore + yearScore + mbScoreNormalized;

    const normalizedScore = totalScore / maxScore;

    const breakdown: ScoreBreakdown = {
      titleScore: Math.round(titleScore * 10) / 10,
      artistScore: Math.round(artistScore * 10) / 10,
      yearScore,
      mbScore: Math.round(mbScoreNormalized * 10) / 10,
    };

    return {
      ...result,
      normalizedScore: Math.round(normalizedScore * 100) / 100,
      displayScore: Math.round(totalScore),
      breakdown,
      isLowConfidence: false,
      scoringStrategy: 'weighted',
    };
  }
}
```

Export each class as default and named export.
  </action>
  <verify>
1. `pnpm type-check` passes
2. `pnpm lint src/lib/correction/scoring/` passes
3. Each file imports its required utilities (string-similarity, fuzzysort)
  </verify>
  <done>Three scorer classes implemented: NormalizedScorer, TieredScorer, WeightedScorer - each following SearchScorer interface</done>
</task>

<task type="auto">
  <name>Task 3: Create SearchScoringService and update exports</name>
  <files>src/lib/correction/scoring/index.ts, src/lib/correction/types.ts, src/lib/correction/index.ts</files>
  <action>
Create the scoring service that orchestrates strategy selection and result scoring.

**scoring/index.ts:**

```typescript
import type { CorrectionSearchResult } from '../types';
import type { SearchScorer, ScoredSearchResult, ScoringOptions, ScoringStrategy } from './types';
import { NormalizedScorer } from './normalized-scorer';
import { TieredScorer } from './tiered-scorer';
import { WeightedScorer } from './weighted-scorer';

// Re-export types
export * from './types';

// Default low-confidence threshold (per RESEARCH.md recommendation)
const DEFAULT_LOW_CONFIDENCE_THRESHOLD = 0.5;

/**
 * Service for scoring and ranking correction search results
 * Supports pluggable strategies for dev testing
 */
export class SearchScoringService {
  private strategy: ScoringStrategy = 'normalized';
  private lowConfidenceThreshold = DEFAULT_LOW_CONFIDENCE_THRESHOLD;

  /**
   * Set the scoring strategy
   */
  setStrategy(strategy: ScoringStrategy): void {
    this.strategy = strategy;
  }

  /**
   * Get current strategy
   */
  getStrategy(): ScoringStrategy {
    return this.strategy;
  }

  /**
   * Set low-confidence threshold (0-1)
   */
  setLowConfidenceThreshold(threshold: number): void {
    this.lowConfidenceThreshold = Math.max(0, Math.min(1, threshold));
  }

  /**
   * Score a list of search results
   * @param results - Raw search results
   * @param albumQuery - Original album query
   * @param artistQuery - Original artist query
   * @param options - Optional overrides for strategy and threshold
   * @returns Scored and sorted results
   */
  scoreResults(
    results: CorrectionSearchResult[],
    albumQuery: string,
    artistQuery?: string,
    options?: ScoringOptions
  ): ScoredSearchResult[] {
    const strategy = options?.strategy ?? this.strategy;
    const threshold = options?.lowConfidenceThreshold ?? this.lowConfidenceThreshold;
    
    const scorer = this.getScorer(strategy);

    return results
      .map(result => {
        const scored = scorer.score(result, albumQuery, artistQuery);
        return {
          ...scored,
          isLowConfidence: scored.normalizedScore < threshold,
        };
      })
      .sort((a, b) => b.normalizedScore - a.normalizedScore);
  }

  /**
   * Get scorer instance for strategy
   */
  private getScorer(strategy: ScoringStrategy): SearchScorer {
    switch (strategy) {
      case 'normalized':
        return new NormalizedScorer();
      case 'tiered':
        return new TieredScorer();
      case 'weighted':
        return new WeightedScorer();
      default:
        return new NormalizedScorer();
    }
  }
}

// Singleton instance
let scoringServiceInstance: SearchScoringService | null = null;

export function getSearchScoringService(): SearchScoringService {
  if (!scoringServiceInstance) {
    scoringServiceInstance = new SearchScoringService();
  }
  return scoringServiceInstance;
}
```

**Update src/lib/correction/types.ts** - Add re-export of scoring types at the bottom:

```typescript
// Re-export scoring types for convenience
export type { ScoredSearchResult, ScoringStrategy, ScoreBreakdown, ConfidenceTier } from './scoring/types';
```

**Update src/lib/correction/index.ts** - Add scoring exports:

```typescript
// Types
export * from './types';

// Search service
export { CorrectionSearchService, getCorrectionSearchService } from './search-service';

// Scoring
export { SearchScoringService, getSearchScoringService } from './scoring';
export type { ScoringOptions, SearchScorer } from './scoring';
```
  </action>
  <verify>
1. `pnpm type-check` passes
2. `pnpm lint src/lib/correction/` passes  
3. Can import: `import { SearchScoringService, ScoringStrategy, ScoredSearchResult } from '@/lib/correction'`
  </verify>
  <done>
SearchScoringService created with:
- setStrategy() to switch between scoring approaches
- scoreResults() that applies scoring and sorts by normalizedScore
- Low-confidence flagging with configurable threshold
- All types exported from correction module
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Type safety: `pnpm type-check` passes
2. Linting: `pnpm lint src/lib/correction/` passes
3. Three scorers exist: normalized-scorer.ts, tiered-scorer.ts, weighted-scorer.ts
4. Each scorer implements SearchScorer interface
5. SearchScoringService can switch strategies at runtime
6. All exports accessible from `@/lib/correction`
</verification>

<success_criteria>
- Three scoring strategies implemented: normalized (0-1), tiered (high/medium/low), weighted (0-100)
- SearchScoringService.scoreResults() accepts results and query, returns ScoredSearchResult[]
- All scored results have: normalizedScore (0-1), displayScore, breakdown, isLowConfidence
- Strategy can be changed via setStrategy()
- Low-confidence threshold is configurable
</success_criteria>

<output>
After completion, create `.planning/phases/02-search-service/02-02-SUMMARY.md`
</output>
