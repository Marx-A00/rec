---
phase: 02-search-service
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/correction/search-service.ts
  - src/lib/correction/types.ts
  - src/lib/correction/index.ts
autonomous: true

must_haves:
  truths:
    - "CorrectionSearchService.search() accepts album title and artist name, returns results"
    - "Search uses ADMIN priority tier for queue jobs"
    - "Results include release group MBID, title, artist, release date, primary type"
    - "Cover Art Archive URL is computed for each result"
    - "Search respects rate limiting via queue-service"
  artifacts:
    - path: "src/lib/correction/search-service.ts"
      provides: "CorrectionSearchService class with search method"
      exports: ["CorrectionSearchService", "getCorrectionSearchService"]
    - path: "src/lib/correction/types.ts"
      provides: "Type definitions for correction search"
      exports: ["CorrectionSearchResult", "CorrectionSearchOptions"]
    - path: "src/lib/correction/index.ts"
      provides: "Barrel exports for correction module"
  key_links:
    - from: "src/lib/correction/search-service.ts"
      to: "src/lib/musicbrainz/queue-service.ts"
      via: "getQueuedMusicBrainzService import"
      pattern: "getQueuedMusicBrainzService"
    - from: "src/lib/correction/search-service.ts"
      to: "src/lib/queue/jobs.ts"
      via: "PRIORITY_TIERS.ADMIN import"
      pattern: "PRIORITY_TIERS"
---

<objective>
Create the CorrectionSearchService that searches MusicBrainz for album correction candidates.

Purpose: This is the core service layer for admin album corrections. It wraps the existing queue-based MusicBrainz search with ADMIN priority, normalizes results into a correction-specific format, and computes Cover Art Archive URLs for thumbnails.

Output: A new `src/lib/correction/` module with search service and types that Phase 2 plans 02-03 will extend with scoring.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-search-service/02-CONTEXT.md
@.planning/phases/02-search-service/02-RESEARCH.md

# Phase 1 outputs (provides queue infrastructure)
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md

# Existing patterns to follow
@src/lib/musicbrainz/queue-service.ts
@src/lib/musicbrainz/query-builder.ts
@src/lib/musicbrainz/basic-service.ts
@src/lib/queue/jobs.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create correction types</name>
  <files>src/lib/correction/types.ts</files>
  <action>
Create type definitions for the correction search system.

Define these types:

```typescript
/**
 * Options for correction search
 */
export interface CorrectionSearchOptions {
  /** Album title to search for */
  albumTitle?: string;
  /** Artist name to filter by */
  artistName?: string;
  /** Optional year filter (e.g., 2023) */
  yearFilter?: number;
  /** Maximum results to return (default 10) */
  limit?: number;
  /** Offset for pagination */
  offset?: number;
}

/**
 * Artist credit from MusicBrainz
 */
export interface CorrectionArtistCredit {
  /** Artist MBID */
  mbid: string;
  /** Artist name as credited */
  name: string;
  /** Join phrase (e.g., " & ", " feat. ") */
  joinPhrase?: string;
}

/**
 * A single search result for correction
 */
export interface CorrectionSearchResult {
  /** Release group MBID */
  releaseGroupMbid: string;
  /** Album title */
  title: string;
  /** Disambiguation (e.g., "deluxe edition") */
  disambiguation?: string;
  /** Primary artist credits */
  artistCredits: CorrectionArtistCredit[];
  /** Formatted primary artist name for display */
  primaryArtistName: string;
  /** First release date (YYYY or YYYY-MM-DD) */
  firstReleaseDate?: string;
  /** Primary type (Album, EP, Single, etc.) */
  primaryType?: string;
  /** Secondary types (Compilation, Live, Remix, etc.) */
  secondaryTypes?: string[];
  /** MusicBrainz search score (0-100) */
  mbScore: number;
  /** Cover Art Archive thumbnail URL (250px) */
  coverArtUrl: string | null;
  /** Source indicator */
  source: 'musicbrainz';
}

/**
 * Response from correction search
 */
export interface CorrectionSearchResponse {
  /** Search results */
  results: CorrectionSearchResult[];
  /** Total results available (for pagination) */
  totalCount?: number;
  /** Whether more results are available */
  hasMore: boolean;
  /** The query that was executed */
  query: {
    albumTitle?: string;
    artistName?: string;
    yearFilter?: number;
  };
}
```

Export all types from the file.
  </action>
  <verify>Run `pnpm type-check` - should pass with new types defined</verify>
  <done>Types file exists with CorrectionSearchResult, CorrectionSearchOptions, CorrectionSearchResponse exported</done>
</task>

<task type="auto">
  <name>Task 2: Create CorrectionSearchService</name>
  <files>src/lib/correction/search-service.ts, src/lib/correction/index.ts</files>
  <action>
Create the CorrectionSearchService class that wraps MusicBrainz search with ADMIN priority.

In `search-service.ts`:

1. Import dependencies:
   - `getQueuedMusicBrainzService` from `@/lib/musicbrainz/queue-service`
   - `PRIORITY_TIERS` from `@/lib/queue`
   - `buildDualInputQuery, hasSearchableInput` from `@/lib/musicbrainz/query-builder`
   - Types from `./types`

2. Create `CorrectionSearchService` class with:

```typescript
export class CorrectionSearchService {
  private mbService = getQueuedMusicBrainzService();

  /**
   * Search MusicBrainz for correction candidates
   * Uses ADMIN priority tier for responsive admin UI
   */
  async search(options: CorrectionSearchOptions): Promise<CorrectionSearchResponse> {
    // Validate input - require at least album or artist
    if (!hasSearchableInput(options.albumTitle, options.artistName)) {
      return {
        results: [],
        hasMore: false,
        query: { albumTitle: options.albumTitle, artistName: options.artistName }
      };
    }

    // Build Lucene query using existing query-builder
    let query = buildDualInputQuery(options.albumTitle, options.artistName);
    
    // Add year filter if provided
    if (options.yearFilter) {
      query += ` AND firstreleasedate:${options.yearFilter}*`;
    }

    const limit = options.limit ?? 10;
    const offset = options.offset ?? 0;

    // Execute search with ADMIN priority
    const results = await this.mbService.searchReleaseGroups(
      query,
      limit,
      offset,
      PRIORITY_TIERS.ADMIN
    );

    // Map to correction result format
    const correctionResults = results.map(rg => this.mapToResult(rg));

    return {
      results: correctionResults,
      hasMore: results.length === limit,
      query: {
        albumTitle: options.albumTitle,
        artistName: options.artistName,
        yearFilter: options.yearFilter
      }
    };
  }

  /**
   * Map MusicBrainz release group to correction result
   */
  private mapToResult(rg: ReleaseGroupSearchResult): CorrectionSearchResult {
    // Extract artist credits
    const artistCredits: CorrectionArtistCredit[] = (rg.artistCredit || []).map(ac => ({
      mbid: ac.artist.id,
      name: ac.name,
      joinPhrase: ac.joinphrase
    }));

    // Build primary artist name from credits
    const primaryArtistName = artistCredits
      .map((ac, i) => ac.name + (ac.joinPhrase || (i < artistCredits.length - 1 ? ', ' : '')))
      .join('')
      .trim();

    // Compute CAA URL (250px thumbnail)
    const coverArtUrl = `https://coverartarchive.org/release-group/${rg.id}/front-250`;

    return {
      releaseGroupMbid: rg.id,
      title: rg.title,
      disambiguation: rg.disambiguation,
      artistCredits,
      primaryArtistName: primaryArtistName || 'Unknown Artist',
      firstReleaseDate: rg.firstReleaseDate,
      primaryType: rg.primaryType,
      secondaryTypes: rg.secondaryTypes,
      mbScore: rg.score,
      coverArtUrl,
      source: 'musicbrainz'
    };
  }
}
```

3. Add singleton pattern (HMR-safe like queue-service.ts):

```typescript
const globalForCorrection = globalThis as unknown as {
  correctionSearchService: CorrectionSearchService | undefined;
};

export function getCorrectionSearchService(): CorrectionSearchService {
  if (!globalForCorrection.correctionSearchService) {
    globalForCorrection.correctionSearchService = new CorrectionSearchService();
  }
  return globalForCorrection.correctionSearchService;
}
```

4. Create `index.ts` barrel file exporting:
   - All types from `./types`
   - `CorrectionSearchService`, `getCorrectionSearchService` from `./search-service`

Note: The `ReleaseGroupSearchResult` type is from `@/lib/musicbrainz/basic-service` - import it for the mapToResult parameter type.
  </action>
  <verify>
Run these checks:
1. `pnpm type-check` - should pass
2. `pnpm lint src/lib/correction/` - should pass
3. Verify exports: `grep -r "getCorrectionSearchService" src/lib/correction/index.ts`
  </verify>
  <done>
CorrectionSearchService exists with:
- search() method accepting CorrectionSearchOptions
- Uses PRIORITY_TIERS.ADMIN for queue jobs
- Returns CorrectionSearchResponse with mapped results
- Cover Art Archive URLs computed for each result
- Singleton pattern with getCorrectionSearchService()
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Type safety: `pnpm type-check` passes
2. Linting: `pnpm lint src/lib/correction/` passes
3. Exports work: Can import `{ getCorrectionSearchService, CorrectionSearchResult }` from `@/lib/correction`
4. Key link: search-service.ts imports and uses `PRIORITY_TIERS.ADMIN`
5. Key link: search-service.ts imports and uses `getQueuedMusicBrainzService`
</verification>

<success_criteria>
- CorrectionSearchService class exists with search() method
- search() accepts album title and artist name, returns typed results
- All searches use ADMIN priority tier (verifiable in code)
- Results include: releaseGroupMbid, title, artistCredits, firstReleaseDate, primaryType, coverArtUrl
- Module exports work from src/lib/correction/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/02-search-service/02-01-SUMMARY.md`
</output>
