---
phase: 02-search-service
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - src/lib/correction/search-service.ts
  - src/lib/correction/types.ts
  - src/lib/correction/index.ts
autonomous: true

must_haves:
  truths:
    - "CorrectionSearchService.searchWithScoring() returns scored and sorted results"
    - "Results are grouped by release group MBID (deduplication)"
    - "Each group has primaryResult and alternateVersions"
    - "Albums are prioritized over EPs/Singles in sort order"
    - "Load more pagination works with offset"
  artifacts:
    - path: "src/lib/correction/search-service.ts"
      provides: "Extended search service with scoring integration and deduplication"
      exports: ["searchWithScoring"]
    - path: "src/lib/correction/types.ts"
      provides: "GroupedSearchResult type for deduplicated results"
      exports: ["GroupedSearchResult", "ScoredSearchResponse"]
  key_links:
    - from: "src/lib/correction/search-service.ts"
      to: "src/lib/correction/scoring/index.ts"
      via: "getSearchScoringService import"
      pattern: "getSearchScoringService"
---

<objective>
Integrate scoring into CorrectionSearchService and add result grouping/deduplication.

Purpose: Complete the search service by combining raw MusicBrainz search with fuzzy scoring and release group deduplication. This produces the final scored, grouped results that Phase 7 UI will display.

Output: Enhanced CorrectionSearchService with `searchWithScoring()` method that returns deduplicated, scored, and sorted results ready for UI consumption.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-search-service/02-CONTEXT.md
@.planning/phases/02-search-service/02-RESEARCH.md

# Depends on 02-01 and 02-02
@src/lib/correction/search-service.ts
@src/lib/correction/types.ts
@src/lib/correction/scoring/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add grouped result types</name>
  <files>src/lib/correction/types.ts</files>
  <action>
Add types for grouped/deduplicated search results.

Add these types to `src/lib/correction/types.ts`:

```typescript
/**
 * A group of results sharing the same release group
 * Used for deduplication - shows one primary result with alternate versions
 */
export interface GroupedSearchResult {
  /** Release group MBID (shared by all results in group) */
  releaseGroupMbid: string;
  /** The primary/best result for this release group */
  primaryResult: ScoredSearchResult;
  /** Alternate versions (remasters, deluxe editions, etc.) */
  alternateVersions: ScoredSearchResult[];
  /** Total number of versions found */
  versionCount: number;
}

/**
 * Response from searchWithScoring
 */
export interface ScoredSearchResponse {
  /** Grouped and scored results */
  results: GroupedSearchResult[];
  /** Flat list of all scored results (before grouping) */
  allResults: ScoredSearchResult[];
  /** Total unique release groups found */
  totalGroups: number;
  /** Whether more results are available */
  hasMore: boolean;
  /** The query parameters used */
  query: {
    albumTitle?: string;
    artistName?: string;
    yearFilter?: number;
  };
  /** Scoring metadata */
  scoring: {
    strategy: ScoringStrategy;
    lowConfidenceThreshold: number;
    lowConfidenceCount: number;
  };
}

/**
 * Options for searchWithScoring
 */
export interface ScoredSearchOptions extends CorrectionSearchOptions {
  /** Scoring strategy to use */
  scoringStrategy?: ScoringStrategy;
  /** Threshold for low-confidence flagging (0-1) */
  lowConfidenceThreshold?: number;
  /** Whether to group by release group (default true) */
  groupByReleaseGroup?: boolean;
}
```

Make sure to import `ScoringStrategy` from `./scoring/types` if not already re-exported.
  </action>
  <verify>`pnpm type-check` passes with new types</verify>
  <done>GroupedSearchResult, ScoredSearchResponse, and ScoredSearchOptions types added</done>
</task>

<task type="auto">
  <name>Task 2: Implement groupByReleaseGroup and searchWithScoring</name>
  <files>src/lib/correction/search-service.ts</files>
  <action>
Add deduplication logic and the main `searchWithScoring()` method.

Update `src/lib/correction/search-service.ts`:

1. Add imports at the top:
```typescript
import { getSearchScoringService } from './scoring';
import type { ScoredSearchResult, ScoringStrategy } from './scoring/types';
import type { 
  GroupedSearchResult, 
  ScoredSearchResponse, 
  ScoredSearchOptions 
} from './types';
```

2. Add the deduplication helper method to the class:

```typescript
/**
 * Group results by release group MBID
 * Prioritizes: Albums > EPs > Singles, then by score
 */
private groupByReleaseGroup(results: ScoredSearchResult[]): GroupedSearchResult[] {
  const groups = new Map<string, ScoredSearchResult[]>();

  // Group by release group MBID
  for (const result of results) {
    const rgid = result.releaseGroupMbid;
    if (!groups.has(rgid)) {
      groups.set(rgid, []);
    }
    groups.get(rgid)!.push(result);
  }

  // Convert to GroupedSearchResult array
  return Array.from(groups.entries()).map(([rgid, versions]) => {
    // Sort versions: Albums first, then by score, then by date (earliest first)
    const sorted = versions.sort((a, b) => {
      // Priority by type: Album > EP > Single > Other
      const typeOrder = (type?: string) => {
        switch (type?.toLowerCase()) {
          case 'album': return 0;
          case 'ep': return 1;
          case 'single': return 2;
          default: return 3;
        }
      };
      
      const typeCompare = typeOrder(a.primaryType) - typeOrder(b.primaryType);
      if (typeCompare !== 0) return typeCompare;

      // Then by score (higher first)
      const scoreCompare = b.normalizedScore - a.normalizedScore;
      if (Math.abs(scoreCompare) > 0.01) return scoreCompare;

      // Then by date (earlier first for original releases)
      const dateA = a.firstReleaseDate || '9999';
      const dateB = b.firstReleaseDate || '9999';
      return dateA.localeCompare(dateB);
    });

    return {
      releaseGroupMbid: rgid,
      primaryResult: sorted[0],
      alternateVersions: sorted.slice(1),
      versionCount: versions.length,
    };
  });
}
```

3. Add the main `searchWithScoring()` method:

```typescript
/**
 * Search MusicBrainz with scoring and optional deduplication
 * This is the main method for admin correction workflow
 */
async searchWithScoring(options: ScoredSearchOptions): Promise<ScoredSearchResponse> {
  // Execute raw search
  const rawResponse = await this.search({
    albumTitle: options.albumTitle,
    artistName: options.artistName,
    yearFilter: options.yearFilter,
    limit: options.limit,
    offset: options.offset,
  });

  // Apply scoring
  const scoringService = getSearchScoringService();
  const strategy = options.scoringStrategy ?? scoringService.getStrategy();
  const threshold = options.lowConfidenceThreshold ?? 0.5;

  const scoredResults = scoringService.scoreResults(
    rawResponse.results,
    options.albumTitle || '',
    options.artistName,
    {
      strategy,
      lowConfidenceThreshold: threshold,
    }
  );

  // Count low-confidence results
  const lowConfidenceCount = scoredResults.filter(r => r.isLowConfidence).length;

  // Group by release group (default: true)
  const shouldGroup = options.groupByReleaseGroup !== false;
  const groupedResults = shouldGroup 
    ? this.groupByReleaseGroup(scoredResults)
    : scoredResults.map(r => ({
        releaseGroupMbid: r.releaseGroupMbid,
        primaryResult: r,
        alternateVersions: [],
        versionCount: 1,
      }));

  // Sort groups by primary result score
  groupedResults.sort((a, b) => 
    b.primaryResult.normalizedScore - a.primaryResult.normalizedScore
  );

  return {
    results: groupedResults,
    allResults: scoredResults,
    totalGroups: groupedResults.length,
    hasMore: rawResponse.hasMore,
    query: rawResponse.query,
    scoring: {
      strategy,
      lowConfidenceThreshold: threshold,
      lowConfidenceCount,
    },
  };
}

/**
 * Load more results (pagination helper)
 * Continues from previous search with increased offset
 */
async loadMore(
  previousResponse: ScoredSearchResponse,
  additionalCount: number = 10
): Promise<ScoredSearchResponse> {
  const currentCount = previousResponse.allResults.length;
  
  return this.searchWithScoring({
    albumTitle: previousResponse.query.albumTitle,
    artistName: previousResponse.query.artistName,
    yearFilter: previousResponse.query.yearFilter,
    limit: additionalCount,
    offset: currentCount,
    scoringStrategy: previousResponse.scoring.strategy,
    lowConfidenceThreshold: previousResponse.scoring.lowConfidenceThreshold,
  });
}
```

4. Export the new method and types from index.ts if needed.
  </action>
  <verify>
1. `pnpm type-check` passes
2. `pnpm lint src/lib/correction/` passes
3. searchWithScoring method exists and returns ScoredSearchResponse
  </verify>
  <done>
CorrectionSearchService now has:
- searchWithScoring() that returns grouped, scored results
- groupByReleaseGroup() helper for deduplication
- loadMore() pagination helper
- Albums prioritized over EPs/Singles in results
  </done>
</task>

<task type="auto">
  <name>Task 3: Update exports and verify integration</name>
  <files>src/lib/correction/index.ts</files>
  <action>
Ensure all new types and methods are properly exported.

Update `src/lib/correction/index.ts` to include:

```typescript
// Types
export * from './types';

// Search service
export { CorrectionSearchService, getCorrectionSearchService } from './search-service';

// Scoring
export { SearchScoringService, getSearchScoringService } from './scoring';
export type { ScoringOptions, SearchScorer } from './scoring';

// Explicit type exports for clarity
export type {
  CorrectionSearchResult,
  CorrectionSearchOptions,
  CorrectionSearchResponse,
  CorrectionArtistCredit,
  GroupedSearchResult,
  ScoredSearchResponse,
  ScoredSearchOptions,
  ScoredSearchResult,
  ScoringStrategy,
  ScoreBreakdown,
  ConfidenceTier,
} from './types';
```

Then verify the full module works by checking imports compile:

```typescript
// This should work (verify with type-check):
import { 
  getCorrectionSearchService,
  getSearchScoringService,
  type ScoredSearchResponse,
  type GroupedSearchResult,
  type ScoringStrategy,
} from '@/lib/correction';
```
  </action>
  <verify>
1. `pnpm type-check` passes
2. `pnpm lint` passes
3. Run: `grep -r "searchWithScoring" src/lib/correction/` shows the method exists
4. Run: `grep -r "GroupedSearchResult" src/lib/correction/` shows the type is exported
  </verify>
  <done>
All exports verified:
- CorrectionSearchService with search() and searchWithScoring()
- SearchScoringService with scoreResults() and strategy switching
- All types exported from @/lib/correction
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Type safety: `pnpm type-check` passes
2. Linting: `pnpm lint src/lib/correction/` passes
3. Integration test (conceptual):
   ```typescript
   const service = getCorrectionSearchService();
   const response = await service.searchWithScoring({
     albumTitle: 'Abbey Road',
     artistName: 'The Beatles',
     scoringStrategy: 'normalized',
   });
   // response.results is GroupedSearchResult[]
   // response.results[0].primaryResult is ScoredSearchResult
   // response.scoring.strategy === 'normalized'
   ```
4. Deduplication: Multiple versions of same album grouped under one result
5. Sorting: Albums appear before EPs, higher scores appear first
</verification>

<success_criteria>
- searchWithScoring() method exists and returns ScoredSearchResponse
- Results are grouped by release group MBID
- Each group has primaryResult and alternateVersions
- Results sorted by: type (Album > EP > Single), then by score
- loadMore() pagination continues from previous offset
- Scoring metadata included in response (strategy, threshold, lowConfidenceCount)
</success_criteria>

<output>
After completion, create `.planning/phases/02-search-service/02-03-SUMMARY.md`
</output>
