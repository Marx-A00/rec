---
phase: 37-game-state-logic
plan: 03
type: execute
wave: 2
depends_on: [37-01, 37-02]
files_modified:
  - src/lib/uncover/game-service.ts
  - src/lib/graphql/resolvers/mutations.ts
autonomous: true

must_haves:
  truths:
    - "startUncoverSession mutation creates or returns session"
    - "submitGuess mutation validates and records guess"
    - "skipGuess mutation advances game state"
    - "Answer album only exposed when game is over"
  artifacts:
    - path: "src/lib/uncover/game-service.ts"
      provides: "Game business logic"
      exports: ["startSession", "submitGuess", "skipGuess"]
    - path: "src/lib/graphql/resolvers/mutations.ts"
      provides: "GraphQL mutation resolvers"
      contains: "startUncoverSession"
  key_links:
    - from: "src/lib/graphql/resolvers/mutations.ts"
      to: "src/lib/uncover/game-service.ts"
      via: "dynamic import"
      pattern: "import.*game-service"
    - from: "src/lib/uncover/game-service.ts"
      to: "src/lib/uncover/game-validation.ts"
      via: "validation calls"
      pattern: "validateGuess|validateSkip"
---

<objective>
Implement GraphQL mutation resolvers with server-side game logic.

Purpose: Server-side game flow - start session, submit guesses, skip, with validation and database updates.
Output: Working mutations that enforce all game rules server-side.
</objective>

<execution_context>
@/Users/marcosandrade/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcosandrade/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Validation utilities from Plan 01
@src/lib/uncover/game-validation.ts

# Existing mutation patterns
@src/lib/graphql/resolvers/mutations.ts

# Daily challenge service (Phase 35)
@src/lib/daily-challenge/challenge-service.ts

# Research findings
@.planning/phases/37-game-state-logic/37-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create game service with business logic</name>
  <files>src/lib/uncover/game-service.ts</files>
  <action>
Create game service that encapsulates game business logic. Uses validation utilities from Plan 01.

**Import dependencies:**
- Prisma client
- Validation functions from game-validation.ts
- Daily challenge service (getOrCreateDailyChallenge)
- date-utils for toUTCMidnight

**Implement three functions:**

1. **startSession(userId: string, prisma: PrismaClient)**
   - Get today's challenge via getOrCreateDailyChallenge()
   - Check for existing session (challengeId + userId unique constraint)
   - If exists: return existing session with guesses
   - If not: create new session, increment challenge.totalPlays
   - Return: { session, challenge, isNew }
   - Include the album's imageUrl and cloudflareImageId in response (for RevealImage component)

2. **submitGuess(sessionId: string, albumId: string, userId: string, prisma: PrismaClient)**
   - Fetch session with challenge and existing guesses
   - Validate user owns session (session.userId === userId)
   - Call validateGuess from game-validation.ts
   - If invalid: throw GraphQL error with user-friendly message
   - Check if guess is correct: albumId === challenge.albumId
   - Create UncoverGuess record with guessNumber = attemptCount + 1
   - Update session: increment attemptCount, set status/won/completedAt if game over
   - If game over with win: increment challenge.totalWins, update avgAttempts
   - Fetch guessed album info (title, cloudflareImageId, artist name)
   - Return: { guess, session, gameOver, correctAlbum (only if gameOver) }

3. **skipGuess(sessionId: string, userId: string, prisma: PrismaClient)**
   - Fetch session with challenge and existing guesses
   - Validate user owns session
   - Call validateSkip from game-validation.ts
   - Create UncoverGuess with guessedAlbumId = null, isCorrect = false
   - Update session: increment attemptCount, set status to LOST if max attempts reached
   - Return: { guess, session, gameOver, correctAlbum (only if gameOver) }

**Key constraints enforced:**
- GAME-02: 6 attempts max (via validation)
- GAME-05: Win detection (correct albumId)
- GAME-06: Loss detection (6 failed attempts)
- GAME-10: No duplicate guesses (via validation)
- DAILY-03: No replay (session status check)
- SECURITY: Answer only returned when gameOver === true
  </action>
  <verify>
- `pnpm type-check` passes
- Service functions importable
  </verify>
  <done>
Game service exists with startSession, submitGuess, skipGuess functions enforcing all game rules
  </done>
</task>

<task type="auto">
  <name>Task 2: Add mutation resolvers</name>
  <files>src/lib/graphql/resolvers/mutations.ts</files>
  <action>
Add the three mutation resolvers to the existing mutations file. Use dynamic imports pattern like other resolvers.

**Add these resolvers to the mutations object:**

1. **startUncoverSession resolver:**
```typescript
startUncoverSession: async (_parent, _args, context) => {
  // AUTH-01: Require authentication
  if (!context.user) {
    throw new GraphQLError('Authentication required to play the Uncover game', {
      extensions: { code: 'UNAUTHENTICATED' }
    });
  }
  
  // Dynamic import to avoid circular dependencies
  const { startSession } = await import('@/lib/uncover/game-service');
  
  const result = await startSession(context.user.id, context.prisma);
  
  return {
    session: {
      id: result.session.id,
      status: result.session.status,
      attemptCount: result.session.attemptCount,
      won: result.session.won,
      startedAt: result.session.startedAt,
      completedAt: result.session.completedAt,
      guesses: result.session.guesses.map(g => ({
        id: g.id,
        guessNumber: g.guessNumber,
        guessedAlbum: g.guessedAlbum ? {
          id: g.guessedAlbum.id,
          title: g.guessedAlbum.title,
          cloudflareImageId: g.guessedAlbum.cloudflareImageId,
          artistName: g.guessedAlbum.artists?.[0]?.artist?.name || 'Unknown Artist'
        } : null,
        isSkipped: !g.guessedAlbumId,
        isCorrect: g.isCorrect,
        guessedAt: g.guessedAt
      }))
    },
    challengeId: result.challenge.id,
    imageUrl: result.challenge.album.coverArtUrl,
    cloudflareImageId: result.challenge.album.cloudflareImageId
  };
}
```

2. **submitGuess resolver:**
```typescript
submitGuess: async (_parent, args, context) => {
  if (!context.user) {
    throw new GraphQLError('Authentication required', {
      extensions: { code: 'UNAUTHENTICATED' }
    });
  }
  
  const { submitGuess } = await import('@/lib/uncover/game-service');
  
  const result = await submitGuess(
    args.sessionId,
    args.albumId,
    context.user.id,
    context.prisma
  );
  
  return formatGuessResult(result);
}
```

3. **skipGuess resolver:**
```typescript
skipGuess: async (_parent, args, context) => {
  if (!context.user) {
    throw new GraphQLError('Authentication required', {
      extensions: { code: 'UNAUTHENTICATED' }
    });
  }
  
  const { skipGuess } = await import('@/lib/uncover/game-service');
  
  const result = await skipGuess(
    args.sessionId,
    context.user.id,
    context.prisma
  );
  
  return formatGuessResult(result);
}
```

**Add helper function for formatting guess results (above the resolvers):**
```typescript
function formatGuessResult(result: any) {
  return {
    guess: {
      id: result.guess.id,
      guessNumber: result.guess.guessNumber,
      guessedAlbum: result.guess.guessedAlbum ? {
        id: result.guess.guessedAlbum.id,
        title: result.guess.guessedAlbum.title,
        cloudflareImageId: result.guess.guessedAlbum.cloudflareImageId,
        artistName: result.guess.guessedAlbum.artistName
      } : null,
      isSkipped: !result.guess.guessedAlbumId,
      isCorrect: result.guess.isCorrect,
      guessedAt: result.guess.guessedAt
    },
    session: {
      id: result.session.id,
      status: result.session.status,
      attemptCount: result.session.attemptCount,
      won: result.session.won,
      startedAt: result.session.startedAt,
      completedAt: result.session.completedAt,
      guesses: result.session.guesses.map((g: any) => ({
        id: g.id,
        guessNumber: g.guessNumber,
        guessedAlbum: g.guessedAlbum ? {
          id: g.guessedAlbum.id,
          title: g.guessedAlbum.title,
          cloudflareImageId: g.guessedAlbum.cloudflareImageId,
          artistName: g.guessedAlbum.artistName || g.guessedAlbum.artists?.[0]?.artist?.name || 'Unknown'
        } : null,
        isSkipped: !g.guessedAlbumId,
        isCorrect: g.isCorrect,
        guessedAt: g.guessedAt
      }))
    },
    gameOver: result.gameOver,
    correctAlbum: result.correctAlbum ? {
      id: result.correctAlbum.id,
      title: result.correctAlbum.title,
      cloudflareImageId: result.correctAlbum.cloudflareImageId,
      artistName: result.correctAlbum.artistName
    } : null
  };
}
```
  </action>
  <verify>
- `pnpm type-check` passes
- Resolvers are registered in the mutations export
  </verify>
  <done>
Three mutation resolvers implemented with proper auth checks, dynamic imports, and response formatting
  </done>
</task>

</tasks>

<verification>
- `pnpm type-check` passes
- `pnpm lint` passes
- All three mutations callable via GraphQL
</verification>

<success_criteria>
1. Game service implements all game rules
2. Resolvers check authentication (AUTH-01)
3. Answer album only exposed when gameOver is true
4. Session state persists correctly in database
5. All validation errors return user-friendly messages
</success_criteria>

<output>
After completion, create `.planning/phases/37-game-state-logic/37-03-SUMMARY.md`
</output>
