---
phase: 03-preview-service
plan: 03
type: execute
wave: 3
depends_on: ['03-02']
files_modified:
  - src/lib/correction/preview/preview-service.ts
  - src/lib/correction/preview/index.ts
  - src/lib/correction/index.ts
autonomous: true

must_haves:
  truths:
    - 'Preview accepts current album and search result, returns complete diff'
    - 'Preview fetches full MusicBrainz release data for track listing'
    - 'Preview is sufficient for UI rendering without additional API calls'
    - 'Track listing from MusicBrainz source is included'
    - 'External ID changes (MBID) are clearly indicated'
  artifacts:
    - path: 'src/lib/correction/preview/preview-service.ts'
      provides: 'CorrectionPreviewService with generatePreview method'
      exports: ['CorrectionPreviewService', 'getCorrectionPreviewService']
    - path: 'src/lib/correction/index.ts'
      provides: 'Updated barrel with preview exports'
      exports: ['getCorrectionPreviewService', 'CorrectionPreview']
  key_links:
    - from: 'src/lib/correction/preview/preview-service.ts'
      to: 'src/lib/musicbrainz/queue-service.ts'
      via: 'getQueuedMusicBrainzService import'
      pattern: 'getQueuedMusicBrainzService'
    - from: 'src/lib/correction/preview/preview-service.ts'
      to: 'src/lib/correction/preview/diff-engine.ts'
      via: 'DiffEngine import'
      pattern: 'import.*DiffEngine'
    - from: 'src/lib/correction/preview/preview-service.ts'
      to: '@/lib/queue'
      via: 'PRIORITY_TIERS.ADMIN'
      pattern: 'PRIORITY_TIERS'
---

<objective>
Create CorrectionPreviewService that orchestrates diff generation by fetching full MusicBrainz release data and combining all field diffs into a complete preview.

Purpose: Provide a single service method `generatePreview(albumId, searchResult)` that returns everything the UI needs to render the side-by-side comparison without additional API calls.
Output: `src/lib/correction/preview/preview-service.ts`, updated barrel exports
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-preview-service/03-CONTEXT.md
@.planning/phases/03-preview-service/03-RESEARCH.md
@.planning/phases/02-search-service/02-01-SUMMARY.md
@.planning/phases/02-search-service/02-03-SUMMARY.md

@src/lib/correction/preview/types.ts (from 03-01)
@src/lib/correction/preview/normalizers.ts (from 03-01)
@src/lib/correction/preview/diff-engine.ts (from 03-02)
@src/lib/correction/types.ts
@src/lib/correction/search-service.ts
@src/lib/musicbrainz/queue-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CorrectionPreviewService</name>
  <files>src/lib/correction/preview/preview-service.ts</files>
  <action>
Create `src/lib/correction/preview/preview-service.ts` with the preview service.

**Imports:**

```typescript
import type { Album, Track } from '@prisma/client';
import { prisma } from '@/lib/prisma';
import { getQueuedMusicBrainzService } from '@/lib/musicbrainz/queue-service';
import { PRIORITY_TIERS } from '@/lib/queue';
import type { ScoredSearchResult } from '../types';
import type {
  CorrectionPreview,
  FieldDiff,
  MBReleaseData,
  ChangeType,
} from './types';
import { DiffEngine } from './diff-engine';
```

**CorrectionPreviewService class:**

```typescript
/**
 * CorrectionPreviewService generates field-by-field diffs between
 * current album data and a selected MusicBrainz search result.
 *
 * The preview contains all data needed for UI rendering without
 * additional API calls.
 */
export class CorrectionPreviewService {
  private readonly mbService = getQueuedMusicBrainzService();
  private readonly diffEngine = new DiffEngine();

  /**
   * Generate a complete preview comparing current album with MusicBrainz source.
   *
   * @param albumId - Database ID of the album to compare
   * @param searchResult - The selected MusicBrainz search result
   * @returns Complete preview with all diffs
   */
  async generatePreview(
    albumId: string,
    searchResult: ScoredSearchResult
  ): Promise<CorrectionPreview> {
    // Fetch current album with tracks
    const currentAlbum = await prisma.album.findUnique({
      where: { id: albumId },
      include: {
        tracks: {
          orderBy: [{ discNumber: 'asc' }, { trackNumber: 'asc' }],
        },
        artists: {
          include: { artist: true },
        },
      },
    });

    if (!currentAlbum) {
      throw new Error(`Album not found: ${albumId}`);
    }

    // Fetch full MusicBrainz release data with tracks
    const mbReleaseData = await this.fetchMBReleaseData(
      searchResult.releaseGroupMbid
    );

    // Build field diffs
    const fieldDiffs: FieldDiff[] = [];

    // Title comparison
    fieldDiffs.push(
      this.diffEngine.compareText(
        'title',
        currentAlbum.title,
        searchResult.title
      )
    );

    // Release date comparison
    fieldDiffs.push(
      this.diffEngine.compareDate(
        currentAlbum.releaseDate,
        searchResult.firstReleaseDate ?? null
      )
    );

    // Release type comparison
    fieldDiffs.push(
      this.diffEngine.compareText(
        'releaseType',
        currentAlbum.releaseType,
        searchResult.primaryType ?? null
      )
    );

    // Secondary types comparison
    fieldDiffs.push(
      this.diffEngine.compareArray(
        'secondaryTypes',
        currentAlbum.secondaryTypes ?? [],
        searchResult.secondaryTypes ?? []
      )
    );

    // Genres comparison (from MB tags if available in full data)
    const sourceGenres = this.extractGenresFromMB(mbReleaseData);
    fieldDiffs.push(
      this.diffEngine.compareArray(
        'genres',
        currentAlbum.genres ?? [],
        sourceGenres
      )
    );

    // External IDs
    fieldDiffs.push(
      this.diffEngine.compareExternalId(
        'musicbrainzId',
        currentAlbum.musicbrainzId,
        searchResult.releaseGroupMbid
      )
    );

    // Artist comparison
    const currentArtistCredits = currentAlbum.artists.map(aa => ({
      mbid: aa.artist.musicbrainzId ?? '',
      name: aa.artist.name,
    }));

    const sourceArtistCredits =
      mbReleaseData?.artistCredit ??
      searchResult.artistCredits.map(ac => ({
        name: ac.name,
        artist: { id: ac.mbid, name: ac.name },
      }));

    const artistDiff = this.diffEngine.compareArtistCredits(
      currentArtistCredits,
      sourceArtistCredits
    );

    // Track comparison
    const { trackDiffs, summary: trackSummary } = mbReleaseData
      ? this.diffEngine.compareTracks(currentAlbum.tracks, mbReleaseData.media)
      : {
          trackDiffs: [],
          summary: {
            totalCurrent: currentAlbum.tracks.length,
            totalSource: 0,
            matching: 0,
            modified: 0,
            added: 0,
            removed: 0,
          },
        };

    // Cover art comparison
    const currentCoverUrl = currentAlbum.coverArtUrl;
    const sourceCoverUrl = searchResult.coverArtUrl;
    const coverArtChangeType = this.classifyCoverArtChange(
      currentCoverUrl,
      sourceCoverUrl
    );

    // Calculate summary
    const changedFields = fieldDiffs.filter(d => d.changeType !== 'UNCHANGED');
    const summary = {
      totalFields: fieldDiffs.length,
      changedFields: changedFields.length,
      addedFields: changedFields.filter(d => d.changeType === 'ADDED').length,
      modifiedFields: changedFields.filter(d => d.changeType === 'MODIFIED')
        .length,
      conflictFields: changedFields.filter(d => d.changeType === 'CONFLICT')
        .length,
      hasTrackChanges:
        trackSummary.modified > 0 ||
        trackSummary.added > 0 ||
        trackSummary.removed > 0,
    };

    return {
      currentAlbum: currentAlbum as Album & { tracks: Track[] },
      sourceResult: searchResult,
      mbReleaseData,
      fieldDiffs,
      artistDiff,
      trackDiffs,
      trackSummary,
      coverArt: {
        currentUrl: currentCoverUrl,
        sourceUrl: sourceCoverUrl,
        changeType: coverArtChangeType,
      },
      summary,
    };
  }

  /**
   * Fetch full MusicBrainz release data including tracks.
   * First fetches release group to get first release, then fetches release with recordings.
   */
  private async fetchMBReleaseData(
    releaseGroupMbid: string
  ): Promise<MBReleaseData | null> {
    try {
      // Get release group with releases
      const releaseGroup = await this.mbService.getReleaseGroup(
        releaseGroupMbid,
        ['releases'],
        PRIORITY_TIERS.ADMIN
      );

      if (!releaseGroup?.releases?.length) {
        return null;
      }

      // Get first release (typically the original edition)
      const firstRelease = releaseGroup.releases[0];

      // Fetch full release with recordings and artist credits
      const release = await this.mbService.getRelease(
        firstRelease.id,
        ['recordings', 'artist-credits'],
        PRIORITY_TIERS.ADMIN
      );

      if (!release) {
        return null;
      }

      // Map to our typed structure
      return {
        id: release.id,
        title: release.title,
        date: release.date,
        country: release.country,
        barcode: release.barcode,
        media: (release.media ?? []).map((medium: Record<string, unknown>) => ({
          position: (medium.position as number) ?? 1,
          format: medium.format as string | undefined,
          trackCount: (medium['track-count'] as number) ?? 0,
          tracks: ((medium.tracks as Array<Record<string, unknown>>) ?? []).map(
            track => ({
              position: (track.position as number) ?? 0,
              recording: {
                id:
                  ((track.recording as Record<string, unknown>)
                    ?.id as string) ?? '',
                title:
                  ((track.recording as Record<string, unknown>)
                    ?.title as string) ?? '',
                length: (track.recording as Record<string, unknown>)?.length as
                  | number
                  | undefined,
                position: (track.position as number) ?? 0,
              },
            })
          ),
        })),
        artistCredit: (
          (release['artist-credit'] as Array<Record<string, unknown>>) ?? []
        ).map(credit => ({
          name: (credit.name as string) ?? '',
          joinphrase: credit.joinphrase as string | undefined,
          artist: {
            id:
              ((credit.artist as Record<string, unknown>)?.id as string) ?? '',
            name:
              ((credit.artist as Record<string, unknown>)?.name as string) ??
              '',
            sortName: (credit.artist as Record<string, unknown>)?.[
              'sort-name'
            ] as string | undefined,
            disambiguation: (credit.artist as Record<string, unknown>)
              ?.disambiguation as string | undefined,
          },
        })),
      };
    } catch (error) {
      console.error('Failed to fetch MusicBrainz release data:', error);
      return null;
    }
  }

  /**
   * Extract genres from MusicBrainz release data.
   * MusicBrainz uses tags with counts, we take top 5 by count.
   */
  private extractGenresFromMB(mbData: MBReleaseData | null): string[] {
    // MusicBrainz release doesn't include tags directly
    // Tags come from release group which was already fetched
    // For now, return empty - genres will come from release group fetch
    // This can be enhanced to fetch release group tags separately if needed
    return [];
  }

  /**
   * Classify cover art change type.
   */
  private classifyCoverArtChange(
    current: string | null,
    source: string | null
  ): ChangeType {
    if (!current && !source) return 'UNCHANGED';
    if (!current && source) return 'ADDED';
    if (current && !source) return 'REMOVED';
    // Both have URLs - can't determine if images are same without fetching
    // Treat as CONFLICT so admin can visually compare
    return 'CONFLICT';
  }
}

// Singleton instance for HMR safety
let previewServiceInstance: CorrectionPreviewService | null = null;

/**
 * Get the singleton CorrectionPreviewService instance.
 */
export function getCorrectionPreviewService(): CorrectionPreviewService {
  if (!previewServiceInstance) {
    previewServiceInstance = new CorrectionPreviewService();
  }
  return previewServiceInstance;
}

// Reset singleton for HMR
if (process.env.NODE_ENV === 'development') {
  // @ts-expect-error - global augmentation for HMR
  if (global.__correctionPreviewService) {
    previewServiceInstance = global.__correctionPreviewService;
  }
}
```

Note on MusicBrainz API:

- `getReleaseGroup(mbid, ['releases'])` returns releases within the group
- `getRelease(mbid, ['recordings', 'artist-credits'])` returns full track listing
- Both methods need to exist on the queued MusicBrainz service (they do - check queue-service.ts)
  </action>
  <verify>
- `pnpm type-check` passes
- Service imports resolve correctly
  </verify>
  <done>CorrectionPreviewService implemented with generatePreview method that fetches MB data and computes all diffs</done>
  </task>

<task type="auto">
  <name>Task 2: Update preview barrel exports</name>
  <files>src/lib/correction/preview/index.ts</files>
  <action>
Update `src/lib/correction/preview/index.ts` to add preview service exports.

Add to existing exports:

```typescript
// Preview Service
export {
  CorrectionPreviewService,
  getCorrectionPreviewService,
} from './preview-service';
```

Full file should now export:

- All types from types.ts
- TextNormalizer, normalizeForComparison, parseDateComponents, formatDateComponents from normalizers.ts
- DiffEngine from diff-engine.ts
- CorrectionPreviewService, getCorrectionPreviewService from preview-service.ts
  </action>
  <verify>
- `pnpm type-check` passes
  </verify>
  <done>Preview barrel exports include service</done>
  </task>

<task type="auto">
  <name>Task 3: Update correction module barrel</name>
  <files>src/lib/correction/index.ts</files>
  <action>
Update `src/lib/correction/index.ts` to re-export key preview types and service.

Add to existing exports:

```typescript
// Preview Service
export {
  getCorrectionPreviewService,
  CorrectionPreviewService,
  DiffEngine,
  TextNormalizer,
} from './preview';

// Preview Types
export type {
  CorrectionPreview,
  ChangeType,
  FieldDiff,
  TextDiff,
  DateDiff,
  ArrayDiff,
  TrackDiff,
  TrackListSummary,
  ArtistCreditDiff,
  ExternalIdDiff,
  MBReleaseData,
} from './preview';
```

This allows consumers to import from `@/lib/correction` directly:

```typescript
import {
  getCorrectionPreviewService,
  type CorrectionPreview,
} from '@/lib/correction';
```

  </action>
  <verify>
- `pnpm type-check` passes
- `pnpm eslint src/lib/correction/` passes
  </verify>
  <done>Correction module barrel includes preview exports</done>
</task>

</tasks>

<verification>
After all tasks:
```bash
pnpm type-check
pnpm eslint src/lib/correction/

# Verify exports

node -e "console.log(require('./src/lib/correction').getCorrectionPreviewService)"

```

All commands should pass without errors.
</verification>

<success_criteria>
- generatePreview accepts albumId and ScoredSearchResult
- Preview fetches full MusicBrainz release with tracks via queue
- Preview returns all field diffs, artist diff, track diffs, and summary
- Cover art URLs included (current and source)
- External ID (musicbrainzId) change clearly indicated
- Service uses ADMIN priority tier for MusicBrainz API calls
- No additional API calls needed by UI to render comparison
</success_criteria>

<output>
After completion, create `.planning/phases/03-preview-service/03-03-SUMMARY.md`
</output>
```
