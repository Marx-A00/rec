---
phase: 03-preview-service
plan: 02
type: execute
wave: 2
depends_on: ['03-01']
files_modified:
  - src/lib/correction/preview/diff-engine.ts
  - src/lib/correction/preview/index.ts
autonomous: true

must_haves:
  truths:
    - 'Text fields produce character-level diff parts for modified values'
    - 'Date comparison highlights which components changed (year/month/day)'
    - 'Array comparison identifies added, removed, and unchanged items'
    - 'Classification distinguishes ADDED (null->value) from CONFLICT (value->different value)'
  artifacts:
    - path: 'src/lib/correction/preview/diff-engine.ts'
      provides: 'DiffEngine class with field comparison methods'
      exports: ['DiffEngine']
    - path: 'src/lib/correction/preview/index.ts'
      provides: 'Barrel exports for preview module'
      exports: ['DiffEngine', 'TextNormalizer', 'normalizeForComparison']
  key_links:
    - from: 'src/lib/correction/preview/diff-engine.ts'
      to: 'diff'
      via: 'diffChars, diffWords import'
      pattern: "import.*from 'diff'"
    - from: 'src/lib/correction/preview/diff-engine.ts'
      to: 'src/lib/correction/preview/normalizers.ts'
      via: 'TextNormalizer import'
      pattern: 'import.*TextNormalizer.*from'
---

<objective>
Create the DiffEngine class that performs field-by-field comparisons between current album data and MusicBrainz source data.

Purpose: Implement the core diff algorithms for text (character-level), dates (component-level), arrays (set operations), and external IDs. The diff engine will be used by CorrectionPreviewService (03-03).
Output: `src/lib/correction/preview/diff-engine.ts` with DiffEngine class, barrel exports
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-preview-service/03-CONTEXT.md
@.planning/phases/03-preview-service/03-RESEARCH.md

@src/lib/correction/preview/types.ts (from 03-01)
@src/lib/correction/preview/normalizers.ts (from 03-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DiffEngine class</name>
  <files>src/lib/correction/preview/diff-engine.ts</files>
  <action>
Create `src/lib/correction/preview/diff-engine.ts` with the DiffEngine class.

**Imports:**

```typescript
import { diffChars, diffWords } from 'diff';
import type {
  ChangeType,
  TextDiff,
  TextDiffPart,
  DateDiff,
  DateComponents,
  ArrayDiff,
  ExternalIdDiff,
  TrackDiff,
  TrackListSummary,
  ArtistCreditDiff,
  MBMedium,
} from './types';
import { TextNormalizer, parseDateComponents } from './normalizers';
import type { CorrectionArtistCredit } from '../types';
import type { Track } from '@prisma/client';
```

**DiffEngine class:**

```typescript
/**
 * DiffEngine computes field-level diffs between current album data and MusicBrainz source.
 * Uses character-level diff for text, component-level for dates, set operations for arrays.
 */
export class DiffEngine {
  /** Length threshold: use character diff below, word diff above */
  private readonly charDiffThreshold = 100;

  /**
   * Classify the change type between two values.
   * - ADDED: current is null/undefined, source has value
   * - REMOVED: current has value, source is null/undefined
   * - UNCHANGED: both null/undefined, or both equal (normalized)
   * - CONFLICT: both have different values (neither null)
   */
  classifyChange(current: unknown, source: unknown): ChangeType {
    const hasCurrentValue =
      current !== null && current !== undefined && current !== '';
    const hasSourceValue =
      source !== null && source !== undefined && source !== '';

    if (!hasCurrentValue && !hasSourceValue) return 'UNCHANGED';
    if (!hasCurrentValue && hasSourceValue) return 'ADDED';
    if (hasCurrentValue && !hasSourceValue) return 'REMOVED';

    // Both have values - check if equal
    if (typeof current === 'string' && typeof source === 'string') {
      return TextNormalizer.areEqual(current, source)
        ? 'UNCHANGED'
        : 'CONFLICT';
    }

    // For non-strings, use strict equality
    return current === source ? 'UNCHANGED' : 'CONFLICT';
  }

  /**
   * Compare text fields with character-level diff.
   * Uses character diff for short text (<100 chars), word diff for longer.
   */
  compareText(
    field: string,
    current: string | null,
    source: string | null
  ): TextDiff {
    const changeType = this.classifyChange(current, source);

    const result: TextDiff = {
      field,
      changeType,
      currentValue: current,
      sourceValue: source,
    };

    // Only compute parts for CONFLICT (both have different values)
    if (changeType === 'CONFLICT' && current && source) {
      const maxLen = Math.max(current.length, source.length);
      const diffFn = maxLen <= this.charDiffThreshold ? diffChars : diffWords;

      const changes = diffFn(current, source);
      result.parts = changes.map(
        (part): TextDiffPart => ({
          value: part.value,
          added: part.added || undefined,
          removed: part.removed || undefined,
        })
      );
    }

    return result;
  }

  /**
   * Compare release dates with component-level highlighting.
   * Shows which part changed: year, month, or day.
   */
  compareDate(current: Date | null, source: string | null): DateDiff {
    const currentComponents = current
      ? parseDateComponents(current.toISOString().split('T')[0])
      : null;
    const sourceComponents = parseDateComponents(source);

    const changeType = this.classifyDateChange(
      currentComponents,
      sourceComponents
    );

    return {
      field: 'releaseDate',
      changeType,
      current: currentComponents,
      source: sourceComponents,
      componentChanges: {
        year: this.classifyChange(
          currentComponents?.year,
          sourceComponents?.year
        ),
        month: this.classifyChange(
          currentComponents?.month,
          sourceComponents?.month
        ),
        day: this.classifyChange(currentComponents?.day, sourceComponents?.day),
      },
    };
  }

  /**
   * Classify overall date change based on components.
   */
  private classifyDateChange(
    current: DateComponents | null,
    source: DateComponents | null
  ): ChangeType {
    if (!current && !source) return 'UNCHANGED';
    if (!current && source) return 'ADDED';
    if (current && !source) return 'REMOVED';

    // Both have values - check if any component differs
    const yearEqual = current!.year === source!.year;
    const monthEqual = current!.month === source!.month;
    const dayEqual = current!.day === source!.day;

    return yearEqual && monthEqual && dayEqual ? 'UNCHANGED' : 'CONFLICT';
  }

  /**
   * Compare array fields (genres, secondaryTypes).
   * Normalizes items before comparison for case/accent insensitivity.
   */
  compareArray(field: string, current: string[], source: string[]): ArrayDiff {
    // Normalize for comparison
    const currentNormalized = new Map(
      current.map(item => [TextNormalizer.normalize(item), item])
    );
    const sourceNormalized = new Map(
      source.map(item => [TextNormalizer.normalize(item), item])
    );

    const added: string[] = [];
    const removed: string[] = [];
    const unchanged: string[] = [];

    // Find unchanged and removed (items in current)
    for (const [normKey, originalValue] of currentNormalized) {
      if (sourceNormalized.has(normKey)) {
        unchanged.push(originalValue);
      } else {
        removed.push(originalValue);
      }
    }

    // Find added (items in source not in current)
    for (const [normKey, originalValue] of sourceNormalized) {
      if (!currentNormalized.has(normKey)) {
        added.push(originalValue);
      }
    }

    // Determine overall change type
    let changeType: ChangeType = 'UNCHANGED';
    if (added.length > 0 && removed.length === 0 && current.length === 0) {
      changeType = 'ADDED';
    } else if (
      removed.length > 0 &&
      added.length === 0 &&
      source.length === 0
    ) {
      changeType = 'REMOVED';
    } else if (added.length > 0 || removed.length > 0) {
      changeType = 'CONFLICT';
    }

    return {
      field,
      changeType,
      currentItems: current,
      sourceItems: source,
      added,
      removed,
      unchanged,
    };
  }

  /**
   * Compare external ID fields (musicbrainzId, spotifyId, discogsId).
   */
  compareExternalId(
    field: 'musicbrainzId' | 'spotifyId' | 'discogsId',
    current: string | null,
    source: string | null
  ): ExternalIdDiff {
    return {
      field,
      changeType: this.classifyChange(current, source),
      currentValue: current,
      sourceValue: source,
    };
  }

  /**
   * Compare artist credits.
   * Creates display strings with joinphrases and computes name diff.
   */
  compareArtistCredits(
    current: CorrectionArtistCredit[],
    source: Array<{
      name: string;
      joinphrase?: string;
      artist: { id: string; name: string };
    }>
  ): ArtistCreditDiff {
    // Format display strings
    const currentDisplay = current.map(c => c.name).join(', ');
    const sourceDisplay = source
      .map((s, i) => {
        const name = s.name;
        const join = i < source.length - 1 ? s.joinphrase || ', ' : '';
        return name + join;
      })
      .join('');

    // Convert source to CorrectionArtistCredit format
    const sourceCredits: CorrectionArtistCredit[] = source.map(s => ({
      mbid: s.artist.id,
      name: s.name,
    }));

    // Classify overall change
    const normalizedCurrent = TextNormalizer.normalize(currentDisplay);
    const normalizedSource = TextNormalizer.normalize(sourceDisplay);

    let changeType: ChangeType;
    if (!current.length && !source.length) {
      changeType = 'UNCHANGED';
    } else if (!current.length && source.length) {
      changeType = 'ADDED';
    } else if (current.length && !source.length) {
      changeType = 'REMOVED';
    } else if (normalizedCurrent === normalizedSource) {
      changeType = 'UNCHANGED';
    } else {
      changeType = 'CONFLICT';
    }

    const result: ArtistCreditDiff = {
      changeType,
      current,
      source: sourceCredits,
      currentDisplay,
      sourceDisplay,
    };

    // Compute name diff for CONFLICT
    if (changeType === 'CONFLICT' && currentDisplay && sourceDisplay) {
      const changes = diffChars(currentDisplay, sourceDisplay);
      result.nameDiff = changes.map(
        (part): TextDiffPart => ({
          value: part.value,
          added: part.added || undefined,
          removed: part.removed || undefined,
        })
      );
    }

    return result;
  }

  /**
   * Compare track listings with position-based alignment.
   * Aligns by disc number and track position.
   */
  compareTracks(
    currentTracks: Track[],
    sourceMediums: MBMedium[]
  ): {
    trackDiffs: TrackDiff[];
    summary: TrackListSummary;
  } {
    const trackDiffs: TrackDiff[] = [];
    let matching = 0;
    let modified = 0;
    let added = 0;
    let removed = 0;

    // Flatten source tracks with disc info
    interface SourceTrack {
      discNumber: number;
      position: number;
      title: string;
      durationMs: number | null;
      mbid: string;
    }

    const sourceTracks: SourceTrack[] = [];
    for (const medium of sourceMediums) {
      for (const track of medium.tracks) {
        sourceTracks.push({
          discNumber: medium.position,
          position: track.position,
          title: track.recording.title,
          durationMs: track.recording.length ?? null,
          mbid: track.recording.id,
        });
      }
    }

    // Group current tracks by disc
    const currentByDisc = new Map<number, Track[]>();
    for (const track of currentTracks) {
      const disc = track.discNumber ?? 1;
      if (!currentByDisc.has(disc)) currentByDisc.set(disc, []);
      currentByDisc.get(disc)!.push(track);
    }

    // Group source tracks by disc
    const sourceByDisc = new Map<number, SourceTrack[]>();
    for (const track of sourceTracks) {
      if (!sourceByDisc.has(track.discNumber))
        sourceByDisc.set(track.discNumber, []);
      sourceByDisc.get(track.discNumber)!.push(track);
    }

    // Get all disc numbers
    const allDiscs = new Set([...currentByDisc.keys(), ...sourceByDisc.keys()]);

    for (const discNum of [...allDiscs].sort((a, b) => a - b)) {
      const currentDiscTracks = currentByDisc.get(discNum) || [];
      const sourceDiscTracks = sourceByDisc.get(discNum) || [];

      // Sort by position
      currentDiscTracks.sort((a, b) => a.trackNumber - b.trackNumber);
      sourceDiscTracks.sort((a, b) => a.position - b.position);

      const maxLen = Math.max(
        currentDiscTracks.length,
        sourceDiscTracks.length
      );

      for (let i = 0; i < maxLen; i++) {
        const currTrack = currentDiscTracks[i];
        const srcTrack = sourceDiscTracks[i];

        if (currTrack && srcTrack) {
          // Both exist - check if match or modified
          const titlesEqual = TextNormalizer.areEqual(
            currTrack.title,
            srcTrack.title
          );
          const durationsEqual = currTrack.durationMs === srcTrack.durationMs;

          const diff: TrackDiff = {
            position: i + 1,
            discNumber: discNum,
            changeType: titlesEqual ? 'MATCH' : 'MODIFIED',
            current: {
              title: currTrack.title,
              durationMs: currTrack.durationMs,
              trackNumber: currTrack.trackNumber,
            },
            source: {
              title: srcTrack.title,
              durationMs: srcTrack.durationMs,
              mbid: srcTrack.mbid,
            },
          };

          if (!titlesEqual) {
            diff.titleDiff = diffChars(currTrack.title, srcTrack.title).map(
              part => ({
                value: part.value,
                added: part.added || undefined,
                removed: part.removed || undefined,
              })
            );
            modified++;
          } else {
            matching++;
          }

          if (
            !durationsEqual &&
            currTrack.durationMs !== null &&
            srcTrack.durationMs !== null
          ) {
            diff.durationDelta = Math.abs(
              currTrack.durationMs - srcTrack.durationMs
            );
          }

          trackDiffs.push(diff);
        } else if (currTrack && !srcTrack) {
          // Track in current but not in source - REMOVED
          trackDiffs.push({
            position: i + 1,
            discNumber: discNum,
            changeType: 'REMOVED',
            current: {
              title: currTrack.title,
              durationMs: currTrack.durationMs,
              trackNumber: currTrack.trackNumber,
            },
          });
          removed++;
        } else if (!currTrack && srcTrack) {
          // Track in source but not in current - ADDED
          trackDiffs.push({
            position: i + 1,
            discNumber: discNum,
            changeType: 'ADDED',
            source: {
              title: srcTrack.title,
              durationMs: srcTrack.durationMs,
              mbid: srcTrack.mbid,
            },
          });
          added++;
        }
      }
    }

    return {
      trackDiffs,
      summary: {
        totalCurrent: currentTracks.length,
        totalSource: sourceTracks.length,
        matching,
        modified,
        added,
        removed,
      },
    };
  }
}
```

  </action>
  <verify>
- `pnpm type-check` passes
- `pnpm eslint src/lib/correction/preview/diff-engine.ts` passes
  </verify>
  <done>DiffEngine class implemented with text, date, array, external ID, artist, and track comparison methods</done>
</task>

<task type="auto">
  <name>Task 2: Create barrel exports</name>
  <files>src/lib/correction/preview/index.ts</files>
  <action>
Create `src/lib/correction/preview/index.ts` barrel exports.

```typescript
// Types
export type {
  ChangeType,
  TextDiff,
  TextDiffPart,
  DateDiff,
  DateComponents,
  ArrayDiff,
  ExternalIdDiff,
  TrackDiff,
  TrackListSummary,
  ArtistCreditDiff,
  FieldDiff,
  CorrectionPreview,
  MBRecording,
  MBMedium,
  MBReleaseData,
} from './types';

// Normalizers
export {
  TextNormalizer,
  normalizeForComparison,
  parseDateComponents,
  formatDateComponents,
} from './normalizers';

// Diff Engine
export { DiffEngine } from './diff-engine';
```

  </action>
  <verify>
- `pnpm type-check` passes
- All exports resolve correctly
  </verify>
  <done>Barrel exports created for preview module</done>
</task>

</tasks>

<verification>
After all tasks:
```bash
pnpm type-check
pnpm eslint src/lib/correction/preview/
```

All commands should pass without errors.
</verification>

<success_criteria>

- DiffEngine.classifyChange correctly distinguishes ADDED/MODIFIED/REMOVED/CONFLICT/UNCHANGED
- DiffEngine.compareText uses character-level diff for short text, word-level for long
- DiffEngine.compareDate returns component-level change types
- DiffEngine.compareArray identifies added/removed/unchanged items
- DiffEngine.compareTracks aligns by position and handles multi-disc albums
- All methods are fully typed (no `any`)
  </success_criteria>

<output>
After completion, create `.planning/phases/03-preview-service/03-02-SUMMARY.md`
</output>
