---
phase: 34-album-pool
plan: 02
type: execute
wave: 2
depends_on: ["34-01"]
files_modified:
  - src/graphql/schema.graphql
  - src/graphql/queries/gamePool.graphql
  - src/lib/graphql/resolvers/mutations.ts
  - src/lib/graphql/resolvers/queries.ts
  - src/lib/game-pool/eligibility.ts
  - src/generated/graphql.ts
autonomous: true

must_haves:
  truths:
    - "Admin can change album game status via GraphQL mutation"
    - "Only albums with cloudflareImageId can be marked ELIGIBLE"
    - "Status changes are logged to LlamaLog with USER_ACTION category"
    - "GraphQL queries return albums filtered by game status"
  artifacts:
    - path: "src/graphql/schema.graphql"
      provides: "AlbumGameStatus enum, mutations, queries"
      contains: "updateAlbumGameStatus"
    - path: "src/lib/game-pool/eligibility.ts"
      provides: "Validation logic for eligibility"
      exports: ["validateEligibility"]
    - path: "src/graphql/queries/gamePool.graphql"
      provides: "Client-side queries for game pool"
  key_links:
    - from: "src/lib/graphql/resolvers/mutations.ts"
      to: "src/lib/logging/llama-logger.ts"
      via: "LlamaLog USER_ACTION"
      pattern: "category.*USER_ACTION"
    - from: "src/lib/graphql/resolvers/mutations.ts"
      to: "src/lib/game-pool/eligibility.ts"
      via: "validateEligibility call"
---

<objective>
Add GraphQL API for managing album game pool status with validation and audit logging.

Purpose: Enable admin UI to query and update album game status with proper validation (cover art required for ELIGIBLE) and audit trail (LlamaLog USER_ACTION).

Output: GraphQL mutations/queries working, validation enforced, audit trail captured.
</objective>

<execution_context>
@/Users/marcosandrade/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcosandrade/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/34-album-pool/34-CONTEXT.md
@.planning/phases/34-album-pool/34-RESEARCH.md
@.planning/phases/34-album-pool/34-01-SUMMARY.md
@src/graphql/schema.graphql
@src/lib/graphql/resolvers/mutations.ts
@src/lib/logging/llama-logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GraphQL schema for game pool</name>
  <files>src/graphql/schema.graphql</files>
  <action>
Add AlbumGameStatus enum to GraphQL schema (near other enums):

```graphql
enum AlbumGameStatus {
  ELIGIBLE
  EXCLUDED
  NONE
}
```

Add gameStatus field to Album type:

```graphql
type Album {
  # ... existing fields
  gameStatus: AlbumGameStatus!
}
```

Add mutation and input types:

```graphql
input UpdateAlbumGameStatusInput {
  albumId: UUID!
  gameStatus: AlbumGameStatus!
  reason: String
}

type UpdateAlbumGameStatusResult {
  success: Boolean!
  album: Album
  error: String
}

type Mutation {
  # ... existing mutations
  updateAlbumGameStatus(input: UpdateAlbumGameStatusInput!): UpdateAlbumGameStatusResult!
}
```

Add queries:

```graphql
type GamePoolStats {
  eligibleCount: Int!
  excludedCount: Int!
  neutralCount: Int!
  totalWithCoverArt: Int!
}

type Query {
  # ... existing queries
  albumsByGameStatus(status: AlbumGameStatus!, limit: Int = 50, offset: Int = 0): [Album!]!
  gamePoolStats: GamePoolStats!
  suggestedGameAlbums(limit: Int = 50): [Album!]!
}
```
  </action>
  <verify>
Run `pnpm codegen` - should complete without errors.
  </verify>
  <done>
GraphQL schema includes AlbumGameStatus enum, gameStatus on Album, mutation, and queries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create eligibility validation module</name>
  <files>src/lib/game-pool/eligibility.ts</files>
  <action>
Create new file `src/lib/game-pool/eligibility.ts`:

```typescript
// src/lib/game-pool/eligibility.ts
// Validation logic for game pool eligibility

import { Album, AlbumGameStatus } from '@prisma/client';

export interface EligibilityResult {
  eligible: boolean;
  reason?: string;
}

/**
 * Validate if an album can be marked as ELIGIBLE for the game pool.
 * Hard requirements:
 * - Must have cloudflareImageId (cover art)
 * - Must have releaseDate (full metadata)
 * - Must have at least one artist
 */
export function validateEligibility(
  album: Pick<Album, 'cloudflareImageId' | 'releaseDate' | 'title'>,
  hasArtists: boolean
): EligibilityResult {
  if (!album.cloudflareImageId) {
    return {
      eligible: false,
      reason: 'Album must have cover art (cloudflareImageId) to be eligible',
    };
  }

  if (!album.releaseDate) {
    return {
      eligible: false,
      reason: 'Album must have a release date to be eligible',
    };
  }

  if (!hasArtists) {
    return {
      eligible: false,
      reason: 'Album must have at least one artist to be eligible',
    };
  }

  return { eligible: true };
}

/**
 * Check if a status transition is valid.
 * All transitions are valid - admin has final say.
 */
export function isValidStatusTransition(
  _from: AlbumGameStatus,
  _to: AlbumGameStatus
): boolean {
  // All transitions allowed - admin has full control
  return true;
}
```

Create the directory if it doesn't exist: `mkdir -p src/lib/game-pool`
  </action>
  <verify>
File exists and exports validateEligibility function.
`pnpm type-check` passes.
  </verify>
  <done>
Eligibility validation module created with cover art, release date, and artist checks.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add resolver implementations</name>
  <files>src/lib/graphql/resolvers/mutations.ts, src/lib/graphql/resolvers/queries.ts</files>
  <action>
In `src/lib/graphql/resolvers/mutations.ts`, add the updateAlbumGameStatus mutation:

```typescript
import { validateEligibility } from '@/lib/game-pool/eligibility';
import { createLlamaLogger } from '@/lib/logging/llama-logger';
import { AlbumGameStatus } from '@prisma/client';

// Add to mutations object:
updateAlbumGameStatus: async (
  _: unknown,
  { input }: { input: { albumId: string; gameStatus: AlbumGameStatus; reason?: string } },
  context: GraphQLContext
) => {
  const { albumId, gameStatus, reason } = input;
  const userId = context.session?.user?.id;

  // Check admin permission
  if (!userId || !['ADMIN', 'OWNER'].includes(context.session?.user?.role || '')) {
    return { success: false, error: 'Unauthorized: Admin access required' };
  }

  // Fetch album with artist count
  const album = await prisma.album.findUnique({
    where: { id: albumId },
    include: { artists: { select: { artistId: true } } },
  });

  if (!album) {
    return { success: false, error: 'Album not found' };
  }

  const previousStatus = album.gameStatus;

  // Validate eligibility for ELIGIBLE status
  if (gameStatus === 'ELIGIBLE') {
    const validation = validateEligibility(album, album.artists.length > 0);
    if (!validation.eligible) {
      return { success: false, error: validation.reason };
    }
  }

  // Update status
  const updatedAlbum = await prisma.album.update({
    where: { id: albumId },
    data: { gameStatus },
    include: {
      artists: { include: { artist: true } },
      tracks: true,
    },
  });

  // Audit trail via LlamaLog
  const llamaLogger = createLlamaLogger(prisma);
  await llamaLogger.logEnrichment({
    entityType: 'ALBUM',
    entityId: albumId,
    albumId,
    operation: 'game_pool:status_change',
    category: 'USER_ACTION',
    sources: ['ADMIN_UI'],
    status: 'SUCCESS',
    reason: reason || `Changed game status from ${previousStatus} to ${gameStatus}`,
    fieldsEnriched: ['gameStatus'],
    userId,
    metadata: {
      previousStatus,
      newStatus: gameStatus,
    },
  });

  return { success: true, album: updatedAlbum };
},
```

In `src/lib/graphql/resolvers/queries.ts`, add the game pool queries:

```typescript
// Add to queries object:
albumsByGameStatus: async (
  _: unknown,
  { status, limit = 50, offset = 0 }: { status: AlbumGameStatus; limit?: number; offset?: number }
) => {
  return prisma.album.findMany({
    where: { gameStatus: status },
    include: {
      artists: { include: { artist: true } },
    },
    orderBy: { title: 'asc' },
    take: limit,
    skip: offset,
  });
},

gamePoolStats: async () => {
  const [eligibleCount, excludedCount, neutralCount, totalWithCoverArt] = await Promise.all([
    prisma.album.count({ where: { gameStatus: 'ELIGIBLE' } }),
    prisma.album.count({ where: { gameStatus: 'EXCLUDED' } }),
    prisma.album.count({ where: { gameStatus: 'NONE' } }),
    prisma.album.count({ where: { cloudflareImageId: { not: null } } }),
  ]);

  return { eligibleCount, excludedCount, neutralCount, totalWithCoverArt };
},

suggestedGameAlbums: async (_: unknown, { limit = 50 }: { limit?: number }) => {
  // Return albums that:
  // 1. Have cloudflareImageId (cover art)
  // 2. Have releaseDate (full metadata)
  // 3. Have not been reviewed (gameStatus = NONE)
  // 4. Have at least one artist
  return prisma.album.findMany({
    where: {
      gameStatus: 'NONE',
      cloudflareImageId: { not: null },
      releaseDate: { not: null },
      artists: { some: {} },
    },
    include: {
      artists: { include: { artist: true } },
    },
    orderBy: { updatedAt: 'desc' },
    take: limit,
  });
},
```

Also add gameStatus to the Album resolver field mappings if there's a custom resolver.
  </action>
  <verify>
Run `pnpm codegen` then `pnpm type-check` - both should pass.
  </verify>
  <done>
Mutation validates eligibility, updates status, logs to LlamaLog. Queries filter by status and return stats.
  </done>
</task>

</tasks>

<verification>
1. `pnpm codegen` completes without errors
2. `pnpm type-check` passes
3. Generated GraphQL types include AlbumGameStatus enum
4. Generated hooks include useUpdateAlbumGameStatusMutation
5. Generated hooks include useAlbumsByGameStatusQuery, useGamePoolStatsQuery, useSuggestedGameAlbumsQuery
</verification>

<success_criteria>
- GraphQL schema has AlbumGameStatus enum and all mutations/queries
- Eligibility validation prevents marking albums without cover art as ELIGIBLE
- Status changes logged to LlamaLog with USER_ACTION category
- albumsByGameStatus query filters correctly
- gamePoolStats returns accurate counts
- suggestedGameAlbums returns unreviewed albums with cover art
</success_criteria>

<output>
After completion, create `.planning/phases/34-album-pool/34-02-SUMMARY.md`
</output>
