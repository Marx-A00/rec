---
phase: 10-manual-edit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/admin/correction/manual/validation.ts
  - src/components/admin/correction/manual/types.ts
  - src/hooks/useCorrectionModalState.ts
  - src/components/admin/correction/StepIndicator.tsx
autonomous: true

must_haves:
  truths:
    - "Zod validation schemas exist for all manual edit fields"
    - "Modal state hook supports manual edit mode flag"
    - "Step indicator shows correct steps based on mode"
  artifacts:
    - path: "src/components/admin/correction/manual/validation.ts"
      provides: "Zod schemas for external ID and field validation"
      exports: ["musicbrainzIdSchema", "spotifyIdSchema", "discogsIdSchema", "partialDateSchema", "manualEditSchema"]
    - path: "src/components/admin/correction/manual/types.ts"
      provides: "TypeScript types for manual edit form state"
      exports: ["ManualEditFormData", "ManualEditFieldState"]
    - path: "src/hooks/useCorrectionModalState.ts"
      provides: "Extended modal state with manual edit support"
      exports: ["useCorrectionModalState"]
  key_links:
    - from: "src/components/admin/correction/manual/validation.ts"
      to: "zod"
      via: "import z from zod"
      pattern: "z\\.string\\(\\)\\.uuid"
---

<objective>
Create validation schemas and modal state support for manual edit mode.

Purpose: Establish the foundation for manual field editing with proper validation and state management. External ID validation (UUID for MusicBrainz, base62 for Spotify, numeric for Discogs) prevents data corruption. Modal state needs to track when user is in manual edit mode vs search mode.

Output: Zod validation schemas, TypeScript types, and extended modal state hook.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-manual-edit/10-CONTEXT.md
@.planning/phases/10-manual-edit/10-RESEARCH.md

@src/hooks/useCorrectionModalState.ts
@src/components/admin/correction/StepIndicator.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod validation schemas for manual edit fields</name>
  <files>src/components/admin/correction/manual/validation.ts</files>
  <action>
Create validation schemas using Zod (already installed):

1. External ID schemas:
   - `musicbrainzIdSchema`: Use `z.string().uuid()` for UUID validation, `.nullable().optional()`
   - `spotifyIdSchema`: Use regex `/^[a-zA-Z0-9]{22}$/` for 22-char base62, `.nullable().optional()`
   - `discogsIdSchema`: Use regex `/^\d+$/` for numeric only, `.nullable().optional()`

2. Field schemas:
   - `titleSchema`: `z.string().min(1, 'Title is required').max(500)`
   - `artistsSchema`: `z.array(z.string().min(1)).min(1, 'At least one artist required')`
   - `partialDateSchema`: Regex for YYYY, YYYY-MM, or YYYY-MM-DD format: `/^(\d{4})(-((0[1-9]|1[0-2])(-((0[1-9]|[12]\d|3[01])))?)?)?$/`
   - `releaseTypeSchema`: Enum with Album, EP, Single, Compilation, Soundtrack, Live, Remix, Other

3. Complete form schema:
   - `manualEditSchema`: Combine all above into object schema
   - Export type `ManualEditFormData = z.infer<typeof manualEditSchema>`

4. Helper function:
   - `validateField<T>(schema: z.ZodType<T>, value: unknown): { success: true, data: T } | { success: false, error: string }`

Error messages should be user-friendly (e.g., "Spotify ID must be 22 alphanumeric characters").
  </action>
  <verify>Import validation.ts in a test file and validate: valid UUID passes musicbrainzIdSchema, invalid UUID fails with message</verify>
  <done>All validation schemas exported, TypeScript types inferred correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create manual edit types and form state interface</name>
  <files>src/components/admin/correction/manual/types.ts</files>
  <action>
Create TypeScript types for manual edit state:

1. `ManualEditFieldState` interface:
   - `title: string`
   - `artists: string[]` (array of artist names)
   - `releaseDate: string | null` (partial date string)
   - `releaseType: ReleaseType | null` (using existing enum or define here)
   - `musicbrainzId: string | null`
   - `spotifyId: string | null`
   - `discogsId: string | null`

2. `ManualEditValidationErrors` interface:
   - All fields optional string (error message or undefined)

3. `ManualEditDirtyState` interface:
   - Track which fields have been modified from initial values
   - `isDirty: boolean` (any field modified)
   - `dirtyFields: Set<keyof ManualEditFieldState>`

4. Factory function:
   - `createInitialEditState(album: CurrentDataViewAlbum): ManualEditFieldState`
   - Pre-populate from current album data

5. Comparison function:
   - `hasUnsavedChanges(initial: ManualEditFieldState, current: ManualEditFieldState): boolean`
   - Used for unsaved changes warning

Import types from CurrentDataView for album structure compatibility.
  </action>
  <verify>TypeScript compiles with no errors when importing types</verify>
  <done>Types exported and factory function creates correct initial state from album</done>
</task>

<task type="auto">
  <name>Task 3: Extend modal state hook for manual edit mode</name>
  <files>src/hooks/useCorrectionModalState.ts, src/components/admin/correction/StepIndicator.tsx</files>
  <action>
Extend useCorrectionModalState hook:

1. Add to ModalState interface:
   - `isManualEditMode: boolean` (distinguishes manual edit from search flow)
   - `manualEditState?: ManualEditFieldState` (persisted edit values)

2. Add new state and setter:
   - `const [isManualEditMode, setIsManualEditModeInternal] = useState(false)`
   - `const [manualEditState, setManualEditStateInternal] = useState<ManualEditFieldState | undefined>()`

3. Add to sessionStorage persistence (load/save with other state)

4. Add new functions to return object:
   - `setManualEditMode: (mode: boolean) => void`
   - `setManualEditState: (state: ManualEditFieldState) => void`
   - `clearManualEditState: () => void`

5. Update step validation:
   - Manual edit mode has 3 steps (Edit, Preview, Apply) vs 4 steps for search mode
   - `isLastStep` should be context-aware based on mode

6. Update StepIndicator:
   - Accept optional `mode?: 'search' | 'manual'` prop
   - Search mode: ["Current Data", "Search", "Preview", "Apply"] (4 steps)
   - Manual mode: ["Current Data", "Edit", "Apply"] (3 steps) - Preview+Apply combined

IMPORTANT: Do NOT change step numbers yet. Just add the state tracking. Step flow changes come in Plan 03.
  </action>
  <verify>`useCorrectionModalState` returns isManualEditMode and setter functions</verify>
  <done>Modal state hook supports manual edit mode flag, StepIndicator accepts mode prop</done>
</task>

</tasks>

<verification>
1. Run `pnpm type-check` - no TypeScript errors
2. Import validation schemas and verify:
   - Valid UUID "12345678-1234-1234-1234-123456789012" passes musicbrainzIdSchema
   - "abc123" fails musicbrainzIdSchema with UUID error message
   - Valid Spotify ID "0gxyHStUsqpMadRV0Di1Qt" passes spotifyIdSchema
   - "12345" passes discogsIdSchema
3. Modal state hook returns new manual edit properties
</verification>

<success_criteria>
- Zod schemas validate all external ID formats correctly
- TypeScript types provide strong typing for form state
- Modal state hook persists manual edit mode in sessionStorage
- StepIndicator can render different steps based on mode
</success_criteria>

<output>
After completion, create `.planning/phases/10-manual-edit/10-01-SUMMARY.md`
</output>
