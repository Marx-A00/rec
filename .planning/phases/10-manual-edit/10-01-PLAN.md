---
phase: 10-manual-edit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/admin/correction/manual/validation.ts
  - src/components/admin/correction/manual/types.ts
  - src/hooks/useCorrectionModalState.ts
  - src/components/admin/correction/StepIndicator.tsx
autonomous: true

must_haves:
  truths:
    - 'Zod validation schemas exist for all manual edit fields'
    - 'Modal state hook supports manual edit mode flag'
    - 'Step indicator accepts mode prop for different step labels'
  artifacts:
    - path: 'src/components/admin/correction/manual/validation.ts'
      provides: 'Zod schemas for external ID and field validation'
      exports:
        [
          'musicbrainzIdSchema',
          'spotifyIdSchema',
          'discogsIdSchema',
          'partialDateSchema',
          'releaseTypeSchema',
          'manualEditSchema',
        ]
    - path: 'src/components/admin/correction/manual/types.ts'
      provides: 'TypeScript types for manual edit form state'
      exports: ['ManualEditFormData', 'ManualEditFieldState', 'ReleaseType']
    - path: 'src/hooks/useCorrectionModalState.ts'
      provides: 'Extended modal state with manual edit support'
      exports: ['useCorrectionModalState']
  key_links:
    - from: 'src/components/admin/correction/manual/validation.ts'
      to: 'zod'
      via: 'import z from zod'
      pattern: "z\\.string\\(\\)\\.uuid"
---

<objective>
Create validation schemas and modal state support for manual edit mode.

Purpose: Establish the foundation for manual field editing with proper validation and state management. External ID validation (UUID for MusicBrainz, base62 for Spotify, numeric for Discogs) prevents data corruption. Modal state needs to track when user is in manual edit mode vs search mode.

Output: Zod validation schemas, TypeScript types, and extended modal state hook.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-manual-edit/10-CONTEXT.md
@.planning/phases/10-manual-edit/10-RESEARCH.md

@src/hooks/useCorrectionModalState.ts
@src/components/admin/correction/StepIndicator.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod validation schemas for manual edit fields</name>
  <files>src/components/admin/correction/manual/validation.ts</files>
  <action>
Create validation schemas using Zod (already installed):

1. External ID schemas:
   - `musicbrainzIdSchema`: Use `z.string().uuid()` for UUID validation, `.nullable().optional()`
   - `spotifyIdSchema`: Use regex `/^[a-zA-Z0-9]{22}$/` for 22-char base62, `.nullable().optional()`
   - `discogsIdSchema`: Use regex `/^\d+$/` for numeric only, `.nullable().optional()`

2. Field schemas:
   - `titleSchema`: `z.string().min(1, 'Title is required').max(500)`
   - `artistsSchema`: `z.array(z.string().min(1)).min(1, 'At least one artist required')`
   - `partialDateSchema`: Regex for YYYY, YYYY-MM, or YYYY-MM-DD format: `/^(\d{4})(-((0[1-9]|1[0-2])(-((0[1-9]|[12]\d|3[01])))?)?)?$/`
   - `releaseTypeSchema`: Prisma uses String (VARCHAR(50)), so define as union of common values but accept any string:

     ```typescript
     // Common release types for dropdown options
     export const RELEASE_TYPES = [
       'Album',
       'EP',
       'Single',
       'Compilation',
       'Soundtrack',
       'Live',
       'Remix',
       'Other',
     ] as const;
     export type ReleaseType = (typeof RELEASE_TYPES)[number];

     // Schema accepts any string (database is VARCHAR(50)), but provides type hints
     export const releaseTypeSchema = z.string().max(50).nullable().optional();
     ```

3. Complete form schema:
   - `manualEditSchema`: Combine all above into object schema
   - Export type `ManualEditFormData = z.infer<typeof manualEditSchema>`

4. Helper function:
   - `validateField<T>(schema: z.ZodType<T>, value: unknown): { success: true, data: T } | { success: false, error: string }`

Error messages should be user-friendly (e.g., "Spotify ID must be 22 alphanumeric characters").
</action>
<verify>Import validation.ts in a test file and validate: valid UUID passes musicbrainzIdSchema, invalid UUID fails with message</verify>
<done>All validation schemas exported, TypeScript types inferred correctly, RELEASE_TYPES constant available for dropdowns</done>
</task>

<task type="auto">
  <name>Task 2: Create manual edit types and form state interface</name>
  <files>src/components/admin/correction/manual/types.ts</files>
  <action>
Create TypeScript types for manual edit state:

1. `ManualEditFieldState` interface:
   - `title: string`
   - `artists: string[]` (array of artist names)
   - `releaseDate: string | null` (partial date string)
   - `releaseType: string | null` (using string since Prisma uses VARCHAR)
   - `musicbrainzId: string | null`
   - `spotifyId: string | null`
   - `discogsId: string | null`

2. `ManualEditValidationErrors` interface:
   - All fields optional string (error message or undefined)

3. `ManualEditDirtyState` interface:
   - Track which fields have been modified from initial values
   - `isDirty: boolean` (any field modified)
   - `dirtyFields: Set<keyof ManualEditFieldState>`

4. Factory function:
   - `createInitialEditState(album: CurrentDataViewAlbum): ManualEditFieldState`
   - Pre-populate from current album data

5. Comparison function:
   - `hasUnsavedChanges(initial: ManualEditFieldState, current: ManualEditFieldState): boolean`
   - Used for unsaved changes warning

Import types from CurrentDataView for album structure compatibility.
</action>
<verify>TypeScript compiles with no errors when importing types</verify>
<done>Types exported and factory function creates correct initial state from album</done>
</task>

<task type="auto">
  <name>Task 3: Extend modal state hook and add mode prop to StepIndicator</name>
  <files>src/hooks/useCorrectionModalState.ts, src/components/admin/correction/StepIndicator.tsx</files>
  <action>
**Extend useCorrectionModalState hook:**

1. Add to ModalState interface:
   - `isManualEditMode: boolean` (distinguishes manual edit from search flow)
   - `manualEditState?: ManualEditFieldState` (persisted edit values)

2. Add new state and setter:
   - `const [isManualEditMode, setIsManualEditModeInternal] = useState(false)`
   - `const [manualEditState, setManualEditStateInternal] = useState<ManualEditFieldState | undefined>()`

3. Add to sessionStorage persistence (load/save with other state)

4. Add new functions to return object:
   - `setManualEditMode: (mode: boolean) => void`
   - `setManualEditState: (state: ManualEditFieldState) => void`
   - `clearManualEditState: () => void`

5. Update step validation:
   - Manual edit mode has 3 steps (Edit, Preview, Apply) vs 4 steps for search mode
   - `isLastStep` should be context-aware based on mode

**Update StepIndicator (mode prop only):**

Add optional `mode` prop to StepIndicator component:

- `mode?: 'search' | 'manual'` (default: 'search')
- Search mode labels: ["Current Data", "Search", "Preview", "Apply"] (4 steps)
- Manual mode labels: ["Current Data", "Edit", "Apply"] (3 steps)

NOTE: This task only adds the mode prop and conditional labels. The actual step flow logic change (which step numbers map to which views) happens in Plan 10-03 when integrating into CorrectionModal.
</action>
<verify>`useCorrectionModalState` returns isManualEditMode and setter functions; StepIndicator renders 3 steps when mode="manual"</verify>
<done>Modal state hook supports manual edit mode flag, StepIndicator accepts mode prop and renders correct labels per mode</done>
</task>

</tasks>

<verification>
1. Run `pnpm type-check` - no TypeScript errors
2. Import validation schemas and verify:
   - Valid UUID "12345678-1234-1234-1234-123456789012" passes musicbrainzIdSchema
   - "abc123" fails musicbrainzIdSchema with UUID error message
   - Valid Spotify ID "0gxyHStUsqpMadRV0Di1Qt" passes spotifyIdSchema
   - "12345" passes discogsIdSchema
   - Any string up to 50 chars passes releaseTypeSchema (e.g., "Album", "EP", "Custom Type")
3. Modal state hook returns new manual edit properties
4. StepIndicator with mode="manual" renders 3 steps with correct labels
</verification>

<success_criteria>

- Zod schemas validate all external ID formats correctly
- releaseTypeSchema accepts any string (matching Prisma VARCHAR(50))
- RELEASE_TYPES constant provides dropdown options
- TypeScript types provide strong typing for form state
- Modal state hook persists manual edit mode in sessionStorage
- StepIndicator can render different step counts and labels based on mode
  </success_criteria>

<output>
After completion, create `.planning/phases/10-manual-edit/10-01-SUMMARY.md`
</output>
