---
phase: 10-manual-edit
plan: 03
type: execute
wave: 3
depends_on: ["10-02"]
files_modified:
  - src/components/admin/correction/manual/ManualEditView.tsx
  - src/components/admin/correction/manual/UnsavedChangesDialog.tsx
  - src/components/admin/correction/manual/computeManualDiffs.ts
  - src/graphql/schema.graphql
  - src/graphql/mutations/manualCorrectionApply.graphql
  - src/lib/graphql/resolvers/mutations.ts
  - src/components/admin/correction/CorrectionModal.tsx
  - src/components/admin/correction/manual/index.ts
autonomous: true

must_haves:
  truths:
    - "Manual Edit tab is accessible from step 1 (Current Data)"
    - "Clicking Manual Edit enters edit mode with pre-populated fields"
    - "Unsaved changes warning appears when switching away with edits"
    - "Preview shows diff between original and edited values"
    - "Apply uses 'manual_correction' as source"
    - "Form validation blocks preview until all fields are valid"
    - "New GraphQL mutation exists for manual edit apply"
  artifacts:
    - path: "src/components/admin/correction/manual/ManualEditView.tsx"
      provides: "Main container for manual edit step"
      exports: ["ManualEditView"]
    - path: "src/components/admin/correction/manual/UnsavedChangesDialog.tsx"
      provides: "Confirmation dialog for discarding edits"
      exports: ["UnsavedChangesDialog"]
    - path: "src/components/admin/correction/manual/computeManualDiffs.ts"
      provides: "Diff computation for manual edits"
      exports: ["computeManualPreview"]
    - path: "src/graphql/schema.graphql"
      provides: "ManualCorrectionApplyInput type"
      contains: "input ManualCorrectionApplyInput"
    - path: "src/graphql/mutations/manualCorrectionApply.graphql"
      provides: "Client mutation for manual apply"
    - path: "src/lib/graphql/resolvers/mutations.ts"
      provides: "manualCorrectionApply resolver"
  key_links:
    - from: "src/components/admin/correction/CorrectionModal.tsx"
      to: "src/components/admin/correction/manual/ManualEditView.tsx"
      via: "renders ManualEditView when in manual mode"
      pattern: "<ManualEditView"
    - from: "src/components/admin/correction/manual/ManualEditView.tsx"
      to: "src/components/admin/correction/manual/validation.ts"
      via: "validates form before preview"
      pattern: "manualEditSchema\\.safeParse"
    - from: "src/components/admin/correction/manual/computeManualDiffs.ts"
      to: "src/lib/correction/preview/types.ts"
      via: "imports CorrectionPreview, TextDiff types"
      pattern: "import.*CorrectionPreview.*from.*types"
---

<objective>
Create the ManualEditView container, new GraphQL mutation for manual apply, and integrate manual edit flow into the CorrectionModal.

Purpose: This is the main deliverable - a working manual edit flow where admin can edit fields inline, preview changes, and apply with "manual_correction" source. A new mutation is needed because the existing correctionApply requires releaseGroupMbid which manual edits don't have.

Output: Complete manual edit workflow integrated into correction modal with dedicated GraphQL mutation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-manual-edit/10-CONTEXT.md
@.planning/phases/10-manual-edit/10-RESEARCH.md
@.planning/phases/10-manual-edit/10-01-SUMMARY.md
@.planning/phases/10-manual-edit/10-02-SUMMARY.md

@src/components/admin/correction/CorrectionModal.tsx
@src/components/admin/correction/apply/ApplyView.tsx
@src/components/admin/correction/preview/PreviewView.tsx
@src/lib/correction/preview/types.ts
@src/graphql/schema.graphql
@src/lib/graphql/resolvers/mutations.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ManualEditView container component</name>
  <files>src/components/admin/correction/manual/ManualEditView.tsx</files>
  <action>
**ManualEditView.tsx** - Main container for manual edit step:

Props interface:
```typescript
interface ManualEditViewProps {
  album: CurrentDataViewAlbum;
  onPreviewClick: (editedState: ManualEditFieldState) => void;
  onCancel: () => void;
  initialState?: ManualEditFieldState; // For resuming edits
}
```

Component structure:

1. **State management:**
   - `const [formState, setFormState] = useState<ManualEditFieldState>(() => initialState ?? createInitialEditState(album))`
   - `const [errors, setErrors] = useState<ManualEditValidationErrors>({})`
   - Track dirty state with `hasUnsavedChanges(initialState, formState)`

2. **Layout sections:**

   a) Header:
   - Title: "Edit Album Data"
   - Subtitle: "Make changes directly, then preview before applying"

   b) Basic Info section:
   - EditableField for title (required)
   - ArtistChipsInput for artists
   - DateInput for releaseDate
   - ReleaseTypeSelect for releaseType

   c) External IDs section (collapsible accordion):
   - ExternalIdInput for musicbrainzId (UUID schema)
   - ExternalIdInput for spotifyId (base62 schema)
   - ExternalIdInput for discogsId (numeric schema)

3. **Validation on preview click:**
   - Validate entire form with manualEditSchema.safeParse
   - **Block preview if validation fails:**
     - Show validation banner at top with summary of errors
     - Show inline errors on each invalid field
     - Do NOT call onPreviewClick
   - **Allow preview only when valid:**
     - All fields pass validation
     - Call onPreviewClick(formState)

4. **Footer:**
   - "Cancel" button (calls onCancel)
   - "Preview Changes" button (primary, disabled if no changes OR if form has validation errors)

Styling:
- Match existing modal dark theme (zinc-900 bg, zinc-100 text)
- Section cards with border-zinc-800
- Use existing Accordion for External IDs section
  </action>
  <verify>Render ManualEditView with album data, all fields pre-populated. Edit title, click Preview - onPreviewClick called with updated state. Clear required field, click Preview - blocked with error.</verify>
  <done>ManualEditView renders with all input components, validates before preview, and blocks preview on validation errors</done>
</task>

<task type="auto">
  <name>Task 2: Create diff computation and UnsavedChangesDialog</name>
  <files>src/components/admin/correction/manual/computeManualDiffs.ts, src/components/admin/correction/manual/UnsavedChangesDialog.tsx</files>
  <action>
**computeManualDiffs.ts** - Construct preview data from manual edits:

Import required types:
```typescript
import type { CorrectionPreview, TextDiff, DateDiff, ArtistDiff } from '@/lib/correction/preview/types';
import type { ManualEditFieldState } from './types';
import type { CurrentDataViewAlbum } from '../CurrentDataView';
```

```typescript
export function computeManualPreview(
  album: CurrentDataViewAlbum,
  editedState: ManualEditFieldState
): CorrectionPreview
```

Logic:
1. Compare each field between album (current) and editedState (source)
2. Generate TextDiff for title if changed:
   ```typescript
   {
     field: 'title',
     changeType: 'MODIFIED',
     currentValue: album.title,
     sourceValue: editedState.title
   }
   ```
3. Generate DateDiff for releaseDate if changed
4. Generate artistDiff comparing album.artists to editedState.artists:
   - Convert string arrays to artist credit format
   - Compare order and names
5. Generate TextDiff for releaseType if changed
6. External IDs: Generate TextDiff for each if changed (musicbrainzId, spotifyId, discogsId)
7. Set sourceResult with:
   - `id: 'manual-edit'` (synthetic ID for manual edits)
   - `releaseGroupMbid: null` (manual edits have no external MBID)
   - `title: editedState.title`
   - Populate other fields from editedState
8. trackDiffs: Empty array (manual edit doesn't change tracks in v1)
9. coverArt: { changeType: 'UNCHANGED' } (no cover change in manual edit)

Return CorrectionPreview structure compatible with existing PreviewView.

**UnsavedChangesDialog.tsx** - Confirmation for discarding edits:

Props interface:
```typescript
interface UnsavedChangesDialogProps {
  open: boolean;
  onConfirm: () => void;
  onCancel: () => void;
}
```

Content:
- Title: "Unsaved Changes"
- Description: "You have unsaved edits. Do you want to discard them?"
- Buttons: "Keep Editing" (secondary), "Discard" (destructive)

Use existing AlertDialog primitives from @/components/ui/alert-dialog.

Add both to index.ts exports.
  </action>
  <verify>computeManualPreview returns valid CorrectionPreview with fieldDiffs for changed fields only. Dialog renders with correct buttons.</verify>
  <done>Diff computation returns valid CorrectionPreview, dialog and utility exported</done>
</task>

<task type="auto">
  <name>Task 3: Create GraphQL mutation and integrate into CorrectionModal</name>
  <files>src/graphql/schema.graphql, src/graphql/mutations/manualCorrectionApply.graphql, src/lib/graphql/resolvers/mutations.ts, src/components/admin/correction/CorrectionModal.tsx, src/components/admin/correction/manual/index.ts</files>
  <action>
**1. Add new GraphQL mutation to schema.graphql:**

```graphql
"""
Input for applying a manual correction (no external MBID required).
"""
input ManualCorrectionApplyInput {
  """Album ID to apply correction to"""
  albumId: UUID!
  """Title to set (required)"""
  title: String!
  """Artist names to set"""
  artists: [String!]!
  """Release date (YYYY, YYYY-MM, or YYYY-MM-DD format)"""
  releaseDate: String
  """Release type (Album, EP, Single, etc.)"""
  releaseType: String
  """MusicBrainz release group UUID"""
  musicbrainzId: String
  """Spotify album ID"""
  spotifyId: String
  """Discogs master/release ID"""
  discogsId: String
  """Expected album updatedAt timestamp for optimistic locking"""
  expectedUpdatedAt: DateTime!
}

# Add to Mutation type:
"""Apply manual corrections to an album (no external source)"""
manualCorrectionApply(input: ManualCorrectionApplyInput!): CorrectionApplyResult!
```

**2. Create client mutation file (src/graphql/mutations/manualCorrectionApply.graphql):**

```graphql
mutation ManualCorrectionApply($input: ManualCorrectionApplyInput!) {
  manualCorrectionApply(input: $input) {
    success
    album {
      id
      title
      releaseDate
      releaseType
      artists {
        id
        name
      }
    }
    error {
      code
      message
    }
  }
}
```

**3. Add resolver to mutations.ts:**

```typescript
manualCorrectionApply: async (_, { input }, { prisma, user }) => {
  // Admin check
  if (!user || user.role !== 'ADMIN') {
    return { success: false, error: { code: 'UNAUTHORIZED', message: 'Admin access required' } };
  }

  // Fetch album with optimistic lock check
  const album = await prisma.album.findUnique({ where: { id: input.albumId } });
  if (!album) {
    return { success: false, error: { code: 'NOT_FOUND', message: 'Album not found' } };
  }
  if (album.updatedAt.toISOString() !== input.expectedUpdatedAt) {
    return { success: false, error: { code: 'STALE_DATA', message: 'Album was modified' } };
  }

  // Parse release date
  const releaseDate = input.releaseDate ? parsePartialDate(input.releaseDate) : null;

  // Update album
  const updated = await prisma.album.update({
    where: { id: input.albumId },
    data: {
      title: input.title,
      releaseDate,
      releaseType: input.releaseType,
      musicbrainzId: input.musicbrainzId,
      spotifyId: input.spotifyId,
      discogsId: input.discogsId,
      // Handle artists via connectOrCreate pattern
    },
    include: { artists: true }
  });

  // Log enrichment with source: 'manual_correction'
  await prisma.enrichmentLog.create({
    data: {
      entityType: 'ALBUM',
      entityId: input.albumId,
      operation: 'manual_correction',
      sources: ['manual'],
      status: 'SUCCESS',
    }
  });

  return { success: true, album: updated };
}
```

**4. Run codegen:** `pnpm codegen` to generate hook

**5. Update CorrectionModal.tsx:**

a) Add manual edit state:
```typescript
const [isManualMode, setIsManualMode] = useState(false);
const [manualEditState, setManualEditState] = useState<ManualEditFieldState | null>(null);
const [showUnsavedDialog, setShowUnsavedDialog] = useState(false);
const [pendingAction, setPendingAction] = useState<(() => void) | null>(null);
```

b) Add "Manual Edit" button to Current Data step (step 0):
- Add button below CurrentDataView: "Edit Manually" with Pencil icon
- On click: setIsManualMode(true), setCurrentStep to 1 (edit step)
- Position: flex row with "Search MusicBrainz" and "Edit Manually" buttons

c) Update step flow for manual mode:
- Pass `mode={isManualMode ? 'manual' : 'search'}` to StepIndicator
- Manual mode: step 1 = ManualEditView, step 2 = Apply
- Search mode: step 1 = SearchView, step 2 = PreviewView, step 3 = ApplyView

d) Render ManualEditView when step 1 and isManualMode:
```tsx
{currentStep === 1 && isManualMode && album && (
  <ManualEditView
    album={album}
    onPreviewClick={handleManualPreview}
    onCancel={handleCancelManualEdit}
    initialState={manualEditState ?? undefined}
  />
)}
```

e) Handle manual preview and apply:
```typescript
const handleManualPreview = (editedState: ManualEditFieldState) => {
  setManualEditState(editedState);
  const preview = computeManualPreview(album!, editedState);
  setPreviewData(preview);
  nextStep(); // Go to Apply step (step 2 in manual mode)
};

const handleManualApply = async () => {
  const { mutateAsync } = useManualCorrectionApplyMutation();
  await mutateAsync({
    input: {
      albumId: album!.id,
      title: manualEditState!.title,
      artists: manualEditState!.artists,
      releaseDate: manualEditState!.releaseDate,
      releaseType: manualEditState!.releaseType,
      musicbrainzId: manualEditState!.musicbrainzId,
      spotifyId: manualEditState!.spotifyId,
      discogsId: manualEditState!.discogsId,
      expectedUpdatedAt: album!.updatedAt,
    }
  });
  // Show success toast, close modal
};
```

f) Unsaved changes guard:
- When switching from manual mode to search or closing modal
- Check hasUnsavedChanges
- If dirty: show UnsavedChangesDialog
- On confirm: proceed with action
- On cancel: stay in edit mode

g) Update footer buttons per mode and step

h) Clear manual state on close/apply success
  </action>
  <verify>Run pnpm codegen, then pnpm type-check. Open modal, click "Edit Manually", edit title, click "Preview Changes" - shows diff. Click Apply - uses new mutation, applies with manual_correction source.</verify>
  <done>Complete manual edit flow works end-to-end with dedicated GraphQL mutation</done>
</task>

</tasks>

<verification>
1. Run `pnpm codegen` - generates useManualCorrectionApplyMutation hook
2. Run `pnpm type-check` - no TypeScript errors
3. Run `pnpm lint` - no linting errors
4. Manual testing flow:
   a. Open correction modal for any album
   b. Click "Edit Manually" button on Current Data step
   c. Edit title, add/remove artist, change release date
   d. Try to preview with invalid field - blocked with errors
   e. Fix validation errors, click "Preview Changes"
   f. Verify diff shows current vs edited values
   g. Click "Apply" - changes applied to database with manual_correction source
5. Test unsaved changes:
   a. Edit a field in manual mode
   b. Try to close modal or switch to search
   c. Verify warning dialog appears
   d. Click "Keep Editing" - stays in edit mode
   e. Click "Discard" - exits without saving
</verification>

<success_criteria>
- "Edit Manually" button visible on Current Data step
- ManualEditView renders with all editable fields
- Form validation blocks preview until all fields valid
- Preview shows correct diff between original and edited values
- New manualCorrectionApply mutation exists and works
- Apply uses "manual_correction" as source in enrichment log
- Unsaved changes warning prevents accidental data loss
- Modal state persists manual edit state in sessionStorage
</success_criteria>

<output>
After completion, create `.planning/phases/10-manual-edit/10-03-SUMMARY.md`
</output>
