---
phase: 04-apply-service
plan: 03
type: execute
wave: 3
depends_on: ['04-01', '04-02']
files_modified:
  - src/lib/correction/apply/apply-service.ts
  - src/lib/correction/apply/data-quality-calculator.ts
  - src/lib/correction/apply/index.ts
autonomous: true

must_haves:
  truths:
    - 'Corrections update Album, AlbumArtist, and Track in one atomic transaction'
    - 'Optimistic locking prevents concurrent modification conflicts'
    - 'Audit log captures before/after deltas for changed fields only'
    - 'Data quality is recalculated after correction'
    - 'Failed transactions leave no partial changes'
  artifacts:
    - path: 'src/lib/correction/apply/apply-service.ts'
      provides: 'ApplyCorrectionService with atomic transaction'
      exports: ['ApplyCorrectionService', 'applyCorrectionService']
    - path: 'src/lib/correction/apply/data-quality-calculator.ts'
      provides: 'Data quality recalculation'
      exports: ['calculateDataQuality', 'DataQualityFactors']
  key_links:
    - from: 'src/lib/correction/apply/apply-service.ts'
      to: 'prisma.$transaction'
      via: 'Interactive transaction with tx client'
      pattern: "prisma\\.\\$transaction\\(async \\(tx\\)"
    - from: 'src/lib/correction/apply/apply-service.ts'
      to: 'prisma.enrichmentLog.create'
      via: 'Audit logging after transaction'
      pattern: "enrichmentLog\\.create"
    - from: 'src/lib/correction/apply/apply-service.ts'
      to: 'src/lib/correction/apply/field-selector.ts'
      via: 'buildAlbumUpdateData, buildTrackUpdateData'
      pattern: 'import.*buildAlbumUpdateData.*field-selector'
---

<objective>
Implement the ApplyCorrectionService with Prisma interactive transactions, audit logging, and data quality updates.

Purpose: This is the core service that atomically applies corrections to the database. It ensures all-or-nothing updates with full audit trail for admin accountability.
Output: apply-service.ts with complete correction application logic, data-quality-calculator.ts for post-correction scoring
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-apply-service/04-CONTEXT.md
@.planning/phases/04-apply-service/04-RESEARCH.md
@.planning/phases/04-apply-service/04-01-SUMMARY.md
@.planning/phases/04-apply-service/04-02-SUMMARY.md
@src/lib/correction/apply/types.ts
@src/lib/correction/apply/field-selector.ts
@src/lib/correction/apply/track-matcher.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement data quality calculator</name>
  <files>src/lib/correction/apply/data-quality-calculator.ts</files>
  <action>
Create data quality calculation for post-correction scoring:

1. **Quality Factors Type**

   ```typescript
   interface DataQualityFactors {
     hasTitle: boolean;
     hasReleaseDate: boolean;
     hasArtists: boolean;
     hasTracks: boolean;
     hasCoverArt: boolean;
     hasMusicbrainzId: boolean;
     hasBarcode: boolean;
     source: 'admin_correction' | 'enrichment' | 'user_submission';
   }
   ```

2. **Calculate Quality Function**

   ```typescript
   function calculateDataQuality(factors: DataQualityFactors): DataQuality;
   ```

   Logic (per CONTEXT.md: admin corrections = HIGH):
   - If source === 'admin_correction': return 'HIGH' (admin-verified = highest confidence)
   - Otherwise, use weighted scoring:
     - Required fields (title, artists): 30 points each = 60 max
     - Important fields (releaseDate, tracks, coverArt): 10 points each = 30 max
     - Bonus fields (musicbrainzId, barcode): 5 points each = 10 max
     - Total: 100 max
     - HIGH: >= 80, MEDIUM: >= 50, LOW: < 50

   Note: For this phase, admin corrections ALWAYS return HIGH. The weighted logic is for future use (Phase 10 manual edits, enrichment).

3. **Helper: Build Factors from Album**

   ```typescript
   function buildQualityFactors(
     album: Album & { tracks: Track[]; artists: AlbumArtist[] },
     source: DataQualityFactors['source']
   ): DataQualityFactors;
   ```

   - Check each field for presence
   - Return factors object
     </action>
     <verify>Run `pnpm type-check` - data-quality-calculator.ts compiles</verify>
     <done>Data quality calculator returns HIGH for admin corrections</done>
     </task>

<task type="auto">
  <name>Task 2: Implement ApplyCorrectionService core</name>
  <files>src/lib/correction/apply/apply-service.ts</files>
  <action>
Create the main ApplyCorrectionService class:

1. **Class Structure**

   ```typescript
   class ApplyCorrectionService {
     private prisma: PrismaClient;

     constructor(prisma?: PrismaClient); // Optional for testing

     async applyCorrection(input: ApplyInput): Promise<ApplyResult>;
   }
   ```

2. **Singleton Pattern** (for Next.js HMR safety)

   ```typescript
   const globalForApply = globalThis as unknown as {
     applyCorrectionService?: ApplyCorrectionService;
   };
   export const applyCorrectionService =
     globalForApply.applyCorrectionService ?? new ApplyCorrectionService();
   if (process.env.NODE_ENV !== 'production')
     globalForApply.applyCorrectionService = applyCorrectionService;
   ```

3. **applyCorrection Method - Pre-Transaction Phase**
   - Validate input (albumId, preview, selections)
   - Fetch current album with tracks and artists (for audit log before-state)
   - Match tracks using matchTracks() from track-matcher
   - Build all update payloads using field-selector functions
   - Prepare artist operations (which to link/unlink)

4. **applyCorrection Method - Transaction Phase**

   ```typescript
   const result = await this.prisma.$transaction(async (tx) => {
     // 1. Optimistic locking check
     const current = await tx.album.findUnique({
       where: { id: albumId },
       select: { updatedAt: true }
     });
     if (current?.updatedAt.getTime() !== input.expectedUpdatedAt.getTime()) {
       throw new StaleDataError('Album was modified. Refresh and retry.');
     }

     // 2. Update album fields
     const updatedAlbum = await tx.album.update({ ... });

     // 3. Update artist associations (delete all, recreate)
     await tx.albumArtist.deleteMany({ where: { albumId } });
     // For each selected artist, upsert Artist then create AlbumArtist

     // 4. Update tracks
     // - Delete orphaned tracks (if selected)
     // - Update modified tracks (if selected)
     // - Create new tracks (always, if track changes selected)

     // 5. Calculate and update data quality

     return { album: updatedAlbum, ... };
   }, {
     timeout: 10000,  // 10s for admin operations
     isolationLevel: Prisma.TransactionIsolationLevel.Serializable
   });
   ```

5. **Error Handling**
   - Catch Prisma errors, map to ApplyError codes
   - P2034 -> TRANSACTION_FAILED
   - P2025 -> ALBUM_NOT_FOUND
   - Custom StaleDataError -> STALE_DATA
     </action>
     <verify>Run `pnpm type-check` - apply-service.ts compiles with no errors</verify>
     <done>ApplyCorrectionService.applyCorrection executes atomic transaction</done>
     </task>

<task type="auto">
  <name>Task 3: Implement audit logging and finalize</name>
  <files>src/lib/correction/apply/apply-service.ts, src/lib/correction/apply/index.ts</files>
  <action>
1. **Add Audit Logging Method**
   ```typescript
   private async logCorrection(
     albumId: string,
     adminUserId: string,
     beforeAlbum: Album & { tracks: Track[], artists: AlbumArtist[] },
     afterAlbum: Album & { tracks: Track[] },
     trackChanges: TrackMatch[],
     artistChanges: { added: string[], removed: string[] },
     selections: FieldSelections
   ): Promise<void>
   ```
   
   Logic:
   - Build AuditLogPayload with only changed fields:
     - metadata: Compare before/after album fields
     - tracks: Log added/modified/removed with deltas
     - artists: Log added/removed with names
     - externalIds: Compare musicbrainzId, spotifyId, discogsId
     - coverArt: Compare coverArtUrl changes
   
   - Create enrichment_logs entry:
     ```typescript
     await this.prisma.enrichmentLog.create({
       data: {
         entityType: 'ALBUM',
         albumId,
         userId: adminUserId,
         operation: 'admin_correction',
         status: 'SUCCESS',
         sources: ['musicbrainz'],
         fieldsEnriched: [...changedFieldNames],
         dataQualityBefore: beforeAlbum.dataQuality,
         dataQualityAfter: 'HIGH',
         metadata: auditPayload,  // JSON with deltas
         triggeredBy: 'admin_ui'
       }
     });
     ```

2. **Integrate Logging into applyCorrection**
   - Call logCorrection AFTER transaction succeeds (not inside transaction)
   - Wrap in try/catch - logging failure should not fail the correction
   - Log warning if audit logging fails

3. **Build AppliedChanges Response**
   - Populate metadata: array of changed field names
   - Populate artists: { added: [...names], removed: [...names] }
   - Populate tracks: { added: count, modified: count, removed: count }
   - Include dataQualityBefore and dataQualityAfter

4. **Update Barrel Export**
   - Export ApplyCorrectionService class
   - Export applyCorrectionService singleton
   - Export calculateDataQuality, buildQualityFactors
   - Export all types from types.ts

5. **Update src/lib/correction/index.ts**
   - Ensure apply module is exported
     </action>
     <verify>Run `pnpm type-check` - entire correction module compiles. Run `pnpm lint` - no lint errors.</verify>
     <done>Complete ApplyCorrectionService with audit logging and data quality updates</done>
     </task>

</tasks>

<verification>
- [ ] `pnpm type-check` passes
- [ ] `pnpm lint` passes
- [ ] ApplyCorrectionService exported from @/lib/correction
- [ ] Transaction uses `tx` client, not global `prisma`
- [ ] Optimistic locking via expectedUpdatedAt is implemented
- [ ] Audit log captures before/after deltas
- [ ] Data quality set to HIGH for admin corrections
- [ ] Error codes mapped correctly (STALE_DATA, ALBUM_NOT_FOUND, TRANSACTION_FAILED)
</verification>

<success_criteria>

1. `applyCorrection(input)` updates Album, AlbumArtist, Track in one atomic transaction
2. Optimistic locking throws STALE_DATA error if album was modified since preview
3. Audit log in enrichment_logs captures all field deltas with before/after values
4. Failed transactions roll back completely - no partial changes
5. Data quality is set to HIGH for all admin corrections
6. Singleton pattern prevents HMR issues in development
   </success_criteria>

<output>
After completion, create `.planning/phases/04-apply-service/04-03-SUMMARY.md`
</output>
