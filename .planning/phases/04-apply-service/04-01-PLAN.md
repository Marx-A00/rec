---
phase: 04-apply-service
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/correction/apply/types.ts
  - src/lib/correction/apply/track-matcher.ts
  - src/lib/correction/apply/index.ts
autonomous: true

must_haves:
  truths:
    - 'Track matching algorithm finds position matches first'
    - 'Track matching falls back to title similarity for reordered tracks'
    - 'Field selection types define five logical groups'
    - 'Apply input captures optimistic locking timestamp'
  artifacts:
    - path: 'src/lib/correction/apply/types.ts'
      provides: 'ApplyCorrection types (FieldSelections, ApplyInput, ApplyResult)'
      exports:
        [
          'FieldSelections',
          'ApplyInput',
          'ApplyResult',
          'ApplyError',
          'CoverArtChoice',
        ]
    - path: 'src/lib/correction/apply/track-matcher.ts'
      provides: 'Track matching strategy with position and similarity'
      exports: ['matchTracks', 'TrackMatch', 'TrackMatchType']
    - path: 'src/lib/correction/apply/index.ts'
      provides: 'Barrel export'
  key_links:
    - from: 'src/lib/correction/apply/types.ts'
      to: 'src/lib/correction/preview/types.ts'
      via: 'imports CorrectionPreview, MBRecording'
      pattern: 'import.*from.*preview/types'
    - from: 'src/lib/correction/apply/track-matcher.ts'
      to: 'fastest-levenshtein'
      via: 'distance function for similarity'
      pattern: 'import.*fastest-levenshtein'
---

<objective>
Define apply correction types and implement track matching strategy.

Purpose: Establish type-safe foundation for selective field updates and atomic corrections. Track matcher enables intelligent merging of MusicBrainz track data with existing database tracks.
Output: types.ts with all apply types, track-matcher.ts with position-first/similarity-fallback algorithm
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-apply-service/04-CONTEXT.md
@.planning/phases/04-apply-service/04-RESEARCH.md
@src/lib/correction/preview/types.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create apply correction types</name>
  <files>src/lib/correction/apply/types.ts</files>
  <action>
Create comprehensive type definitions for the apply correction system:

1. **Field Selection Types**
   - `MetadataSelections`: { title: boolean, releaseDate: boolean, releaseType: boolean, releaseCountry: boolean, barcode: boolean, label: boolean }
   - `ExternalIdSelections`: { musicbrainzId: boolean, spotifyId: boolean, discogsId: boolean }
   - `CoverArtChoice`: 'use_source' | 'keep_current' | 'clear'
   - `FieldSelections`: { metadata: MetadataSelections, artists: Map<string, boolean>, tracks: Map<string, boolean>, externalIds: ExternalIdSelections, coverArt: CoverArtChoice }
   - Include factory function `createDefaultSelections()` that returns all true/selected
   - Include factory `selectAllFromPreview(preview: CorrectionPreview)` that populates track/artist maps

2. **Apply Input/Output Types**
   - `ApplyInput`: { albumId: string, preview: CorrectionPreview, selections: FieldSelections, expectedUpdatedAt: Date, adminUserId: string }
   - `ApplyResult`: { success: true, album: Album, changes: AppliedChanges } | { success: false, error: ApplyError }
   - `AppliedChanges`: { metadata: string[], artists: { added: string[], removed: string[] }, tracks: { added: number, modified: number, removed: number }, externalIds: string[], coverArt: boolean, dataQualityBefore: DataQuality, dataQualityAfter: DataQuality }

3. **Error Types**
   - `ApplyErrorCode`: 'STALE_DATA' | 'ALBUM_NOT_FOUND' | 'TRANSACTION_FAILED' | 'INVALID_SELECTION' | 'VALIDATION_ERROR'
   - `ApplyError`: { code: ApplyErrorCode, message: string, context?: Record<string, unknown> }

4. **Audit Log Types**
   - `FieldDelta`: { field: string, before: unknown, after: unknown }
   - `TrackChangeLog`: { action: 'added' | 'modified' | 'removed', trackTitle: string, position: number, deltas?: FieldDelta[] }
   - `ArtistChangeLog`: { action: 'added' | 'removed', artistName: string, artistMbid?: string }
   - `AuditLogPayload`: { metadata: FieldDelta[], tracks: TrackChangeLog[], artists: ArtistChangeLog[], externalIds: FieldDelta[], coverArt: FieldDelta | null }

Import DataQuality from @prisma/client, CorrectionPreview from preview/types.
</action>
<verify>Run `pnpm type-check` - no TypeScript errors in new file</verify>
<done>types.ts exports all apply types with proper JSDoc documentation</done>
</task>

<task type="auto">
  <name>Task 2: Implement track matching strategy</name>
  <files>src/lib/correction/apply/track-matcher.ts</files>
  <action>
Create track matching algorithm that intelligently pairs database tracks with MusicBrainz tracks:

1. **Install dependency**
   - Run `pnpm add fastest-levenshtein` if not already installed

2. **Track Match Types**
   - `TrackMatchType`: 'POSITION' | 'TITLE_SIMILARITY' | 'NEW' | 'ORPHANED'
   - `TrackMatch`: { dbTrack: Track | null, mbTrack: MBRecording | null, matchType: TrackMatchType, confidence: number, discNumber: number, position: number }

3. **Matching Algorithm**
   - `matchTracks(dbTracks: Track[], mbTracks: MBRecording[]): TrackMatch[]`
   - First pass: Position match (disc + track number exact match)
   - Second pass: Title similarity for unmatched MB tracks (threshold 0.8)
   - Third pass: Mark remaining MB tracks as NEW (no dbTrack)
   - Fourth pass: Mark remaining DB tracks as ORPHANED (no mbTrack, will be deleted)
   - Return all matches sorted by discNumber, then position

4. **Similarity Calculation**
   - `calculateTitleSimilarity(title1: string, title2: string): number`
   - Use `distance` from fastest-levenshtein
   - Normalize: 1 - (distance / max(len1, len2))
   - Normalize titles before comparison (lowercase, trim)

5. **Constants**
   - `SIMILARITY_THRESHOLD = 0.8` - exportable for testing/tuning

Note: MBRecording has `length` for duration in ms, Track has `durationMs`. Handle the property name difference.
</action>
<verify>Run `pnpm type-check` - no errors. Create a quick test in the file comments showing expected behavior.</verify>
<done>track-matcher.ts exports matchTracks function that handles all four match types</done>
</task>

<task type="auto">
  <name>Task 3: Create barrel export and integrate</name>
  <files>src/lib/correction/apply/index.ts, src/lib/correction/index.ts</files>
  <action>
1. Create `src/lib/correction/apply/index.ts`:
   - Export all types from './types'
   - Export matchTracks, TrackMatch, TrackMatchType, SIMILARITY_THRESHOLD from './track-matcher'

2. Update `src/lib/correction/index.ts`:
   - Add: export \* from './apply'
   - Keep existing exports (search-service, types, scoring, preview)
     </action>
     <verify>Run `pnpm type-check` - no errors across correction module</verify>
     <done>Apply module accessible via @/lib/correction import</done>
     </task>

</tasks>

<verification>
- [ ] `pnpm type-check` passes
- [ ] `src/lib/correction/apply/types.ts` exists with all required exports
- [ ] `src/lib/correction/apply/track-matcher.ts` exists with matchTracks function
- [ ] fastest-levenshtein is in package.json dependencies
- [ ] All exports accessible from `@/lib/correction`
</verification>

<success_criteria>

1. All apply types are defined with proper TypeScript types (no `any`)
2. FieldSelections supports five logical groups with per-track/per-artist granularity
3. Track matcher handles all four cases: POSITION match, TITLE_SIMILARITY fallback, NEW tracks, ORPHANED tracks
4. Similarity calculation uses fastest-levenshtein with 0.8 threshold
5. Types integrate with existing CorrectionPreview from Phase 3
   </success_criteria>

<output>
After completion, create `.planning/phases/04-apply-service/04-01-SUMMARY.md`
</output>
