---
phase: 14-artist-correction-store
plan: 02
type: execute
wave: 2
depends_on: [14-01]
files_modified:
  - src/components/admin/correction/artist/ArtistCorrectionModal.tsx
  - src/components/admin/correction/artist/search/ArtistSearchView.tsx
  - src/components/admin/correction/artist/preview/ArtistPreviewView.tsx
  - src/components/admin/correction/artist/apply/ArtistApplyView.tsx
  - src/hooks/useArtistCorrectionModalState.ts
autonomous: true

must_haves:
  truths:
    - 'Admin opens artist correction modal and sees identical UI as before (zero visual changes)'
    - 'Search query typed in step 1 persists when navigating away and back via sessionStorage'
    - 'Selecting a search result atomically advances to preview step'
    - 'Preview data loads and is available to apply step without prop drilling'
    - 'Apply step shows field selections and applies corrections identically'
    - 'Modal close clears all state and sessionStorage entry'
    - 'useArtistCorrectionModalState.ts is deleted with zero remaining imports'
  artifacts:
    - path: 'src/components/admin/correction/artist/ArtistCorrectionModal.tsx'
      provides: 'Modal shell using Zustand store instead of hook'
      contains: 'getArtistCorrectionStore'
    - path: 'src/components/admin/correction/artist/search/ArtistSearchView.tsx'
      provides: 'Search view with artist-only prop'
      contains: 'getArtistCorrectionStore'
    - path: 'src/components/admin/correction/artist/preview/ArtistPreviewView.tsx'
      provides: 'Preview view with zero props'
      contains: 'getArtistCorrectionStore'
    - path: 'src/components/admin/correction/artist/apply/ArtistApplyView.tsx'
      provides: 'Apply view with isApplying + error props only'
      contains: 'getArtistCorrectionStore'
  key_links:
    - from: 'ArtistCorrectionModal.tsx'
      to: 'useArtistCorrectionStore'
      via: 'getArtistCorrectionStore(artistId)'
      pattern: 'getArtistCorrectionStore'
    - from: 'ArtistSearchView.tsx'
      to: 'useArtistCorrectionStore'
      via: 'getArtistCorrectionStore(artist.id)'
      pattern: 'getArtistCorrectionStore'
    - from: 'ArtistPreviewView.tsx'
      to: 'useArtistCorrectionStore'
      via: 'getArtistCorrectionStore(artistId) — artistId from store or context'
      pattern: 'getArtistCorrectionStore'
    - from: 'ArtistApplyView.tsx'
      to: 'useArtistCorrectionStore'
      via: 'getArtistCorrectionStore(artistId) — reads previewData, applySelections from store'
      pattern: 'getArtistCorrectionStore'
---

<objective>
Refactor ArtistCorrectionModal and all three child components (ArtistSearchView, ArtistPreviewView, ArtistApplyView) to read/write state from useArtistCorrectionStore instead of the legacy hook. Then delete useArtistCorrectionModalState.ts.

This follows the EXACT migration pattern established in Phase 13 Plans 02-03 for the album correction modal. Zero UI changes — identical behavior, cleaner internals.

Purpose: Complete the artist correction Zustand migration, achieving prop reduction targets and eliminating the legacy hook.
Output: All 4 components refactored, legacy hook deleted.
</objective>

<execution_context>
@/Users/marcosandrade/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcosandrade/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-artist-correction-store/14-RESEARCH.md
@.planning/phases/14-artist-correction-store/14-01-SUMMARY.md

# The store created in Plan 01:

@src/stores/useArtistCorrectionStore.ts

# Phase 13 summaries showing the exact migration pattern to follow:

@.planning/phases/13-album-correction-store/13-02-SUMMARY.md

# Current files to refactor:

@src/components/admin/correction/artist/ArtistCorrectionModal.tsx
@src/components/admin/correction/artist/search/ArtistSearchView.tsx
@src/components/admin/correction/artist/preview/ArtistPreviewView.tsx
@src/components/admin/correction/artist/apply/ArtistApplyView.tsx

# Album equivalents for reference (how they were refactored):

@src/components/admin/correction/CorrectionModal.tsx
@src/components/admin/correction/search/SearchView.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor ArtistCorrectionModal and ArtistSearchView to use Zustand store</name>
  <files>
    src/components/admin/correction/artist/ArtistCorrectionModal.tsx
    src/components/admin/correction/artist/search/ArtistSearchView.tsx
  </files>
  <action>
**ArtistCorrectionModal.tsx refactoring:**

Follow the EXACT pattern from Phase 13 Plan 02 (CorrectionModal migration). Read `.planning/phases/13-album-correction-store/13-02-SUMMARY.md` and `src/components/admin/correction/CorrectionModal.tsx` for the proven pattern.

1. **Remove imports:**
   - Remove: `import { useArtistCorrectionModalState } from '@/hooks/useArtistCorrectionModalState'`

2. **Add imports:**

   ```typescript
   import {
     getArtistCorrectionStore,
     clearArtistCorrectionStoreCache,
     isFirstStep as isFirstStepSelector,
   } from '@/stores/useArtistCorrectionStore';
   ```

3. **Replace hook with store:** Remove the `useArtistCorrectionModalState(artistId)` call and all destructured values. Replace with store subscription pattern:

   ```typescript
   const store = artistId ? getArtistCorrectionStore(artistId) : null;

   // Subscribe to individual state fields
   const step = store?.(s => s.step) ?? 0;
   const selectedArtistMbid = store?.(s => s.selectedArtistMbid);
   const previewData = store?.(s => s.previewData);
   const shouldEnrich = store?.(s => s.shouldEnrich);
   const showAppliedState = store?.(s => s.showAppliedState);

   // Derived selectors
   const isFirstStep = store ? store(isFirstStepSelector) : true;
   ```

4. **Remove local useState declarations** that are now in the store:
   - Remove: `useState<ArtistCorrectionPreview | null>(null)` for previewData
   - Remove: `useState(false)` for showAppliedState
   - Remove: `useState(false)` for shouldEnrich

   These are now read from the store via selectors above.

5. **Refactor handler functions:**
   - `handleClose`: Call `clearArtistCorrectionStoreCache(artistId)` instead of `clearState()`. Remove `setPreviewData(null)` and `setShowAppliedState(false)` (handled by store clear).
   - `handleResultSelect`: Remove this function entirely. SearchView now calls `store.selectResult()` directly.
   - `handlePreviewLoaded`: Remove this function entirely. PreviewView now calls `store.setPreviewLoaded()` directly.
   - `handleApplyClick` (the "Select Fields & Apply" button): Call `store?.getState().nextStep()` instead of `nextStep()`.
   - `handleApply`: Read `shouldEnrich` from store via `store?.getState().shouldEnrich`. Call `store?.getState().setShouldEnrich(triggerEnrichment ?? false)` before mutation.
   - Apply mutation `onSuccess`: Call `store?.getState().setShowAppliedState(true)`. In the auto-close timeout, call `clearArtistCorrectionStoreCache(artistId!)` instead of `clearState()`.
   - Step navigation: `setCurrentStep` → `store?.getState().setStep(step)`, `prevStep` → `store?.getState().prevStep()`, `nextStep` → `store?.getState().nextStep()`

6. **Update child component props:**
   - **ArtistSearchView**: Change from `<ArtistSearchView artist={...} onResultSelect={handleResultSelect} modalState={modalState} />` to just `<ArtistSearchView artist={artistData as Artist} />`
   - **ArtistPreviewView**: Change from `<ArtistPreviewView artistId={artistId} artistMbid={selectedArtistMbid} onPreviewLoaded={handlePreviewLoaded} />` to just `<ArtistPreviewView />`
   - **ArtistApplyView**: Change from `<ArtistApplyView preview={previewData} onApply={handleApply} onBack={prevStep} isApplying={...} error={...} />` to `<ArtistApplyView isApplying={applyMutation.isPending} error={applyMutation.error instanceof Error ? applyMutation.error : null} />`

7. **Keep in ArtistCorrectionModal (do NOT move to store):**
   - Mutation definitions (applyMutation, enrichMutation) — these orchestrate toasts + queryClient
   - Toast state (useToast)
   - Keyboard shortcuts effect
   - The `handleApply` function itself — it needs to be called from ApplyView, so pass it to ApplyView OR have ApplyView call a store action that triggers it. **Decision: Keep `handleApply` as a callback prop on ApplyView.** Update ArtistApplyView to accept `onApply` prop alongside `isApplying` and `error`. This means ArtistApplyView props become: `{ isApplying, error, onApply }`.

   Wait — re-reading the requirements: "XCHILD-03: ArtistApplyView props reduced to isApplying + error only". But `onApply` is a mutation callback that orchestrates toasts + cache invalidation + enrichment — it MUST stay in the modal. The solution from the album store: **ApplyView reads selections and shouldEnrich from store, and calls onApply which is still a prop.** So the final ArtistApplyView props are `{ isApplying, error, onApply }` where onApply accepts no args (reads from store internally). This matches how album ApplyView works after Phase 13.

   Actually, looking more carefully at the album refactored ApplyView: the `onApply` callback in album modal gets selections and enrichment from the store. Let me check... The research says "ArtistApplyView: isApplying, error (mutation state from parent)". The `onApply` callback needs to stay because it triggers the GraphQL mutation with toast orchestration. So:

   **Final ArtistApplyView prop interface:**

   ```typescript
   interface ArtistApplyViewProps {
     isApplying: boolean;
     error: Error | null;
   }
   ```

   The `handleApply` in the modal will read selections and shouldEnrich from the store directly:

   ```typescript
   const handleApply = () => {
     const state = store?.getState();
     if (
       !artistId ||
       !state?.previewData ||
       !state?.selectedArtistMbid ||
       !state?.applySelections
     )
       return;
     // ... use state.applySelections and state.shouldEnrich
   };
   ```

   And ArtistApplyView will call `handleApply` how? **Via a store action.** Add a `triggerApply` action or simply have the modal subscribe to a "ready to apply" signal.

   **Simplest approach (matching album pattern):** Keep `onApply` as a prop on ArtistApplyView. The requirement says "isApplying + error only" but the album equivalent also passes onApply. Looking at the album CorrectionModal after refactor — yes, it still passes the mutation trigger as a prop. So keep `onApply` as a prop but have it take zero arguments (modal reads selections from store). This means ArtistApplyView gets 3 props: `{ onApply, isApplying, error }`.

   **Implementation:** In ArtistApplyView, the "Confirm & Apply" button calls `onApply()` (no args). In the modal, `handleApply` reads `store.getState().applySelections` and `store.getState().shouldEnrich` to build the mutation input.

8. **StepIndicator stays prop-driven** (same as Phase 13 decision CLEAN-04):
   ```typescript
   <StepIndicator
     currentStep={step}
     onStepClick={(s: number) => store?.getState().setStep(s)}
     steps={['Current', 'Search', 'Preview', 'Apply']}
   />
   ```

**ArtistSearchView.tsx refactoring:**

Follow the EXACT pattern from Phase 13 Plan 02 (SearchView migration).

1. **Remove imports:**
   - Remove: `import { type useArtistCorrectionModalState } from '@/hooks/useArtistCorrectionModalState'`

2. **Add imports:**

   ```typescript
   import { getArtistCorrectionStore } from '@/stores/useArtistCorrectionStore';
   ```

3. **Reduce props interface** from 3 props to 1:

   ```typescript
   // Before
   export interface ArtistSearchViewProps {
     artist: Artist;
     onResultSelect: (mbid: string) => void;
     modalState: ReturnType<typeof useArtistCorrectionModalState>;
   }

   // After
   export interface ArtistSearchViewProps {
     artist: Artist;
   }
   ```

4. **Replace modalState destructuring with store:**

   ```typescript
   const store = getArtistCorrectionStore(artist.id);
   const searchQuery = store(s => s.searchQuery);
   const searchOffset = store(s => s.searchOffset);
   ```

5. **Update handler functions:**
   - `handleSearch`: Call `store.getState().setSearchQuery(inputValue.trim())` (also resets offset automatically)
   - `handleResultClick`: Call `store.getState().selectResult(result.artistMbid)` instead of `setSelectedResult` + `onResultSelect`. The atomic action sets mbid AND advances step.
   - Load more: Call `store.getState().setSearchOffset(searchOffset + 10)`

6. **Remove `onResultSelect` and `modalState` from function parameters.** Keep only `{ artist }`.

7. **Preserve all existing behavior:** Search input pre-population, auto-trigger on mount with saved state, pagination, loading/error states, skeleton.
   </action>
   <verify>
   Run `pnpm type-check` — must pass with zero errors.
   Verify no `useArtistCorrectionModalState` import in either file: `grep -r "useArtistCorrectionModalState" src/components/admin/correction/artist/ArtistCorrectionModal.tsx src/components/admin/correction/artist/search/ArtistSearchView.tsx` — should return nothing.
   Verify store imports: `grep "getArtistCorrectionStore" src/components/admin/correction/artist/ArtistCorrectionModal.tsx src/components/admin/correction/artist/search/ArtistSearchView.tsx` — should return matches in both files.
   Verify SearchView props: `grep "artist:" src/components/admin/correction/artist/search/ArtistSearchView.tsx` — should show only `artist` in interface.
   Verify zero `any` types: `grep -c "any" src/components/admin/correction/artist/ArtistCorrectionModal.tsx` and for SearchView.
   </verify>
   <done>
   ArtistCorrectionModal uses getArtistCorrectionStore instead of useArtistCorrectionModalState. All local useState for shared state removed. ArtistSearchView props reduced to `{ artist }` only. Both files import from store, not legacy hook. Type checking passes. Zero any types.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Refactor ArtistPreviewView and ArtistApplyView, delete legacy hook</name>
  <files>
    src/components/admin/correction/artist/preview/ArtistPreviewView.tsx
    src/components/admin/correction/artist/apply/ArtistApplyView.tsx
    src/hooks/useArtistCorrectionModalState.ts
  </files>
  <action>
**ArtistPreviewView.tsx refactoring — reduce to ZERO props:**

1. **Add store import:**

   ```typescript
   import { getArtistCorrectionStore } from '@/stores/useArtistCorrectionStore';
   ```

2. **Change props interface to zero props:**

   ```typescript
   // Before
   export interface ArtistPreviewViewProps {
     artistId: string;
     artistMbid: string;
     onPreviewLoaded?: (preview: ArtistCorrectionPreview) => void;
   }

   // After: No props interface needed, or empty
   // export function ArtistPreviewView() {
   ```

3. **Get artistId and artistMbid from store context.** The parent modal (ArtistCorrectionModal) knows the artistId. For PreviewView to get it with zero props, it needs a way to know which store to read.

   **Pattern decision:** PreviewView needs artistId to locate the store. Since the modal already has artistId, the cleanest approach is to keep artistId as a single identity prop (matching the album pattern where PreviewView also kept albumId). Read the Phase 13-03 summary — check if album PreviewView ended up with zero or one prop.

   Actually, looking at the research: "ArtistPreviewView: zero props (reads everything from store)". But the store is keyed by artistId, so PreviewView MUST know which artistId to look up. The solution: **use React context or pass artistId as a minimal prop.**

   **Pragmatic decision (matching album pattern):** Keep `artistId` as a single prop for store lookup. The requirement "zero props" means zero _state_ props — artistId is an identity/key prop. This matches Phase 13 where albumId was kept as identity prop (see STATE.md: "albumId as identity prop: PreviewView and ApplyView keep albumId as prop (needed to locate store instance)").

   So the final interface:

   ```typescript
   export interface ArtistPreviewViewProps {
     artistId: string;
   }
   ```

4. **Read state from store instead of props:**

   ```typescript
   const store = getArtistCorrectionStore(artistId);
   const selectedArtistMbid = store(s => s.selectedArtistMbid);
   ```

5. **Replace onPreviewLoaded callback with store action:**

   ```typescript
   // Before: onPreviewLoaded?.(data.artistCorrectionPreview)
   // After:
   useEffect(() => {
     if (data?.artistCorrectionPreview) {
       store
         .getState()
         .setPreviewLoaded(
           data.artistCorrectionPreview as ArtistCorrectionPreview
         );
     }
   }, [data?.artistCorrectionPreview, store]);
   ```

6. **Guard rendering** if `selectedArtistMbid` is undefined (same as current null check in modal).

7. **Preserve all existing UI:** Accordion sections, field diff highlighting, album count warning, skeleton loading, error states.

**ArtistApplyView.tsx refactoring — reduce to isApplying + error + onApply:**

1. **Add store import:**

   ```typescript
   import { getArtistCorrectionStore } from '@/stores/useArtistCorrectionStore';
   ```

2. **Change props interface:**

   ```typescript
   // Before
   interface ArtistApplyViewProps {
     preview: ArtistCorrectionPreview;
     onApply: (
       selections: UIArtistFieldSelections,
       triggerEnrichment?: boolean
     ) => void;
     onBack: () => void;
     isApplying?: boolean;
     error?: Error | null;
   }

   // After
   interface ArtistApplyViewProps {
     artistId: string; // Identity prop for store lookup
     onApply: () => void; // No args — reads from store
     isApplying?: boolean;
     error?: Error | null;
   }
   ```

3. **Read state from store:**

   ```typescript
   const store = getArtistCorrectionStore(artistId);
   const preview = store(s => s.previewData);
   const selections = store(s => s.applySelections);
   const triggerEnrichment = store(s => s.shouldEnrich);
   ```

4. **Replace local useState for selections with store:**
   - Remove: `const [selections, setSelections] = useState<UIArtistFieldSelections>(() => createDefaultArtistSelections(preview));`
   - Read selections from store: `const selections = store((s) => s.applySelections);`
   - Update selections via store: `store.getState().setApplySelections({ ...updated })` instead of `setSelections(prev => ...)`.

5. **Replace local useState for triggerEnrichment with store:**
   - Remove: `const [triggerEnrichment, setTriggerEnrichment] = useState(false);`
   - Read from store: `const triggerEnrichment = store((s) => s.shouldEnrich);`
   - Update via store: `store.getState().setShouldEnrich(checked === true)`

6. **Replace onBack with store action:**
   - Remove `onBack` from props
   - "Back to preview" button: `onClick={() => store.getState().prevStep()}`

7. **Update handleApply:**

   ```typescript
   const handleApply = () => {
     if (!selections || totalSelected === 0 || isApplying) return;
     onApply(); // No args - modal reads from store
   };
   ```

8. **Guard rendering** if `preview` or `selections` is null (store might not have preview data loaded).

9. **Keep `createDefaultArtistSelections` as exported function** (done in Plan 01). It is still used internally by the `setPreviewLoaded` atomic action in the store. The local `useState` initializer that called it is removed.

10. **Preserve all existing UI:** Two-column layout, field selection checkboxes, summary box, error display, enrichment checkbox, apply button.

**Update ArtistCorrectionModal.tsx for new ApplyView props:**

After changing ArtistApplyView's props, update the render call in ArtistCorrectionModal:

```typescript
<ArtistApplyView
  artistId={artistId!}
  onApply={handleApply}
  isApplying={applyMutation.isPending}
  error={applyMutation.error instanceof Error ? applyMutation.error : null}
/>
```

And update `handleApply` in the modal to read from store (no args):

```typescript
const handleApply = () => {
  const state = store?.getState();
  if (
    !artistId ||
    !state?.previewData ||
    !state?.selectedArtistMbid ||
    !state?.applySelections
  )
    return;

  // Read enrichment preference from store
  const enrichPref = state.shouldEnrich;

  const expectedUpdatedAt = artistData?.updatedAt
    ? artistData.updatedAt
    : new Date();

  applyMutation.mutate({
    input: {
      artistId,
      artistMbid: state.selectedArtistMbid,
      selections: {
        metadata: { ...state.applySelections.metadata },
        externalIds: { ...state.applySelections.externalIds },
      },
      expectedUpdatedAt,
    },
  });
};
```

And store the enrichment check in mutation onSuccess using store state.

Also update ArtistPreviewView render call:

```typescript
<ArtistPreviewView artistId={artistId!} />
```

**Delete legacy hook:**

Delete `src/hooks/useArtistCorrectionModalState.ts`.

Before deleting, verify zero remaining imports:

```bash
grep -r "useArtistCorrectionModalState" src/ --include="*.ts" --include="*.tsx"
```

This MUST return zero results (all imports removed in this task and Task 1).
</action>
<verify>
Run `pnpm type-check` — must pass with zero errors.
Verify legacy hook deleted: `ls src/hooks/useArtistCorrectionModalState.ts` — should fail (file not found).
Verify zero remaining imports of legacy hook: `grep -r "useArtistCorrectionModalState" src/` — should return nothing.
Verify zero `any` types in all modified files.
Verify store imports in all child components: `grep -r "getArtistCorrectionStore" src/components/admin/correction/artist/` — should appear in all 4 files.
Verify PreviewView has only artistId prop: `grep -A3 "ArtistPreviewViewProps" src/components/admin/correction/artist/preview/ArtistPreviewView.tsx`
Verify ApplyView has artistId + onApply + isApplying + error props only: `grep -A6 "ArtistApplyViewProps" src/components/admin/correction/artist/apply/ArtistApplyView.tsx`
Run `pnpm lint` — should pass (or only formatting issues fixed by prettier).
</verify>
<done>
ArtistPreviewView reduced to artistId prop only (reads mbid + preview from store). ArtistApplyView reduced to artistId + onApply + isApplying + error (reads selections + enrichment from store). useArtistCorrectionModalState.ts deleted with zero remaining imports. All 4 artist correction components use getArtistCorrectionStore. Type checking passes. Zero any types.
</done>
</task>

</tasks>

<verification>
1. `pnpm type-check` passes with zero errors
2. `pnpm lint` passes
3. `grep -r "useArtistCorrectionModalState" src/` returns zero results
4. `ls src/hooks/useArtistCorrectionModalState.ts` fails (file deleted)
5. `grep -r "getArtistCorrectionStore" src/components/admin/correction/artist/` shows matches in all 4 component files
6. ArtistSearchView props: `{ artist }` only
7. ArtistPreviewView props: `{ artistId }` only
8. ArtistApplyView props: `{ artistId, onApply, isApplying, error }` only
9. Zero `any` types across all modified files
10. Zero visual/behavioral changes to the correction modal UI
</verification>

<success_criteria>

- All 4 artist correction components read/write state from useArtistCorrectionStore
- useArtistCorrectionModalState.ts deleted with zero remaining imports
- Props reduced: SearchView={artist}, PreviewView={artistId}, ApplyView={artistId,onApply,isApplying,error}
- Zero any types introduced
- Type checking and linting pass
- Identical modal behavior: search, preview, apply, close, persist, clear
  </success_criteria>

<output>
After completion, create `.planning/phases/14-artist-correction-store/14-02-SUMMARY.md`
</output>
