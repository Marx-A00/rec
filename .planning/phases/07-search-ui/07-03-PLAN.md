---
phase: 07-search-ui
plan: 03
type: execute
wave: 2
depends_on: ['07-01', '07-02']
files_modified:
  - src/components/admin/correction/search/SearchView.tsx
  - src/components/admin/correction/search/index.ts
  - src/components/admin/correction/CorrectionModal.tsx
  - src/hooks/useCorrectionModalState.ts
autonomous: false

must_haves:
  truths:
    - 'Search step displays SearchView in modal when step=1'
    - 'Search inputs pre-populate with current album title and artist'
    - 'Search executes via GraphQL when user submits'
    - 'Loading state shows skeleton during search'
    - 'Results appear after search completes'
    - 'Clicking result stores selection and navigates to preview step'
    - 'Search state persists when navigating back from preview'
  artifacts:
    - path: 'src/components/admin/correction/search/SearchView.tsx'
      provides: 'Main search step container wiring inputs, results, and state'
      exports: ['SearchView']
    - path: 'src/hooks/useCorrectionModalState.ts'
      provides: 'Extended modal state with search query and selected result'
      contains: 'searchQuery'
  key_links:
    - from: 'SearchView'
      to: 'useSearchCorrectionCandidatesQuery'
      via: 'GraphQL hook'
      pattern: 'useSearchCorrectionCandidatesQuery'
    - from: 'SearchView'
      to: 'useCorrectionModalState'
      via: 'state persistence'
      pattern: 'setSearchQuery|setSelectedResult'
    - from: 'CorrectionModal'
      to: 'SearchView'
      via: 'step=1 conditional'
      pattern: 'currentStep === 1.*SearchView'
---

<objective>
Wire search components into the correction modal with GraphQL integration and state persistence.

Purpose: Connect the search UI to the backend search service via GraphQL. Admin submits search, sees results, clicks one to proceed to preview. Search state persists when navigating back from preview step.

Output: SearchView wiring all pieces, modal integration, state persistence
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-search-ui/07-CONTEXT.md
@.planning/phases/07-search-ui/07-RESEARCH.md

@.planning/phases/07-search-ui/07-01-SUMMARY.md
@.planning/phases/07-search-ui/07-02-SUMMARY.md

@src/components/admin/correction/CorrectionModal.tsx
@src/hooks/useCorrectionModalState.ts
@src/graphql/queries/correctionSearch.graphql
@src/generated/graphql.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend useCorrectionModalState for search persistence</name>
  <files>
    src/hooks/useCorrectionModalState.ts
  </files>
  <action>
Extend ModalState interface and hook to persist search state:

1. Update ModalState interface:

```typescript
export interface ModalState {
  currentStep: number;
  searchQuery?: {
    albumTitle: string;
    artistName: string;
  };
  searchOffset?: number;
  selectedResultMbid?: string;
}
```

2. Add state and setters for search fields:
   - searchQuery state (initialized from sessionStorage or undefined)
   - searchOffset state (initialized from sessionStorage or 0)
   - selectedResultMbid state (for tracking which result was clicked)

3. Add new callbacks:
   - setSearchQuery: (query: { albumTitle: string; artistName: string }) => void
   - setSearchOffset: (offset: number) => void
   - setSelectedResult: (mbid: string) => void
   - clearSearchState: () => void (clears search query, offset, selection)

4. Update sessionStorage persistence:
   - Save searchQuery, searchOffset, selectedResultMbid with currentStep
   - Load them when albumId changes

5. Preserve return object structure:
   - Add new values and callbacks to return object
   - Maintain backward compatibility with existing callers

Key decisions from CONTEXT.md:

- Search state preserved when navigating back from preview
- Scroll position preservation (browser handles, we store offset)
  </action>
  <verify>
  pnpm type-check passes
  Hook exports new search state properties
  </verify>
  <done>
  useCorrectionModalState persists searchQuery, searchOffset, selectedResultMbid in sessionStorage
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create SearchView container with GraphQL integration</name>
  <files>
    src/components/admin/correction/search/SearchView.tsx
    src/components/admin/correction/search/index.ts
  </files>
  <action>
Create SearchView.tsx:

1. Props interface:

```typescript
interface SearchViewProps {
  album: CurrentDataViewAlbum;
  onResultSelect: (result: ScoredSearchResult) => void;
  onManualEdit: () => void;
  modalState: ReturnType<typeof useCorrectionModalState>;
}
```

2. Extract initial values from album:
   - albumTitle: album.title
   - artistName: album.artists[0]?.artist.name ?? ''

3. Search state management:
   - Use modalState.searchQuery for persisted query (fallback to album data)
   - Use modalState.searchOffset for pagination offset
   - Track isSearchTriggered: boolean (only true after first search submission)

4. GraphQL query using generated hook:

```typescript
const { data, isLoading, error } = useSearchCorrectionCandidatesQuery(
  {
    input: {
      albumTitle: searchQuery.albumTitle,
      artistName: searchQuery.artistName,
      limit: 10,
      offset: searchOffset,
    },
  },
  {
    enabled:
      isSearchTriggered && !!(searchQuery.albumTitle || searchQuery.artistName),
  }
);

// Extract results from GraphQL response
const results = data?.correctionSearch?.results ?? [];
const hasMore = data?.correctionSearch?.hasMore ?? false;
```

5. Event handlers:
   - handleSearch: Set searchQuery via modalState, set isSearchTriggered=true, reset offset to 0
   - handleLoadMore: Increment offset via modalState
   - handleResultClick: Call onResultSelect, store selected MBID in modalState

6. Render logic:
   - If isLoading && isSearchTriggered: render SearchSkeleton
   - If error: render error message
   - Otherwise: render SearchInputs + (results.length > 0 ? SearchResults : initial prompt)

7. Pass extracted data to SearchResults:

```tsx
<SearchResults
  results={results}
  hasMore={hasMore}
  isLoadingMore={isLoading && searchOffset > 0}
  onResultClick={handleResultClick}
  onLoadMore={handleLoadMore}
  onManualEdit={onManualEdit}
/>
```

8. Initial state (before first search):
   - Show SearchInputs pre-populated
   - Show message: "Search MusicBrainz for the correct album data"
   - Auto-trigger search on mount if searchQuery exists in state (returning from preview)

Update index.ts to export SearchView

Key decisions from CONTEXT.md:

- Inputs always visible at top (but skeleton replaces during loading per CONTEXT)
- Actually CONTEXT says "Full loading state - skeleton replaces search area"
- So on loading: show SearchSkeleton (hides inputs too)
- Results scroll below inputs
  </action>
  <verify>
  pnpm type-check passes
  SearchView exports correctly
  </verify>
  <done>
  SearchView wires SearchInputs, SearchResults, GraphQL query with proper response extraction, and modal state persistence
  </done>
  </task>

<task type="auto">
  <name>Task 3: Integrate SearchView into CorrectionModal</name>
  <files>
    src/components/admin/correction/CorrectionModal.tsx
  </files>
  <action>
Update CorrectionModal.tsx to render SearchView at step 1:

1. Import SearchView from './search'

2. Pass modal state hook to SearchView:
   - Already have modalState from useCorrectionModalState(albumId)

3. Create handleResultSelect callback:

```typescript
const handleResultSelect = (result: ScoredSearchResult) => {
  // Store selected result MBID for preview step
  modalState.setSelectedResult(result.releaseGroupMbid);
  // Navigate to preview step
  nextStep();
};
```

4. Create handleManualEdit callback:

```typescript
const handleManualEdit = () => {
  // Navigate to manual edit (step 3 in future, for now just log)
  console.log('Manual edit requested - Phase 10');
};
```

5. Replace step 1 placeholder with SearchView using explicit conditional guards:

```tsx
{
  /* Step 1: Search */
}
{
  currentStep === 1 && !isLoading && !hasError && album && (
    <SearchView
      album={album}
      onResultSelect={handleResultSelect}
      onManualEdit={handleManualEdit}
      modalState={modalState}
    />
  );
}

{
  /* Show loading state for step 1 if album not ready */
}
{
  currentStep === 1 && isLoading && (
    <div className='flex items-center justify-center p-8'>
      <Loader2 className='h-6 w-6 animate-spin text-zinc-400' />
    </div>
  );
}

{
  /* Show error state for step 1 if album fetch failed */
}
{
  currentStep === 1 && hasError && (
    <div className='p-4 text-center text-red-400'>
      Failed to load album data. Please try again.
    </div>
  );
}
```

6. Update modalState destructuring to include new properties:

```typescript
const modalState = useCorrectionModalState(albumId);
const {
  currentStep,
  setCurrentStep,
  nextStep,
  prevStep,
  clearState,
  isFirstStep,
  isLastStep,
} = modalState;
```

7. Ensure isLoading and hasError are derived from album query state:
   - isLoading: album data is being fetched
   - hasError: album query returned error
     </action>
     <verify>
     pnpm type-check passes
     Modal renders SearchView at step 1 with proper guards
     </verify>
     <done>
     CorrectionModal renders SearchView at step 1 with explicit loading/error guards, result selection navigates to preview step
     </done>
     </task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete search UI integration in correction modal</what-built>
  <how-to-verify>
1. Start dev server: pnpm dev
2. Navigate to /admin/music-database
3. Click wrench icon on any album row
4. Modal opens at Step 0 (Current Data)
5. Click "Next" to go to Step 1 (Search)
6. Verify:
   - Two input fields appear pre-populated with album title and artist
   - Click Search button
   - Loading skeleton appears briefly
   - Results list appears with:
     - Album thumbnails (48px)
     - Title with "XX% match" score
     - Artist and year
     - Release type (Album, EP, etc.)
     - [MB] badge on each row
   - Hover over results shows subtle background change
   - Click a result
   - Step advances to 2 (Preview placeholder)
7. Click Back or Step 1 indicator
8. Verify search results are still there (state preserved)
9. Try search with no results (gibberish query)
10. Verify "No results found" message with Manual Edit link appears
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
- pnpm type-check passes
- pnpm lint passes
- Modal displays SearchView at step 1
- Search executes via GraphQL
- Results display with all metadata (no track count - that comes in Preview phase)
- State persists when navigating back from preview
</verification>

<success_criteria>

1. Search inputs pre-populate with current album data
2. Search button triggers GraphQL query
3. Loading skeleton shows during search
4. Results display with all required metadata (title, artist, year, type, score, [MB] badge)
5. Clicking result stores selection and advances to preview step
6. Returning to search step preserves results
7. No results state shows Manual Edit option
   </success_criteria>

<output>
After completion, create `.planning/phases/07-search-ui/07-03-SUMMARY.md`
</output>
