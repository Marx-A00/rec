---
phase: 05-graphql-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/graphql/schema.graphql
autonomous: true

must_haves:
  truths:
    - "GraphQL schema includes all correction types (search, preview, apply)"
    - "Input types are defined for all operations"
    - "Query and Mutation roots include correction operations"
  artifacts:
    - path: "src/graphql/schema.graphql"
      provides: "Correction types, enums, inputs, and operations"
      contains: "CorrectionSearchInput"
  key_links:
    - from: "schema correction types"
      to: "src/lib/correction/types.ts"
      via: "type mapping"
      pattern: "type Correction"
---

<objective>
Add GraphQL schema definitions for the correction system

Purpose: Enable typed GraphQL operations for admin album correction workflow
Output: Schema types, inputs, enums, queries, and mutation definitions
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-graphql-integration/05-CONTEXT.md
@.planning/phases/05-graphql-integration/05-RESEARCH.md

@src/lib/correction/types.ts
@src/lib/correction/preview/types.ts
@src/lib/correction/apply/types.ts
@src/lib/correction/scoring/types.ts
@src/graphql/schema.graphql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add correction enums and scalar types</name>
  <files>src/graphql/schema.graphql</files>
  <action>
Add the following GraphQL enums after existing enums section (find alphabetical position):

1. `ChangeType` enum with values: ADDED, MODIFIED, REMOVED, CONFLICT, UNCHANGED
   - Maps to ChangeType from preview/types.ts
   
2. `CoverArtChoice` enum with values: USE_SOURCE, KEEP_CURRENT, CLEAR
   - Maps to CoverArtChoice from apply/types.ts

3. `ScoringStrategy` enum with values: NORMALIZED, TIERED, WEIGHTED
   - Maps to ScoringStrategy from scoring/types.ts (lowercase to UPPERCASE)

4. `ConfidenceTier` enum with values: HIGH, MEDIUM, LOW, NONE
   - Maps to ConfidenceTier from scoring/types.ts

5. `ApplyErrorCode` enum with values: STALE_DATA, ALBUM_NOT_FOUND, TRANSACTION_FAILED, INVALID_SELECTION, VALIDATION_ERROR
   - Maps to ApplyErrorCode from apply/types.ts

Follow existing schema organization (enums grouped together).
  </action>
  <verify>Schema parses without syntax errors: Run `pnpm codegen` and check for parse errors only</verify>
  <done>All five enums exist in schema.graphql in correct alphabetical position</done>
</task>

<task type="auto">
  <name>Task 2: Add correction types (search results, preview, apply)</name>
  <files>src/graphql/schema.graphql</files>
  <action>
Add the following GraphQL types in appropriate sections:

**Search Result Types:**
```graphql
type CorrectionArtistCredit {
  mbid: String!
  name: String!
}

type ScoreBreakdown {
  titleScore: Float!
  artistScore: Float!
  yearScore: Float!
  confidenceTier: ConfidenceTier
}

type ScoredSearchResult {
  releaseGroupMbid: String!
  title: String!
  disambiguation: String
  artistCredits: [CorrectionArtistCredit!]!
  primaryArtistName: String!
  firstReleaseDate: String
  primaryType: String
  secondaryTypes: [String!]
  mbScore: Int!
  coverArtUrl: String
  source: String!
  normalizedScore: Float!
  displayScore: Float!
  breakdown: ScoreBreakdown!
  isLowConfidence: Boolean!
  scoringStrategy: ScoringStrategy!
}

type GroupedSearchResult {
  releaseGroupMbid: String!
  primaryResult: ScoredSearchResult!
  alternateVersions: [ScoredSearchResult!]!
  versionCount: Int!
  bestScore: Float!
}

type CorrectionSearchQuery {
  albumTitle: String
  artistName: String
  yearFilter: Int
}

type CorrectionScoringMeta {
  strategy: ScoringStrategy!
  threshold: Float!
  lowConfidenceCount: Int!
}

type CorrectionSearchResponse {
  results: [GroupedSearchResult!]!
  totalGroups: Int!
  hasMore: Boolean!
  query: CorrectionSearchQuery!
  scoring: CorrectionScoringMeta!
}
```

**Preview Types:**
```graphql
type TextDiffPart {
  value: String!
  added: Boolean
  removed: Boolean
}

type TextDiff {
  field: String!
  changeType: ChangeType!
  currentValue: String
  sourceValue: String
  parts: [TextDiffPart!]
}

type DateComponents {
  year: Int
  month: Int
  day: Int
}

type ComponentChanges {
  year: ChangeType!
  month: ChangeType!
  day: ChangeType!
}

type DateDiff {
  field: String!
  changeType: ChangeType!
  current: DateComponents
  source: DateComponents
  componentChanges: ComponentChanges!
}

type ArrayDiff {
  field: String!
  changeType: ChangeType!
  currentItems: [String!]!
  sourceItems: [String!]!
  added: [String!]!
  removed: [String!]!
  unchanged: [String!]!
}

type ExternalIdDiff {
  field: String!
  changeType: ChangeType!
  currentValue: String
  sourceValue: String
}

type TrackDiff {
  position: Int!
  discNumber: Int!
  changeType: ChangeType!
  currentTitle: String
  currentDurationMs: Int
  sourceTitle: String
  sourceDurationMs: Int
  sourceMbid: String
  titleDiff: [TextDiffPart!]
  durationDelta: Int
}

type TrackListSummary {
  totalCurrent: Int!
  totalSource: Int!
  matching: Int!
  modified: Int!
  added: Int!
  removed: Int!
}

type ArtistCreditDiff {
  changeType: ChangeType!
  current: [CorrectionArtistCredit!]!
  source: [CorrectionArtistCredit!]!
  currentDisplay: String!
  sourceDisplay: String!
  nameDiff: [TextDiffPart!]
}

type CoverArtDiff {
  currentUrl: String
  sourceUrl: String
  changeType: ChangeType!
}

type PreviewSummary {
  totalFields: Int!
  changedFields: Int!
  addedFields: Int!
  modifiedFields: Int!
  conflictFields: Int!
  hasTrackChanges: Boolean!
}

type MBRecording {
  id: String!
  title: String!
  length: Int
  position: Int!
}

type MBMediumTrack {
  position: Int!
  recording: MBRecording!
}

type MBMedium {
  position: Int!
  format: String
  trackCount: Int!
  tracks: [MBMediumTrack!]!
}

type MBArtist {
  id: String!
  name: String!
  sortName: String
  disambiguation: String
}

type MBArtistCredit {
  name: String!
  joinphrase: String
  artist: MBArtist!
}

type MBReleaseData {
  id: String!
  title: String!
  date: String
  country: String
  barcode: String
  media: [MBMedium!]!
  artistCredit: [MBArtistCredit!]!
}

type CorrectionPreview {
  currentAlbum: Album!
  sourceResult: ScoredSearchResult!
  mbReleaseData: MBReleaseData
  fieldDiffs: [JSON!]!
  artistDiff: ArtistCreditDiff!
  trackDiffs: [TrackDiff!]!
  trackSummary: TrackListSummary!
  coverArt: CoverArtDiff!
  summary: PreviewSummary!
}
```

**Apply Types:**
```graphql
type AppliedArtistChanges {
  added: [String!]!
  removed: [String!]!
}

type AppliedTrackChanges {
  added: Int!
  modified: Int!
  removed: Int!
}

type AppliedChanges {
  metadata: [String!]!
  artists: AppliedArtistChanges!
  tracks: AppliedTrackChanges!
  externalIds: [String!]!
  coverArt: Boolean!
  dataQualityBefore: DataQuality!
  dataQualityAfter: DataQuality!
}

type CorrectionApplySuccess {
  success: Boolean!
  album: Album!
  changes: AppliedChanges!
}

type CorrectionApplyError {
  code: ApplyErrorCode!
  message: String!
}

type CorrectionApplyResult {
  success: Boolean!
  album: Album
  changes: AppliedChanges
  error: CorrectionApplyError
}
```

Note: Use JSON scalar for fieldDiffs (union of TextDiff|DateDiff|ArrayDiff|ExternalIdDiff is complex - simplify for v1).
  </action>
  <verify>Run `pnpm codegen` - should parse without errors</verify>
  <done>All correction output types exist in schema</done>
</task>

<task type="auto">
  <name>Task 3: Add input types and Query/Mutation roots</name>
  <files>src/graphql/schema.graphql</files>
  <action>
Add input types in the inputs section (alphabetically):

```graphql
input CorrectionSearchInput {
  albumTitle: String
  artistName: String
  yearFilter: Int
  limit: Int
  offset: Int
  strategy: ScoringStrategy
  lowConfidenceThreshold: Float
}

input CorrectionPreviewInput {
  albumId: UUID!
  releaseGroupMbid: String!
}

input MetadataSelectionsInput {
  title: Boolean!
  releaseDate: Boolean!
  releaseType: Boolean!
  releaseCountry: Boolean!
  barcode: Boolean!
  label: Boolean!
}

input ExternalIdSelectionsInput {
  musicbrainzId: Boolean!
  spotifyId: Boolean!
  discogsId: Boolean!
}

input SelectionEntry {
  key: String!
  selected: Boolean!
}

input FieldSelectionsInput {
  metadata: MetadataSelectionsInput!
  artists: [SelectionEntry!]!
  tracks: [SelectionEntry!]!
  externalIds: ExternalIdSelectionsInput!
  coverArt: CoverArtChoice!
}

input CorrectionApplyInput {
  albumId: UUID!
  preview: JSON!
  selections: FieldSelectionsInput!
  expectedUpdatedAt: DateTime!
}
```

Note: Using JSON for preview because CorrectionPreview is complex (nested Album, Tracks, etc.). GraphQL input types don't support recursive/complex outputs.

Add to Query type (find appropriate position):
```graphql
  # Correction operations (admin only)
  correctionSearch(input: CorrectionSearchInput!): CorrectionSearchResponse!
  correctionPreview(input: CorrectionPreviewInput!): CorrectionPreview!
```

Add to Mutation type (find appropriate position):
```graphql
  # Correction operations (admin only)
  correctionApply(input: CorrectionApplyInput!): CorrectionApplyResult!
```
  </action>
  <verify>Run `pnpm codegen` - should complete successfully generating types</verify>
  <done>Input types defined, Query and Mutation roots include correction operations</done>
</task>

</tasks>

<verification>
- Run `pnpm codegen` - completes without errors
- Check `src/generated/graphql.ts` for generated types:
  - CorrectionSearchInput
  - CorrectionPreviewInput
  - CorrectionApplyInput
  - CorrectionSearchResponse
  - CorrectionPreview
  - CorrectionApplyResult
</verification>

<success_criteria>
- Schema parses and codegen succeeds
- All correction enums are defined
- All correction types are defined
- All input types are defined
- Query/Mutation roots include correction operations
</success_criteria>

<output>
After completion, create `.planning/phases/05-graphql-integration/05-01-SUMMARY.md`
</output>
