---
phase: 05-graphql-integration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/lib/graphql/resolvers/queries.ts
  - src/lib/graphql/resolvers/mutations.ts
autonomous: true

must_haves:
  truths:
    - "correctionSearch query returns scored grouped results"
    - "correctionPreview query returns field-by-field diff"
    - "correctionApply mutation updates album atomically"
    - "Non-admin users receive FORBIDDEN error"
  artifacts:
    - path: "src/lib/graphql/resolvers/queries.ts"
      provides: "correctionSearch and correctionPreview resolvers"
      contains: "correctionSearch"
    - path: "src/lib/graphql/resolvers/mutations.ts"
      provides: "correctionApply resolver"
      contains: "correctionApply"
  key_links:
    - from: "src/lib/graphql/resolvers/queries.ts"
      to: "src/lib/correction"
      via: "getSearchScoringService()"
      pattern: "getSearchScoringService"
    - from: "src/lib/graphql/resolvers/mutations.ts"
      to: "src/lib/correction"
      via: "applyCorrectionService"
      pattern: "applyCorrectionService"
---

<objective>
Implement thin resolvers for correction operations

Purpose: Wire GraphQL operations to service layer with admin authorization
Output: Working correctionSearch, correctionPreview, and correctionApply resolvers
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-graphql-integration/05-CONTEXT.md
@.planning/phases/05-graphql-integration/05-RESEARCH.md
@.planning/phases/05-graphql-integration/05-01-SUMMARY.md

@src/lib/graphql/resolvers/queries.ts
@src/lib/graphql/resolvers/mutations.ts
@src/lib/permissions.ts
@src/lib/correction/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add correctionSearch and correctionPreview query resolvers</name>
  <files>src/lib/graphql/resolvers/queries.ts</files>
  <action>
Add two query resolvers to the queryResolvers object. Follow existing patterns exactly.

**correctionSearch resolver:**
```typescript
correctionSearch: async (_, { input }, { user }) => {
  // 1. Authentication check
  if (!user) {
    throw new GraphQLError('Authentication required', {
      extensions: { code: 'UNAUTHENTICATED' },
    });
  }

  // 2. Authorization check (admin only)
  if (!isAdmin(user.role)) {
    throw new GraphQLError('Unauthorized: Admin access required', {
      extensions: { code: 'FORBIDDEN' },
    });
  }

  try {
    // 3. Delegate to search scoring service
    const { getSearchScoringService } = await import('@/lib/correction');
    const searchService = getSearchScoringService();

    const response = await searchService.searchWithScoring({
      albumTitle: input.albumTitle ?? undefined,
      artistName: input.artistName ?? undefined,
      yearFilter: input.yearFilter ?? undefined,
      limit: input.limit ?? 10,
      offset: input.offset ?? 0,
      strategy: input.strategy?.toLowerCase() as 'normalized' | 'tiered' | 'weighted' | undefined,
      lowConfidenceThreshold: input.lowConfidenceThreshold ?? undefined,
    });

    // 4. Transform to GraphQL schema format
    return {
      results: response.results.map(group => ({
        releaseGroupMbid: group.releaseGroupMbid,
        primaryResult: transformScoredResult(group.primaryResult),
        alternateVersions: group.alternateVersions.map(transformScoredResult),
        versionCount: group.versionCount,
        bestScore: group.bestScore,
      })),
      totalGroups: response.totalGroups,
      hasMore: response.hasMore,
      query: response.query,
      scoring: {
        strategy: response.scoring.strategy.toUpperCase(),
        threshold: response.scoring.threshold,
        lowConfidenceCount: response.scoring.lowConfidenceCount,
      },
    };
  } catch (error) {
    if (error instanceof GraphQLError) throw error;
    console.error('Correction search error:', error);
    throw new GraphQLError(`Search failed: ${error}`, {
      extensions: { code: 'INTERNAL_ERROR' },
    });
  }
},
```

Add helper function near the resolvers (or at top of file):
```typescript
function transformScoredResult(result: import('@/lib/correction').ScoredSearchResult) {
  return {
    releaseGroupMbid: result.releaseGroupMbid,
    title: result.title,
    disambiguation: result.disambiguation,
    artistCredits: result.artistCredits,
    primaryArtistName: result.primaryArtistName,
    firstReleaseDate: result.firstReleaseDate,
    primaryType: result.primaryType,
    secondaryTypes: result.secondaryTypes,
    mbScore: result.mbScore,
    coverArtUrl: result.coverArtUrl,
    source: result.source,
    normalizedScore: result.normalizedScore,
    displayScore: typeof result.displayScore === 'number' ? result.displayScore : 0,
    breakdown: {
      titleScore: result.breakdown.titleScore,
      artistScore: result.breakdown.artistScore,
      yearScore: result.breakdown.yearScore,
      confidenceTier: result.breakdown.confidenceTier?.toUpperCase(),
    },
    isLowConfidence: result.isLowConfidence,
    scoringStrategy: result.scoringStrategy.toUpperCase(),
  };
}
```

**correctionPreview resolver:**
```typescript
correctionPreview: async (_, { input }, { user, prisma }) => {
  // 1. Authentication check
  if (!user) {
    throw new GraphQLError('Authentication required', {
      extensions: { code: 'UNAUTHENTICATED' },
    });
  }

  // 2. Authorization check (admin only)
  if (!isAdmin(user.role)) {
    throw new GraphQLError('Unauthorized: Admin access required', {
      extensions: { code: 'FORBIDDEN' },
    });
  }

  try {
    // 3. Get album with tracks
    const album = await prisma.album.findUnique({
      where: { id: input.albumId },
      include: {
        tracks: { orderBy: [{ discNumber: 'asc' }, { trackNumber: 'asc' }] },
        artists: { include: { artist: true } },
      },
    });

    if (!album) {
      throw new GraphQLError('Album not found', {
        extensions: { code: 'NOT_FOUND' },
      });
    }

    // 4. Search for the specific release group
    const { getSearchScoringService, getCorrectionPreviewService } = await import('@/lib/correction');
    const searchService = getSearchScoringService();

    // Find the result matching the release group MBID
    const searchResponse = await searchService.searchWithScoring({
      albumTitle: album.title,
      artistName: album.artists[0]?.artist?.name,
      limit: 50, // Search enough to find it
    });

    // Find the matching result
    let selectedResult: import('@/lib/correction').ScoredSearchResult | undefined;
    for (const group of searchResponse.results) {
      if (group.releaseGroupMbid === input.releaseGroupMbid) {
        selectedResult = group.primaryResult;
        break;
      }
      const altMatch = group.alternateVersions.find(
        v => v.releaseGroupMbid === input.releaseGroupMbid
      );
      if (altMatch) {
        selectedResult = altMatch;
        break;
      }
    }

    if (!selectedResult) {
      throw new GraphQLError('Release group not found in search results', {
        extensions: { code: 'NOT_FOUND' },
      });
    }

    // 5. Generate preview
    const previewService = getCorrectionPreviewService();
    const preview = await previewService.generatePreview(
      album as import('@/lib/correction').CorrectionPreview['currentAlbum'],
      selectedResult
    );

    // 6. Transform to GraphQL format
    return {
      currentAlbum: album,
      sourceResult: transformScoredResult(preview.sourceResult),
      mbReleaseData: preview.mbReleaseData ? transformMBReleaseData(preview.mbReleaseData) : null,
      fieldDiffs: preview.fieldDiffs, // JSON array
      artistDiff: {
        changeType: preview.artistDiff.changeType,
        current: preview.artistDiff.current,
        source: preview.artistDiff.source,
        currentDisplay: preview.artistDiff.currentDisplay,
        sourceDisplay: preview.artistDiff.sourceDisplay,
        nameDiff: preview.artistDiff.nameDiff,
      },
      trackDiffs: preview.trackDiffs.map(td => ({
        position: td.position,
        discNumber: td.discNumber,
        changeType: td.changeType === 'MATCH' ? 'UNCHANGED' : td.changeType,
        currentTitle: td.current?.title,
        currentDurationMs: td.current?.durationMs,
        sourceTitle: td.source?.title,
        sourceDurationMs: td.source?.durationMs,
        sourceMbid: td.source?.mbid,
        titleDiff: td.titleDiff,
        durationDelta: td.durationDelta,
      })),
      trackSummary: preview.trackSummary,
      coverArt: preview.coverArt,
      summary: preview.summary,
    };
  } catch (error) {
    if (error instanceof GraphQLError) throw error;
    console.error('Correction preview error:', error);
    throw new GraphQLError(`Preview generation failed: ${error}`, {
      extensions: { code: 'INTERNAL_ERROR' },
    });
  }
},
```

Add helper for MBReleaseData transformation:
```typescript
function transformMBReleaseData(data: import('@/lib/correction').MBReleaseData) {
  return {
    id: data.id,
    title: data.title,
    date: data.date,
    country: data.country,
    barcode: data.barcode,
    media: data.media.map(m => ({
      position: m.position,
      format: m.format,
      trackCount: m.trackCount,
      tracks: m.tracks.map(t => ({
        position: t.position,
        recording: {
          id: t.recording.id,
          title: t.recording.title,
          length: t.recording.length,
          position: t.recording.position,
        },
      })),
    })),
    artistCredit: data.artistCredit.map(ac => ({
      name: ac.name,
      joinphrase: ac.joinphrase,
      artist: {
        id: ac.artist.id,
        name: ac.artist.name,
        sortName: ac.artist.sortName,
        disambiguation: ac.artist.disambiguation,
      },
    })),
  };
}
```

Ensure `isAdmin` is imported at top of file (should already exist).
  </action>
  <verify>TypeScript compiles: `pnpm type-check`</verify>
  <done>correctionSearch and correctionPreview resolvers are implemented with admin authorization</done>
</task>

<task type="auto">
  <name>Task 2: Add correctionApply mutation resolver</name>
  <files>src/lib/graphql/resolvers/mutations.ts</files>
  <action>
Add mutation resolver to the mutationResolvers object. Follow existing patterns exactly.

```typescript
correctionApply: async (_, { input }, { user, prisma }) => {
  // 1. Authentication check
  if (!user) {
    throw new GraphQLError('Authentication required', {
      extensions: { code: 'UNAUTHENTICATED' },
    });
  }

  // 2. Authorization check (admin only)
  if (!isAdmin(user.role)) {
    throw new GraphQLError('Unauthorized: Admin access required', {
      extensions: { code: 'FORBIDDEN' },
    });
  }

  try {
    // 3. Import apply service
    const { applyCorrectionService, StaleDataError } = await import('@/lib/correction');

    // 4. Transform selections from GraphQL input to service format
    const selections: import('@/lib/correction/apply/types').FieldSelections = {
      metadata: input.selections.metadata,
      artists: new Map(input.selections.artists.map(e => [e.key, e.selected])),
      tracks: new Map(input.selections.tracks.map(e => [e.key, e.selected])),
      externalIds: input.selections.externalIds,
      coverArt: input.selections.coverArt.toLowerCase() as 'use_source' | 'keep_current' | 'clear',
    };

    // 5. Apply correction
    const result = await applyCorrectionService.applyCorrection({
      albumId: input.albumId,
      preview: input.preview as import('@/lib/correction').CorrectionPreview,
      selections,
      expectedUpdatedAt: new Date(input.expectedUpdatedAt),
      adminUserId: user.id,
    });

    // 6. Return result (success or failure)
    if (result.success) {
      return {
        success: true,
        album: result.album,
        changes: {
          metadata: result.changes.metadata,
          artists: result.changes.artists,
          tracks: result.changes.tracks,
          externalIds: result.changes.externalIds,
          coverArt: result.changes.coverArt,
          dataQualityBefore: result.changes.dataQualityBefore,
          dataQualityAfter: result.changes.dataQualityAfter,
        },
        error: null,
      };
    } else {
      return {
        success: false,
        album: null,
        changes: null,
        error: {
          code: result.error.code,
          message: result.error.message,
        },
      };
    }
  } catch (error) {
    // Handle StaleDataError specifically
    const { StaleDataError } = await import('@/lib/correction');
    if (error instanceof StaleDataError) {
      return {
        success: false,
        album: null,
        changes: null,
        error: {
          code: 'STALE_DATA',
          message: error.message,
        },
      };
    }

    if (error instanceof GraphQLError) throw error;
    
    console.error('Correction apply error:', error);
    throw new GraphQLError(`Apply failed: ${error}`, {
      extensions: { code: 'INTERNAL_ERROR' },
    });
  }
},
```

Ensure `isAdmin` import exists (should already be imported at line 27).
  </action>
  <verify>TypeScript compiles: `pnpm type-check`</verify>
  <done>correctionApply resolver is implemented with admin authorization and proper error handling</done>
</task>

</tasks>

<verification>
- Run `pnpm type-check` - no TypeScript errors
- Run `pnpm lint` - passes without resolver-related errors
- Resolvers handle all error cases (auth, not found, stale data, internal)
</verification>

<success_criteria>
- correctionSearch resolver delegates to getSearchScoringService()
- correctionPreview resolver generates diffs via getCorrectionPreviewService()
- correctionApply resolver applies changes via applyCorrectionService
- All resolvers check isAdmin() before proceeding
- Unauthenticated requests throw UNAUTHENTICATED error
- Non-admin requests throw FORBIDDEN error
</success_criteria>

<output>
After completion, create `.planning/phases/05-graphql-integration/05-02-SUMMARY.md`
</output>
