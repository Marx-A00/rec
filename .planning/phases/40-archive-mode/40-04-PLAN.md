---
phase: 40-archive-mode
plan: 04
type: execute
wave: 4
depends_on: [40-03]
files_modified:
  - src/components/uncover/ArchiveGame.tsx
  - src/hooks/useArchiveGame.ts
  - src/components/uncover/StatsModal.tsx
  - src/app/(main)/game/archive/[date]/page.tsx
  - src/app/m/game/archive/[date]/page.tsx
  - src/app/(main)/game/page.tsx
autonomous: true

must_haves:
  truths:
    - "Player can play past puzzles from archive"
    - "Archive puzzles don't affect current streak"
    - "Archive wins/losses update archive stats"
    - "Stats modal shows both daily and archive stats"
  artifacts:
    - path: "src/components/uncover/ArchiveGame.tsx"
      provides: "Archive game UI component"
      exports: ["ArchiveGame"]
    - path: "src/hooks/useArchiveGame.ts"
      provides: "Archive game coordination hook"
      exports: ["useArchiveGame"]
    - path: "src/components/uncover/StatsModal.tsx"
      provides: "Combined daily + archive stats display"
      contains: "myArchiveStats"
  key_links:
    - from: "src/hooks/useArchiveGame.ts"
      to: "useStartArchiveSessionMutation"
      via: "GraphQL mutation"
      pattern: "startArchiveSession"
    - from: "src/components/uncover/StatsModal.tsx"
      to: "useMyArchiveStatsQuery"
      via: "GraphQL query"
      pattern: "myArchiveStats"
---

<objective>
Complete archive game flow with game component, hook, stats integration, and entry point.

Purpose: ARCHIVE-01 requires playable past puzzles. ARCHIVE-03 requires no streak impact (enforced via mode='archive'). ARCHIVE-04 requires archive stats tracked and displayed. Entry point button on main game page provides discoverability.

Output: ArchiveGame component, useArchiveGame hook, updated StatsModal with archive section, archive routes completed, entry point on main game page.
</objective>

<execution_context>
@/Users/marcosandrade/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcosandrade/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/40-archive-mode/40-CONTEXT.md
@.planning/phases/40-archive-mode/40-RESEARCH.md
@.planning/phases/40-archive-mode/40-03-SUMMARY.md
@src/components/uncover/UncoverGame.tsx (existing game component pattern)
@src/hooks/useUncoverGame.ts (existing game hook pattern)
@src/components/uncover/StatsModal.tsx (existing stats modal)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useArchiveGame hook</name>
  <files>src/hooks/useArchiveGame.ts</files>
  <action>
Create `src/hooks/useArchiveGame.ts` based on useUncoverGame.ts pattern but for archive mode:

```typescript
'use client';

import { useCallback, useState } from 'react';
import { useSession } from 'next-auth/react';
import { useQueryClient } from '@tanstack/react-query';

import { useUncoverGameStore } from '@/stores/useUncoverGameStore';
import {
  useStartArchiveSessionMutation,
  useSubmitGuessMutation,
  useSkipGuessMutation,
} from '@/generated/graphql';

/**
 * Coordination hook for Archive game.
 * Similar to useUncoverGame but:
 * - Starts session with specific date (not today)
 * - Passes mode='archive' to mutations (ARCHIVE-03)
 * - Invalidates session history on game completion (calendar update)
 */
export function useArchiveGame(challengeDate: Date) {
  const { data: session, status: authStatus } = useSession();
  const queryClient = useQueryClient();
  const gameStore = useUncoverGameStore();

  const [localError, setLocalError] = useState<string | null>(null);

  // GraphQL mutations
  const startMutation = useStartArchiveSessionMutation();
  const submitMutation = useSubmitGuessMutation();
  const skipMutation = useSkipGuessMutation();

  /**
   * Start an archive session for the specified date.
   */
  const startGame = useCallback(async () => {
    try {
      gameStore.setSubmitting(true);
      gameStore.clearError();
      setLocalError(null);

      const result = await startMutation.mutateAsync({
        date: challengeDate.toISOString(),
      });

      if (!result.startArchiveSession) {
        throw new Error('Failed to start archive session');
      }

      const {
        session: sessionData,
        imageUrl,
        cloudflareImageId,
        challengeId,
      } = result.startArchiveSession;

      // Sync session to store
      gameStore.setSession({
        id: sessionData.id,
        challengeId: challengeId,
      });

      // Sync guesses to store (for resumed sessions)
      gameStore.clearGuesses();
      sessionData.guesses.forEach((guess) => {
        gameStore.addGuess({
          guessNumber: guess.guessNumber,
          albumId: guess.guessedAlbum?.id ?? null,
          albumTitle: guess.guessedAlbum?.title ?? '(skipped)',
          artistName: guess.guessedAlbum?.artistName ?? '',
          isCorrect: guess.isCorrect,
        });
      });

      // Update attempt count
      gameStore.updateAttemptCount(sessionData.attemptCount);

      // Check if session is already completed
      if (sessionData.status === 'WON') {
        gameStore.endSession(true);
      } else if (sessionData.status === 'LOST') {
        gameStore.endSession(false);
      }

      return {
        imageUrl,
        cloudflareImageId: cloudflareImageId ?? undefined,
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Failed to start archive game';
      gameStore.setError(errorMessage);
      setLocalError(errorMessage);
      throw error;
    } finally {
      gameStore.setSubmitting(false);
    }
  }, [gameStore, startMutation, challengeDate]);

  /**
   * Submit a guess with mode='archive'.
   * ARCHIVE-03: Archive mode doesn't affect streaks.
   */
  const submitGuess = useCallback(
    async (albumId: string, albumTitle: string, artistName: string) => {
      if (!gameStore.sessionId) {
        throw new Error('No active session');
      }

      try {
        gameStore.setSubmitting(true);
        gameStore.clearError();
        setLocalError(null);

        const result = await submitMutation.mutateAsync({
          sessionId: gameStore.sessionId,
          albumId,
          mode: 'archive', // ARCHIVE-03: No streak impact
        });

        if (!result.submitGuess) {
          throw new Error('Failed to submit guess');
        }

        const { guess, session: sessionResult, gameOver } = result.submitGuess;

        // Add guess to store
        gameStore.addGuess({
          guessNumber: guess.guessNumber,
          albumId: guess.guessedAlbum?.id ?? null,
          albumTitle: guess.guessedAlbum?.title ?? albumTitle,
          artistName: guess.guessedAlbum?.artistName ?? artistName,
          isCorrect: guess.isCorrect,
        });

        gameStore.updateAttemptCount(sessionResult.attemptCount);

        if (gameOver) {
          gameStore.endSession(sessionResult.won);
          // Invalidate calendar data so it shows updated status
          queryClient.invalidateQueries({ queryKey: ['MyUncoverSessions'] });
        }

        return {
          isCorrect: guess.isCorrect,
          gameOver,
          won: sessionResult.won,
        };
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : 'Failed to submit guess';
        gameStore.setError(errorMessage);
        setLocalError(errorMessage);
        throw error;
      } finally {
        gameStore.setSubmitting(false);
      }
    },
    [gameStore, submitMutation, queryClient]
  );

  /**
   * Skip guess with mode='archive'.
   */
  const skipGuess = useCallback(async () => {
    if (!gameStore.sessionId) {
      throw new Error('No active session');
    }

    try {
      gameStore.setSubmitting(true);
      gameStore.clearError();
      setLocalError(null);

      const result = await skipMutation.mutateAsync({
        sessionId: gameStore.sessionId,
        mode: 'archive', // ARCHIVE-03: No streak impact
      });

      if (!result.skipGuess) {
        throw new Error('Failed to skip guess');
      }

      const { guess, session: sessionResult, gameOver } = result.skipGuess;

      gameStore.addGuess({
        guessNumber: guess.guessNumber,
        albumId: null,
        albumTitle: '(skipped)',
        artistName: '',
        isCorrect: false,
      });

      gameStore.updateAttemptCount(sessionResult.attemptCount);

      if (gameOver) {
        gameStore.endSession(sessionResult.won);
        // Invalidate calendar data
        queryClient.invalidateQueries({ queryKey: ['MyUncoverSessions'] });
      }

      return { gameOver };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Failed to skip guess';
      gameStore.setError(errorMessage);
      setLocalError(errorMessage);
      throw error;
    } finally {
      gameStore.setSubmitting(false);
    }
  }, [gameStore, skipMutation, queryClient]);

  const revealStage =
    gameStore.status === 'WON' || gameStore.status === 'LOST'
      ? 6
      : Math.min(gameStore.attemptCount + 1, 6);

  return {
    isAuthenticated: !!session?.user,
    isAuthLoading: authStatus === 'loading',
    user: session?.user,

    sessionId: gameStore.sessionId,
    challengeId: gameStore.challengeId,
    status: gameStore.status,
    attemptCount: gameStore.attemptCount,
    won: gameStore.won,
    guesses: gameStore.guesses,

    isSubmitting: gameStore.isSubmitting,
    error: gameStore.error || localError,

    revealStage,
    isGameOver: gameStore.status === 'WON' || gameStore.status === 'LOST',

    startGame,
    submitGuess,
    skipGuess,
    resetGame: gameStore.resetSession,
    clearError: () => {
      gameStore.clearError();
      setLocalError(null);
    },
  };
}
```

Key differences from useUncoverGame:
1. Takes challengeDate parameter
2. Uses startArchiveSession mutation
3. Passes mode='archive' to submitGuess and skipGuess
4. Invalidates MyUncoverSessions query on game completion
  </action>
  <verify>
Run `pnpm type-check` - no TypeScript errors.
File exports useArchiveGame hook.
  </verify>
  <done>
useArchiveGame.ts created with archive-specific logic.
Uses startArchiveSession mutation with date parameter.
Passes mode='archive' to guess mutations.
Invalidates calendar query on game completion.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ArchiveGame component and update routes</name>
  <files>
    src/components/uncover/ArchiveGame.tsx,
    src/app/(main)/game/archive/[date]/page.tsx,
    src/app/m/game/archive/[date]/page.tsx
  </files>
  <action>
1. Create `src/components/uncover/ArchiveGame.tsx`:

```typescript
'use client';

import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { format } from 'date-fns';
import { CalendarDays, ArrowLeft } from 'lucide-react';

import { useArchiveGame } from '@/hooks/useArchiveGame';
import { RevealImage } from '@/components/uncover/RevealImage';
import { AlbumGuessInput } from '@/components/uncover/AlbumGuessInput';
import { GuessList } from '@/components/uncover/GuessList';
import { AttemptDots } from '@/components/uncover/AttemptDots';
import { StatsModal } from '@/components/uncover/StatsModal';
import { Button } from '@/components/ui/button';

interface ArchiveGameProps {
  challengeDate: Date;
  mobile?: boolean;
}

/**
 * Archive game component - plays past daily puzzles.
 * ARCHIVE-03: Archive games don't affect streaks (handled by hook).
 */
export function ArchiveGame({ challengeDate, mobile = false }: ArchiveGameProps) {
  const router = useRouter();
  const game = useArchiveGame(challengeDate);

  const [challengeImageUrl, setChallengeImageUrl] = useState<string | null>(null);
  const [isInitializing, setIsInitializing] = useState(false);
  const [showStats, setShowStats] = useState(false);

  const formattedDate = format(challengeDate, 'MMMM d, yyyy');

  // Auto-start session on mount
  useEffect(() => {
    if (!game.isAuthenticated || game.isAuthLoading) return;
    if (game.sessionId) return;
    if (isInitializing) return;

    const initializeGame = async () => {
      setIsInitializing(true);
      try {
        const result = await game.startGame();
        setChallengeImageUrl(result.imageUrl);
      } catch (error) {
        console.error('Failed to start archive game:', error);
      } finally {
        setIsInitializing(false);
      }
    };

    initializeGame();
  }, [game.isAuthenticated, game.isAuthLoading, game.sessionId, game, isInitializing]);

  // Auto-show stats modal when game ends
  useEffect(() => {
    if (game.isGameOver && !showStats) {
      const timer = setTimeout(() => setShowStats(true), 800);
      return () => clearTimeout(timer);
    }
  }, [game.isGameOver, showStats]);

  const archiveUrl = mobile ? '/m/game/archive' : '/game/archive';

  // Loading state
  if (game.isAuthLoading || isInitializing || (game.isAuthenticated && !game.sessionId)) {
    return (
      <div className="flex min-h-[400px] items-center justify-center">
        <div className="text-muted-foreground">Loading archive game...</div>
      </div>
    );
  }

  // Error state
  if (game.error && !game.sessionId) {
    return (
      <div className="flex min-h-[400px] flex-col items-center justify-center gap-4 p-8">
        <div className="text-center">
          <h2 className="mb-2 text-xl font-bold text-red-600">Error</h2>
          <p className="text-muted-foreground">{game.error}</p>
        </div>
        <Button onClick={() => router.push(archiveUrl)}>
          Back to Archive
        </Button>
      </div>
    );
  }

  // Game over state
  if (game.isGameOver) {
    return (
      <div className="flex min-h-[400px] flex-col items-center justify-center gap-6 p-4 md:p-8">
        {/* Header */}
        <div className="flex items-center gap-2 text-muted-foreground">
          <CalendarDays className="h-4 w-4" />
          <span className="text-sm">{formattedDate}</span>
        </div>

        <div className="text-center">
          <h2 className="mb-2 text-3xl font-bold">
            {game.won ? 'ðŸŽ‰ You Won!' : 'ðŸ˜” Game Over'}
          </h2>
          <p className="text-muted-foreground">
            {game.won
              ? `You guessed correctly in ${game.attemptCount} ${game.attemptCount === 1 ? 'attempt' : 'attempts'}!`
              : `You used all ${game.attemptCount} attempts.`}
          </p>
        </div>

        {/* Full reveal */}
        {challengeImageUrl && game.challengeId && (
          <div className="w-full max-w-md">
            <RevealImage
              imageUrl={challengeImageUrl}
              challengeId={game.challengeId}
              stage={6}
              showToggle={false}
              className="aspect-square w-full overflow-hidden rounded-lg"
            />
          </div>
        )}

        {/* Guesses */}
        {game.guesses.length > 0 && (
          <div className="w-full max-w-md">
            <GuessList guesses={game.guesses} />
          </div>
        )}

        {/* Actions */}
        <div className="flex flex-col gap-3 w-full max-w-md">
          <Button onClick={() => setShowStats(true)} variant="outline">
            View Stats
          </Button>
          <Button onClick={() => router.push(archiveUrl)}>
            <CalendarDays className="mr-2 h-4 w-4" />
            Back to Archive
          </Button>
        </div>

        {/* Stats Modal - mode='archive' shows archive section prominently */}
        <StatsModal
          open={showStats}
          onClose={() => setShowStats(false)}
          won={game.won}
          attemptCount={game.attemptCount}
          mode="archive"
        />
      </div>
    );
  }

  // Active game state
  return (
    <div className="flex min-h-[400px] flex-col items-center gap-6 p-4 md:p-8">
      {/* Header with date and back button */}
      <div className="flex w-full max-w-md items-center justify-between">
        <div className="flex items-center gap-2">
          <CalendarDays className="h-5 w-5 text-muted-foreground" />
          <h2 className="font-semibold">{formattedDate}</h2>
        </div>
        <Button variant="ghost" size="sm" onClick={() => router.push(archiveUrl)}>
          <ArrowLeft className="mr-1 h-4 w-4" />
          Calendar
        </Button>
      </div>

      {/* Reveal image */}
      {challengeImageUrl && game.challengeId && (
        <div className="w-full max-w-md">
          <RevealImage
            imageUrl={challengeImageUrl}
            challengeId={game.challengeId}
            stage={game.revealStage}
            isSubmitting={game.isSubmitting}
            className="aspect-square w-full overflow-hidden rounded-lg"
          />
        </div>
      )}

      {/* Attempt dots */}
      <AttemptDots attemptCount={game.attemptCount} />

      {/* Search input */}
      <div className="w-full max-w-md">
        <AlbumGuessInput
          onGuess={game.submitGuess}
          onSkip={game.skipGuess}
          disabled={game.isGameOver}
          isSubmitting={game.isSubmitting}
        />
      </div>

      {/* Previous guesses */}
      {game.guesses.length > 0 && (
        <div className="w-full max-w-md">
          <GuessList guesses={game.guesses} />
        </div>
      )}

      {/* Error display */}
      {game.error && (
        <div className="w-full max-w-md rounded-md border border-red-500/50 bg-red-950/20 p-4 text-center text-red-400">
          {game.error}
        </div>
      )}
    </div>
  );
}
```

2. Update `src/app/(main)/game/archive/[date]/page.tsx`:

```typescript
import { notFound } from 'next/navigation';
import { parseISO, isBefore, isAfter, isSameDay } from 'date-fns';
import { GAME_EPOCH, toUTCMidnight } from '@/lib/daily-challenge/date-utils';
import { ArchiveGame } from '@/components/uncover/ArchiveGame';

interface PageProps {
  params: Promise<{ date: string }>;
}

export async function generateMetadata({ params }: PageProps) {
  const { date } = await params;
  return {
    title: `Archive: ${date} | Daily Uncover`,
    description: `Play the daily album art puzzle from ${date}`,
  };
}

export default async function ArchiveGamePage({ params }: PageProps) {
  const { date: dateParam } = await params;

  // Validate date format
  let challengeDate: Date;
  try {
    challengeDate = toUTCMidnight(parseISO(dateParam));
  } catch {
    notFound();
  }

  const today = toUTCMidnight(new Date());

  if (isBefore(challengeDate, GAME_EPOCH)) {
    notFound();
  }

  if (isAfter(challengeDate, today) || isSameDay(challengeDate, today)) {
    notFound();
  }

  return (
    <div className="container mx-auto max-w-4xl py-8">
      <ArchiveGame challengeDate={challengeDate} mobile={false} />
    </div>
  );
}
```

3. Update `src/app/m/game/archive/[date]/page.tsx`:

```typescript
import { notFound } from 'next/navigation';
import { parseISO, isBefore, isAfter, isSameDay } from 'date-fns';
import { GAME_EPOCH, toUTCMidnight } from '@/lib/daily-challenge/date-utils';
import { ArchiveGame } from '@/components/uncover/ArchiveGame';

interface PageProps {
  params: Promise<{ date: string }>;
}

export async function generateMetadata({ params }: PageProps) {
  const { date } = await params;
  return {
    title: `Archive: ${date} | Daily Uncover`,
    description: `Play the daily album art puzzle from ${date}`,
  };
}

export default async function MobileArchiveGamePage({ params }: PageProps) {
  const { date: dateParam } = await params;

  let challengeDate: Date;
  try {
    challengeDate = toUTCMidnight(parseISO(dateParam));
  } catch {
    notFound();
  }

  const today = toUTCMidnight(new Date());

  if (isBefore(challengeDate, GAME_EPOCH)) {
    notFound();
  }

  if (isAfter(challengeDate, today) || isSameDay(challengeDate, today)) {
    notFound();
  }

  return (
    <div className="min-h-screen">
      <ArchiveGame challengeDate={challengeDate} mobile={true} />
    </div>
  );
}
```
  </action>
  <verify>
Run `pnpm type-check` - no TypeScript errors.
ArchiveGame component exists with proper props.
Both route files import and render ArchiveGame.
  </verify>
  <done>
ArchiveGame.tsx component created with full game flow.
Desktop route renders ArchiveGame with mobile={false}.
Mobile route renders ArchiveGame with mobile={true}.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update StatsModal with archive stats section</name>
  <files>src/components/uncover/StatsModal.tsx</files>
  <action>
Update `src/components/uncover/StatsModal.tsx` to show both daily and archive stats:

1. Add mode prop and archive stats query:
```typescript
interface StatsModalProps {
  open: boolean;
  onClose: () => void;
  won: boolean;
  attemptCount: number;
  /** Game mode - affects which section is highlighted */
  mode?: 'daily' | 'archive';
}
```

2. Import and use archive stats query:
```typescript
import { useMyUncoverStatsQuery, useMyArchiveStatsQuery } from '@/generated/graphql';
```

3. Fetch both stats:
```typescript
const { data: dailyData, isLoading: dailyLoading } = useMyUncoverStatsQuery(
  {},
  { enabled: open }
);
const { data: archiveData, isLoading: archiveLoading } = useMyArchiveStatsQuery(
  {},
  { enabled: open }
);

const stats = dailyData?.myUncoverStats;
const archiveStats = archiveData?.myArchiveStats;
const isLoading = dailyLoading || archiveLoading;
```

4. Update title based on mode:
```typescript
<DialogTitle className="text-center text-2xl">
  {won ? 'ðŸŽ‰ You Won!' : 'Game Over'}
  {mode === 'archive' && ' (Archive)'}
</DialogTitle>
```

5. Add archive stats section below daily stats (only show if archive games exist):
```typescript
{/* Daily Stats Section */}
<div>
  <h3 className="mb-3 text-sm font-medium text-muted-foreground">
    Daily Stats
  </h3>
  {/* Existing daily stats grid... */}
  <GuessDistributionChart
    distribution={stats.winDistribution}
    todayAttempts={mode === 'daily' && won ? attemptCount : null}
  />
</div>

{/* Archive Stats Section */}
{archiveStats && archiveStats.gamesPlayed > 0 && (
  <div className="border-t pt-4">
    <h3 className="mb-3 text-sm font-medium text-muted-foreground">
      Archive Stats
    </h3>
    <div className="grid grid-cols-3 gap-2 text-center mb-4">
      <div>
        <div className="text-xl font-bold md:text-2xl">
          {archiveStats.gamesPlayed}
        </div>
        <div className="text-[10px] text-muted-foreground md:text-xs">
          Played
        </div>
      </div>
      <div>
        <div className="text-xl font-bold md:text-2xl">
          {Math.round(archiveStats.winRate * 100)}%
        </div>
        <div className="text-[10px] text-muted-foreground md:text-xs">
          Win Rate
        </div>
      </div>
      <div>
        <div className="text-xl font-bold md:text-2xl">
          {archiveStats.gamesWon}
        </div>
        <div className="text-[10px] text-muted-foreground md:text-xs">
          Wins
        </div>
      </div>
    </div>
    <GuessDistributionChart
      distribution={archiveStats.winDistribution}
      todayAttempts={mode === 'archive' && won ? attemptCount : null}
    />
  </div>
)}
```

6. Update closing message based on mode:
```typescript
<p className="text-center text-sm text-muted-foreground">
  {mode === 'archive'
    ? 'Check the archive for more past puzzles!'
    : 'Come back tomorrow for a new challenge!'}
</p>
```
  </action>
  <verify>
Run `pnpm type-check` - no TypeScript errors.
StatsModal accepts mode prop.
Archive stats section renders when archiveStats exists.
  </verify>
  <done>
StatsModal.tsx updated with archive stats section.
Shows daily stats (with streaks) and archive stats (no streaks) separately.
Highlights correct distribution bar based on mode.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add archive entry point to main game page</name>
  <files>src/app/(main)/game/page.tsx</files>
  <action>
Update `src/app/(main)/game/page.tsx` to add archive button near the game area.

1. Import Link and CalendarDays icon:
```typescript
import Link from 'next/link';
import { CalendarDays } from 'lucide-react';
```

2. Add archive button in the game page layout. Find where the game header is rendered (around "Daily Uncover" heading) and add an archive link:

In the header section, add alongside existing elements:
```typescript
<Link
  href="/game/archive"
  className="flex items-center gap-1 text-sm text-muted-foreground hover:text-foreground transition-colors"
>
  <CalendarDays className="h-4 w-4" />
  <span>Archive</span>
</Link>
```

Look for the UncoverGame component import and the layout wrapper. The archive link should be visible but not dominant - positioned in header or near the game title.

Also update mobile game page `src/app/m/game/page.tsx` similarly, linking to `/m/game/archive`.
  </action>
  <verify>
Run `pnpm type-check` - no TypeScript errors.
Archive link visible on desktop game page.
Archive link visible on mobile game page.
  </verify>
  <done>
Archive entry point added to desktop game page (/game).
Archive entry point added to mobile game page (/m/game).
Links navigate to respective archive calendar pages.
  </done>
</task>

</tasks>

<verification>
1. `pnpm type-check` passes
2. `pnpm lint` passes
3. Archive game playable at /game/archive/2026-01-15 (example date)
4. Archive game passes mode='archive' to mutations (check network tab)
5. Stats modal shows both daily and archive sections
6. Archive button visible on main game page
7. Calendar updates status after archive game completion
</verification>

<success_criteria>
- useArchiveGame hook passes mode='archive' to all mutations (ARCHIVE-03)
- ArchiveGame component works on both desktop and mobile routes
- StatsModal shows archive stats section when archive games exist
- Archive entry point visible on main game pages
- Calendar query invalidated after archive game completion (status updates)
- Game state resets properly between daily and archive games
</success_criteria>

<output>
After completion, create `.planning/phases/40-archive-mode/40-04-SUMMARY.md`
</output>
