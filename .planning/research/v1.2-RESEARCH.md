# v1.2 Research: Job History Timeline UI

**Researched:** 2026-02-06
**Confidence:** HIGH

## Timeline Component

### Recommended: [timDeHof/shadcn-timeline](https://github.com/timDeHof/shadcn-timeline)

**Why this one:**
- Built on shadcn/ui patterns (copy-paste, not npm install)
- Uses Framer Motion (already installed in project: `^12.23.14`)
- TypeScript with full type definitions
- Status indicators: `completed`, `in-progress`, `pending`
- SSR compatible (Next.js)

**Files to copy:**
- `timeline.tsx` (13.7KB) — main component
- `timeline-layout.tsx` (1.5KB) — layout wrapper
- `index.ts` — exports

**Component API:**
```tsx
<Timeline size="md">
  <TimelineItem
    date={new Date()}
    title="ENRICH_ALBUM"
    description="Success — 4 fields enriched"
    status="completed"
    icon={<CheckCircle />}
  />
  <TimelineItem
    date={new Date()}
    title="SPOTIFY_TRACK_FALLBACK"
    description="Created 12 tracks"
    status="completed"
  />
</Timeline>
```

**Dependencies (all already installed):**
- `framer-motion` ✅
- `lucide-react` ✅
- `class-variance-authority` ✅

### Alternative Considered

[Aceternity UI Timeline](https://ui.aceternity.com/components/timeline) — has CLI install (`npx shadcn@latest add @aceternity/timeline`) but adds external dependency. Prefer copy-paste approach for full control.

---

## Recursive Job Fetching

### The Problem

Jobs form a tree: `ENRICH_ALBUM` → `ENRICH_ARTIST` → `DISCOGS_SEARCH` → `CACHE_ARTIST_IMAGE`

Need to fetch parent with all descendants for timeline display.

### Approach: Two-Query Strategy (Recommended)

Prisma doesn't support recursive CTEs natively. Options considered:

1. **Raw SQL with `WITH RECURSIVE`** — complex, harder to maintain
2. **Nested includes with max depth** — verbose, fixed depth
3. **Two-query approach** — simple, flexible ✅

**Two-query approach:**
```typescript
// Query 1: Get parent logs (where parentJobId is null or matches entity)
const parentLogs = await prisma.enrichmentLog.findMany({
  where: { 
    entityId,
    parentJobId: null  // Top-level jobs only
  },
  orderBy: { createdAt: 'desc' }
});

// Query 2: Get all children for these parents
const parentJobIds = parentLogs.map(l => l.jobId).filter(Boolean);
const childLogs = await prisma.enrichmentLog.findMany({
  where: {
    parentJobId: { in: parentJobIds }
  },
  orderBy: { createdAt: 'asc' }
});

// Assemble tree in JS
const logTree = parentLogs.map(parent => ({
  ...parent,
  children: childLogs.filter(c => c.parentJobId === parent.jobId)
}));
```

**Why this works:**
- Job chains are typically 2-4 levels max
- Single query for children (flat fetch, group in JS)
- No recursive SQL complexity
- Easy to extend if needed

### Schema Change

```prisma
model EnrichmentLog {
  // ... existing fields ...
  jobId        String?  @map("job_id") @db.VarChar(100)
  parentJobId  String?  @map("parent_job_id") @db.VarChar(100)  // NEW
  
  @@index([parentJobId])  // For efficient child lookups
}
```

### GraphQL Schema

```graphql
type EnrichmentLog {
  # ... existing fields ...
  jobId: String
  parentJobId: String
  children: [EnrichmentLog!]  # Resolved in JS, not DB relation
}

type Query {
  enrichmentLogs(
    entityType: EnrichmentEntityType
    entityId: UUID
    includeChildren: Boolean  # NEW - fetch tree structure
  ): [EnrichmentLog!]!
}
```

---

## UI Grouping Strategy

### Main Table Behavior

1. **Fetch logs with `parentJobId: null`** — only top-level jobs in table
2. **Show expand chevron** if job has children (check `childCount` or prefetch)
3. **On expand** — show Timeline component with parent + children

### Timeline Mapping

```typescript
// Map EnrichmentLog status to Timeline status
function mapStatus(log: EnrichmentLog): 'completed' | 'in-progress' | 'pending' {
  switch (log.status) {
    case 'SUCCESS':
    case 'PARTIAL_SUCCESS':
      return 'completed';
    case 'IN_PROGRESS':
      return 'in-progress';
    case 'FAILED':
    case 'NO_DATA_AVAILABLE':
    case 'SKIPPED':
    case 'PENDING':
    default:
      return 'pending';
  }
}

// Map operation to icon
function getOperationIcon(operation: string) {
  if (operation.includes('ALBUM')) return <Disc3 />;
  if (operation.includes('ARTIST')) return <User />;
  if (operation.includes('SPOTIFY')) return <Music />;
  if (operation.includes('DISCOGS')) return <Database />;
  if (operation.includes('CACHE')) return <Image />;
  return <Cog />;
}
```

---

## Pitfalls to Avoid

1. **N+1 queries** — Don't fetch children per-row. Batch fetch all children for visible parents.

2. **Deep recursion** — Job chains are shallow (2-4 levels). Don't over-engineer for infinite depth.

3. **Missing parentJobId in existing logs** — Old logs won't have `parentJobId`. Handle gracefully (show as standalone).

4. **Timeline overflow** — Long job chains could overflow. Consider max-height with scroll on timeline container.

---

## Sources

- [timDeHof/shadcn-timeline](https://github.com/timDeHof/shadcn-timeline) — Timeline component
- [shadcn-timeline demo](https://shadcn-timeline.vercel.app/) — Live demo
- [Prisma recursive relationships](https://github.com/prisma/prisma/issues/3725) — Prisma limitation context
- [NestJS recursive with Prisma](https://wanago.io/2023/12/11/api-nestjs-sql-recursive-relationships-prisma-postgresql/) — Two-query pattern reference
