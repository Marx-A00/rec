generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL") // Optional: for connection pooling (Supabase, Neon)
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                   String           @id @default(cuid())
  name                 String?
  email                String?          @unique
  emailVerified        DateTime?
  image                String?
  hashedPassword       String?
  bio                  String?
  role                 UserRole         @default(USER)
  followersCount       Int              @default(0)
  followingCount       Int              @default(0)
  recommendationsCount Int              @default(0)
  profileUpdatedAt     DateTime?
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt
  accounts             Account[]
  collections          Collection[]
  recommendations      Recommendation[]
  sessions             Session[]
  settings             UserSettings?
  followers            UserFollow[]     @relation("UserFollowers")
  following            UserFollow[]     @relation("UserFollowing")
  enrichmentLogs       EnrichmentLog[]
}

model UserSettings {
  id                    String   @id @default(cuid())
  userId                String   @unique
  dashboardLayout       Json?
  theme                 String   @default("dark")
  language              String   @default("en")
  profileVisibility     String   @default("public")
  showRecentActivity    Boolean  @default(true)
  showCollections       Boolean  @default(true)
  emailNotifications    Boolean  @default(true)
  recommendationAlerts  Boolean  @default(true)
  followAlerts          Boolean  @default(true)
  defaultCollectionView String   @default("grid")
  autoplayPreviews      Boolean  @default(false)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Recommendation {
  id                   String   @id @default(cuid())
  score                Int
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  userId               String
  basisAlbumId         String   @map("basis_album_id") @db.Uuid
  recommendedAlbumId   String   @map("recommended_album_id") @db.Uuid
  basisDiscogsId       String?  @map("basis_discogs_id")
  recommendedDiscogsId String?  @map("recommended_discogs_id")
  basisAlbum           Album    @relation("BasisAlbum", fields: [basisAlbumId], references: [id], onDelete: Cascade)
  recommendedAlbum     Album    @relation("RecommendedAlbum", fields: [recommendedAlbumId], references: [id], onDelete: Cascade)
  user                 User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([basisAlbumId])
  @@index([recommendedAlbumId])
}

model Collection {
  id          String            @id @default(cuid())
  name        String
  description String?
  userId      String
  isPublic    Boolean           @default(false)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  albums      CollectionAlbum[]

  @@index([userId])
  @@index([isPublic])
  @@index([userId, updatedAt])
}

model CollectionAlbum {
  id             String     @id @default(cuid())
  collectionId   String
  albumId        String     @map("album_id") @db.Uuid
  personalRating Int?
  personalNotes  String?
  position       Int        @default(0)
  addedAt        DateTime   @default(now())
  discogsId      String?    @map("discogs_id")
  album          Album      @relation(fields: [albumId], references: [id], onDelete: Cascade)
  collection     Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@unique([collectionId, albumId])
  @@index([collectionId])
  @@index([albumId])
  @@index([collectionId, position])
  @@index([collectionId, discogsId])
}

model UserFollow {
  id         String   @id @default(cuid())
  followerId String
  followedId String
  createdAt  DateTime @default(now())
  followed   User     @relation("UserFollowers", fields: [followedId], references: [id], onDelete: Cascade)
  follower   User     @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)

  @@unique([followerId, followedId])
  @@index([followerId])
  @@index([followedId])
  @@map("user_follows")
}

model UserActivity {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId        String?  @map("user_id")
  sessionId     String   @map("session_id") @db.VarChar(255)
  operation     String   @db.VarChar(100)
  operationType String   @map("operation_type") @db.VarChar(20)
  metadata      Json?    @map("metadata")
  albumIds      String[] @map("album_ids")
  artistIds     String[] @map("artist_ids")
  userAgent     String?  @map("user_agent")
  ipAddress     String?  @map("ip_address") @db.VarChar(45)
  requestId     String?  @map("request_id") @db.VarChar(255)
  timestamp     DateTime @default(now())

  @@index([userId, timestamp])
  @@index([sessionId, timestamp])
  @@index([operation])
  @@index([timestamp])
  @@map("user_activities")
}

model Artist {
  id               String                   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  musicbrainzId    String?                  @unique @map("musicbrainz_id") @db.Uuid
  spotifyId        String?                  @unique @map("spotify_id")
  discogsId        String?                  @map("discogs_id") @db.VarChar(20)
  name             String                   @db.VarChar(255)
  biography        String?
  formedYear       Int?                     @map("formed_year")
  countryCode      String?                  @map("country_code") @db.VarChar(2)
  area             String?                  @map("area") @db.VarChar(100)
  artistType       String?                  @map("artist_type") @db.VarChar(20)
  genres           String[]                 @map("genres")
  imageUrl         String?                  @map("image_url")
  cloudflareImageId String?                 @map("cloudflare_image_id")
  searchVector     Unsupported("tsvector")? @map("search_vector")
  source           ContentSource            @default(MUSICBRAINZ)
  sourceUrl        String?                  @map("source_url")
  submittedBy      String?                  @map("submitted_by") @db.Uuid
  dataQuality      DataQuality?             @default(LOW) @map("data_quality")
  enrichmentStatus EnrichmentStatus?        @default(PENDING) @map("enrichment_status")
  lastEnriched     DateTime?                @map("last_enriched")
  createdAt        DateTime                 @default(now()) @map("created_at")
  updatedAt        DateTime                 @updatedAt @map("updated_at")
  albums           AlbumArtist[]
  tracks           TrackArtist[]
  enrichmentLogs   EnrichmentLog[]

  @@index([name])
  @@index([musicbrainzId])
  @@index([searchVector], type: Gin)
  @@index([source])
  @@map("artists")
}

model Album {
  id                    String                   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  musicbrainzId         String?                  @unique @map("musicbrainz_id") @db.Uuid
  title                 String                   @db.VarChar(255)
  releaseDate           DateTime?                @map("release_date") @db.Date
  releaseType           String?                  @map("release_type") @db.VarChar(50)
  releaseStatus         String?                  @map("release_status") @db.VarChar(20)
  releaseCountry        String?                  @map("release_country") @db.VarChar(2)
  genres                String[]                 @map("genres")
  secondaryTypes        String[]                 @map("secondary_types")
  trackCount            Int?                     @map("track_count")
  durationMs            Int?                     @map("duration_ms")
  coverArtUrl           String?                  @map("cover_art_url")
  cloudflareImageId     String?                  @map("cloudflare_image_id")
  barcode               String?                  @db.VarChar(50)
  label                 String?                  @db.VarChar(255)
  catalogNumber         String?                  @map("catalog_number") @db.VarChar(100)
  searchVector          Unsupported("tsvector")? @map("search_vector")
  spotifyId             String?                  @unique @map("spotify_id") @db.VarChar(50)
  spotifyUrl            String?                  @map("spotify_url")
  discogsId             String?                  @map("discogs_id") @db.VarChar(20)
  source                ContentSource            @default(MUSICBRAINZ)
  sourceUrl             String?                  @map("source_url")
  submittedBy           String?                  @map("submitted_by") @db.Uuid
  dataQuality           DataQuality?             @default(LOW) @map("data_quality")
  enrichmentStatus      EnrichmentStatus?        @default(PENDING) @map("enrichment_status")
  lastEnriched          DateTime?                @map("last_enriched")
  createdAt             DateTime                 @default(now()) @map("created_at")
  updatedAt             DateTime                 @updatedAt @map("updated_at")
  collectionAlbums      CollectionAlbum[]
  basisRecommendations  Recommendation[]         @relation("BasisAlbum")
  targetRecommendations Recommendation[]         @relation("RecommendedAlbum")
  artists               AlbumArtist[]
  tracks                Track[]
  enrichmentLogs        EnrichmentLog[]

  @@index([title])
  @@index([releaseDate])
  @@index([musicbrainzId])
  @@index([searchVector], type: Gin)
  @@index([source])
  @@map("albums")
}

model Track {
  id               String                   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  albumId          String                   @map("album_id") @db.Uuid
  musicbrainzId    String?                  @unique @map("musicbrainz_id") @db.Uuid
  isrc             String?                  @db.VarChar(12)
  title            String                   @db.VarChar(255)
  trackNumber      Int                      @map("track_number")
  discNumber       Int                      @default(1) @map("disc_number")
  durationMs       Int?                     @map("duration_ms")
  explicit         Boolean                  @default(false)
  previewUrl       String?                  @map("preview_url")
  spotifyId        String?                  @unique @map("spotify_id") @db.VarChar(50)
  spotifyUrl       String?                  @map("spotify_url")
  youtubeUrl       String?                  @map("youtube_url")
  discogsReleaseId String?                  @map("discogs_release_id") @db.VarChar(20)
  discogsPosition  String?                  @map("discogs_position") @db.VarChar(10)
  source           ContentSource            @default(MUSICBRAINZ)
  sourceUrl        String?                  @map("source_url")
  submittedBy      String?                  @map("submitted_by") @db.Uuid
  dataQuality      DataQuality              @default(LOW) @map("data_quality")
  enrichmentStatus EnrichmentStatus         @default(PENDING) @map("enrichment_status")
  lastEnriched     DateTime?                @map("last_enriched")
  energy           Float?
  valence          Float?
  danceability     Float?
  tempo            Float?
  acousticness     Float?
  instrumentalness Float?
  liveness         Float?
  loudness         Float?
  speechiness      Float?
  key              Int?                     @map("key_signature")
  mode             Int?
  timeSignature    Int?                     @map("time_signature")
  searchVector     Unsupported("tsvector")? @map("search_vector")
  createdAt        DateTime                 @default(now()) @map("created_at")
  updatedAt        DateTime                 @updatedAt @map("updated_at")
  artists          TrackArtist[]
  album            Album                    @relation(fields: [albumId], references: [id], onDelete: Cascade)
  enrichmentLogs   EnrichmentLog[]

  @@index([albumId, discNumber, trackNumber])
  @@index([title])
  @@index([isrc])
  @@index([searchVector], type: Gin)
  @@index([source])
  @@index([discogsReleaseId, discogsPosition])
  @@map("tracks")
}

model AlbumArtist {
  albumId  String @map("album_id") @db.Uuid
  artistId String @map("artist_id") @db.Uuid
  role     String @default("primary") @db.VarChar(50)
  position Int    @default(0)
  album    Album  @relation(fields: [albumId], references: [id], onDelete: Cascade)
  artist   Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@id([albumId, artistId, role])
  @@index([albumId])
  @@index([artistId])
  @@map("album_artists")
}

model TrackArtist {
  trackId  String @map("track_id") @db.Uuid
  artistId String @map("artist_id") @db.Uuid
  role     String @default("primary") @db.VarChar(50)
  position Int    @default(0)
  artist   Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)
  track    Track  @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@id([trackId, artistId, role])
  @@index([trackId])
  @@index([artistId])
  @@map("track_artists")
}

model CacheData {
  id        String   @id @default(cuid())
  key       String   @unique
  data      Json
  expires   DateTime
  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([key, expires])
  @@map("cache_data")
}

model EnrichmentLog {
  id                 String                 @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  entityType         EnrichmentEntityType?  @map("entity_type")
  entityId           String?                @map("entity_id") @db.Uuid
  artistId           String?                @map("artist_id") @db.Uuid
  albumId            String?                @map("album_id") @db.Uuid
  trackId            String?                @map("track_id") @db.Uuid
  operation          String                 @db.VarChar(100)
  sources            String[]
  status             EnrichmentStatus
  fieldsEnriched     String[]               @map("fields_enriched")
  dataQualityBefore  DataQuality?           @map("data_quality_before")
  dataQualityAfter   DataQuality?           @map("data_quality_after")
  errorMessage       String?                @map("error_message")
  errorCode          String?                @map("error_code") @db.VarChar(50)
  retryCount         Int                    @default(0) @map("retry_count")
  durationMs         Int?                   @map("duration_ms")
  apiCallCount       Int                    @default(0) @map("api_call_count")
  metadata           Json?
  jobId              String?                @map("job_id") @db.VarChar(100)
  triggeredBy        String?                @map("triggered_by") @db.VarChar(50)
  userId             String?                @map("user_id") // Track which user made manual changes
  createdAt          DateTime               @default(now()) @map("created_at")
  artist             Artist?                @relation(fields: [artistId], references: [id], onDelete: Cascade)
  album              Album?                 @relation(fields: [albumId], references: [id], onDelete: Cascade)
  track              Track?                 @relation(fields: [trackId], references: [id], onDelete: Cascade)
  user               User?                  @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([entityType, entityId])
  @@index([artistId, createdAt])
  @@index([albumId, createdAt])
  @@index([trackId, createdAt])
  @@index([status, createdAt])
  @@index([operation])
  @@index([sources])
  @@index([userId])
  @@map("enrichment_logs")
}

enum ContentSource {
  DISCOGS
  MUSICBRAINZ
  SPOTIFY
  YOUTUBE
  BANDCAMP
  SOUNDCLOUD
  USER_SUBMITTED
}

enum DataQuality {
  LOW
  MEDIUM
  HIGH
}

enum EnrichmentStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  SUCCESS
  PARTIAL_SUCCESS
  NO_DATA_AVAILABLE
  SKIPPED
}

enum EnrichmentEntityType {
  ARTIST
  ALBUM
  TRACK
}

enum UserRole {
  USER
  MODERATOR
  ADMIN
  OWNER
}
