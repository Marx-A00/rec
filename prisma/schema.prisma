generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id              String           @id @default(cuid())
  name            String?
  email           String?          @unique
  emailVerified   DateTime?
  image           String?
  hashedPassword  String?
  
  // Essential profile fields
  bio             String?          @db.Text
  
  // Social statistics for music recommendations
  followersCount  Int              @default(0)
  followingCount  Int              @default(0)
  recommendationsCount Int          @default(0)
  
  // Profile timestamp
  profileUpdatedAt DateTime?
  
  // Existing relations
  accounts        Account[]
  recommendations Recommendation[]
  sessions        Session[]
  collections     Collection[]
  
  // Social features - following relationships
  following       UserFollow[]     @relation("UserFollowing")
  followers       UserFollow[]     @relation("UserFollowers")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Recommendation {
  id                  String   @id @default(cuid())
  score               Int
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  userId              String
  
  // Direct references to canonical albums
  basisAlbumId        String   @map("basis_album_id") @db.Uuid
  recommendedAlbumId  String   @map("recommended_album_id") @db.Uuid
  
  // Migration metadata (temporary - track migration from Discogs)
  migratedFromBasisDiscogsId       String? @map("migrated_from_basis_discogs_id")
  migratedFromRecommendedDiscogsId String? @map("migrated_from_recommended_discogs_id")
  
  // Relationships
  user           User  @relation(fields: [userId], references: [id])
  basisAlbum     Album @relation("BasisAlbum", fields: [basisAlbumId], references: [id], onDelete: Cascade)
  recommendedAlbum Album @relation("RecommendedAlbum", fields: [recommendedAlbumId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([basisAlbumId])
  @@index([recommendedAlbumId])
}

model Collection {
  id          String   @id @default(cuid())
  name        String
  description String?
  userId      String
  isPublic    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  albums      CollectionAlbum[]
  
  @@index([userId])
  @@index([isPublic])
  @@index([userId, updatedAt])  // Optimize user collections ordered by update time
}

model CollectionAlbum {
  id           String     @id @default(cuid())
  collectionId String
  albumId      String     @map("album_id") @db.Uuid  // Direct reference to canonical album
  
  // User-specific data
  personalRating Int?
  personalNotes  String?
  position       Int        @default(0)
  addedAt        DateTime   @default(now())
  
  // Migration metadata (temporary - track migration from Discogs)
  migratedFromDiscogsId String? @map("migrated_from_discogs_id")  // Track source for debugging
  
  // Relationships
  collection Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  album      Album      @relation(fields: [albumId], references: [id], onDelete: Cascade)
  
  @@unique([collectionId, albumId])  // One album per collection
  @@index([collectionId])
  @@index([albumId])
  @@index([collectionId, position])  // Optimize ordered album retrieval
}

// User follow relationships
model UserFollow {
  id          String   @id @default(cuid())
  followerId  String
  followedId  String
  createdAt   DateTime @default(now())
  
  follower    User     @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  followed    User     @relation("UserFollowers", fields: [followedId], references: [id], onDelete: Cascade)
  
  @@unique([followerId, followedId])
  @@index([followerId])
  @@index([followedId])
}

// ==================================
// CANONICAL MUSIC ENTITIES
// ==================================
// New canonical schema for Phase 1 migration
// These models represent the source of truth for music data

model Artist {
  id             String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  musicbrainzId  String?   @unique @map("musicbrainz_id") @db.Uuid
  name           String    @db.VarChar(255)
  biography      String?   @db.Text
  formedYear     Int?      @map("formed_year")
  countryCode    String?   @map("country_code") @db.VarChar(2)
  imageUrl       String?   @map("image_url") @db.Text
  searchVector   Unsupported("tsvector")? @map("search_vector")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")
  
  // Relationships
  albums         AlbumArtist[]
  tracks         TrackArtist[]
  
  @@index([name])
  @@index([musicbrainzId])
  @@index([searchVector], type: Gin)
  @@map("artists")
}

model Album {
  id            String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  musicbrainzId String?   @unique @map("musicbrainz_id") @db.Uuid
  title         String    @db.VarChar(255)
  releaseDate   DateTime? @map("release_date") @db.Date
  releaseType   String?   @map("release_type") @db.VarChar(50)
  trackCount    Int?      @map("track_count")
  durationMs    Int?      @map("duration_ms")
  coverArtUrl   String?   @map("cover_art_url") @db.Text
  barcode       String?   @db.VarChar(50)
  label         String?   @db.VarChar(255)
  catalogNumber String?   @map("catalog_number") @db.VarChar(100)
  searchVector  Unsupported("tsvector")? @map("search_vector")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  
  // Relationships
  artists             AlbumArtist[]
  tracks              Track[]
  collectionAlbums    CollectionAlbum[]     // Albums in user collections
  basisRecommendations Recommendation[] @relation("BasisAlbum")      // Recommendations based on this album
  targetRecommendations Recommendation[] @relation("RecommendedAlbum") // Recommendations targeting this album
  
  @@index([title])
  @@index([releaseDate])
  @@index([musicbrainzId])
  @@index([searchVector], type: Gin)
  @@map("albums")
}

model Track {
  id               String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  albumId          String    @map("album_id") @db.Uuid
  musicbrainzId    String?   @unique @map("musicbrainz_id") @db.Uuid
  isrc             String?   @db.VarChar(12)
  title            String    @db.VarChar(255)
  trackNumber      Int       @map("track_number")
  discNumber       Int       @default(1) @map("disc_number")
  durationMs       Int?      @map("duration_ms")
  explicit         Boolean   @default(false)
  previewUrl       String?   @map("preview_url") @db.Text
  
  // Audio Features (LIMITED AVAILABILITY - see notes below)
  // AcousticBrainz: Legacy data only (stopped collection 2022), some coverage via MusicBrainz ID
  // Spotify: Restricted for new apps (Nov 2024) - only legacy apps have access
  // Schema kept for future alternatives or manual population
  energy           Float?    // 0-1 energy level
  valence          Float?    // 0-1 positivity/happiness
  danceability     Float?    // 0-1 danceability 
  tempo            Float?    // BPM
  acousticness     Float?    // 0-1 acoustic vs electronic
  instrumentalness Float?    // 0-1 instrumental content
  liveness         Float?    // 0-1 live performance detection
  loudness         Float?    // dB loudness
  speechiness      Float?    // 0-1 speech content
  key              Int?      @map("key_signature") // 0-11 musical key
  mode             Int?      // 0=minor, 1=major
  timeSignature    Int?      @map("time_signature") // beats per bar
  
  searchVector     Unsupported("tsvector")? @map("search_vector")
  createdAt        DateTime  @default(now()) @map("created_at")
  updatedAt        DateTime  @updatedAt @map("updated_at")
  
  // Relationships
  album            Album     @relation(fields: [albumId], references: [id], onDelete: Cascade)
  artists          TrackArtist[]
  
  @@index([albumId, discNumber, trackNumber])
  @@index([title])
  @@index([isrc])
  @@index([searchVector], type: Gin)
  @@map("tracks")
}

// Junction tables for many-to-many relationships
model AlbumArtist {
  albumId   String  @map("album_id") @db.Uuid
  artistId  String  @map("artist_id") @db.Uuid
  role      String  @default("primary") @db.VarChar(50)
  position  Int     @default(0)
  
  album     Album   @relation(fields: [albumId], references: [id], onDelete: Cascade)
  artist    Artist  @relation(fields: [artistId], references: [id], onDelete: Cascade)
  
  @@id([albumId, artistId, role])
  @@index([albumId])
  @@index([artistId])
  @@map("album_artists")
}

model TrackArtist {
  trackId   String  @map("track_id") @db.Uuid
  artistId  String  @map("artist_id") @db.Uuid
  role      String  @default("primary") @db.VarChar(50)
  position  Int     @default(0)
  
  track     Track   @relation(fields: [trackId], references: [id], onDelete: Cascade)
  artist    Artist  @relation(fields: [artistId], references: [id], onDelete: Cascade)
  
  @@id([trackId, artistId, role])
  @@index([trackId])
  @@index([artistId])
  @@map("track_artists")
}
