generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL") // Optional: for connection pooling (Supabase, Neon)
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                   String           @id @default(cuid())
  name                 String?          // Required by NextAuth Prisma adapter for OAuth
  username             String?          @unique // Case-insensitive uniqueness enforced via custom index: User_username_lower_unique
  email                String?          @unique
  emailVerified        DateTime?
  image                String?
  hashedPassword       String?
  bio                  String?
  role                 UserRole         @default(USER)
  followersCount       Int              @default(0)
  followingCount       Int              @default(0)
  recommendationsCount Int              @default(0)
  profileUpdatedAt     DateTime?
  lastActive           DateTime?        @map("last_active")
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt
  accounts             Account[]
  collections          Collection[]
  recommendations      Recommendation[]
  sessions             Session[]
  settings             UserSettings?
  followers            UserFollow[]     @relation("UserFollowers")
  following            UserFollow[]     @relation("UserFollowing")
  llamaLogs            LlamaLog[]
  activities           Activity[]       @relation("ActivityActor")
  targetedActivities   Activity[]       @relation("ActivityTarget")
  uncoverSessions    UncoverSession[]
  uncoverStats       UncoverPlayerStats?
}

model UserSettings {
  id                    String   @id @default(cuid())
  userId                String   @unique
  dashboardLayout       Json?
  theme                 String   @default("dark")
  language              String   @default("en")
  profileVisibility        String   @default("public")
  showRecentActivity       Boolean  @default(true)
  showCollections          Boolean  @default(true)
  showListenLaterInFeed    Boolean  @default(true)
  showCollectionAddsInFeed Boolean  @default(true)
  showOnboardingTour       Boolean  @default(true)
  emailNotifications       Boolean  @default(true)
  recommendationAlerts  Boolean  @default(true)
  followAlerts          Boolean  @default(true)
  defaultCollectionView String   @default("grid")
  autoplayPreviews      Boolean  @default(false)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Recommendation {
  id                   String     @id @default(cuid())
  score                Int
  createdAt            DateTime   @default(now())
  updatedAt            DateTime   @updatedAt
  userId               String
  basisAlbumId         String     @map("basis_album_id") @db.Uuid
  recommendedAlbumId   String     @map("recommended_album_id") @db.Uuid
  basisDiscogsId       String?    @map("basis_discogs_id")
  recommendedDiscogsId String?    @map("recommended_discogs_id")
  basisAlbum           Album      @relation("BasisAlbum", fields: [basisAlbumId], references: [id], onDelete: Cascade)
  recommendedAlbum     Album      @relation("RecommendedAlbum", fields: [recommendedAlbumId], references: [id], onDelete: Cascade)
  user                 User       @relation(fields: [userId], references: [id])
  activities           Activity[]

  @@index([userId])
  @@index([basisAlbumId])
  @@index([recommendedAlbumId])
}

model Collection {
  id          String            @id @default(cuid())
  name        String
  description String?
  userId      String
  isPublic    Boolean           @default(false)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  albums      CollectionAlbum[]

  @@index([userId])
  @@index([isPublic])
  @@index([userId, updatedAt])
}

model CollectionAlbum {
  id             String     @id @default(cuid())
  collectionId   String
  albumId        String     @map("album_id") @db.Uuid
  personalRating Int?
  personalNotes  String?
  position       Int        @default(0)
  addedAt        DateTime   @default(now())
  discogsId      String?    @map("discogs_id")
  album          Album      @relation(fields: [albumId], references: [id], onDelete: Cascade)
  collection     Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  activities     Activity[]

  @@unique([collectionId, albumId])
  @@index([collectionId])
  @@index([albumId])
  @@index([collectionId, position])
  @@index([collectionId, discogsId])
}

model UserFollow {
  id         String   @id @default(cuid())
  followerId String
  followedId String
  createdAt  DateTime @default(now())
  followed   User     @relation("UserFollowers", fields: [followedId], references: [id], onDelete: Cascade)
  follower   User     @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)

  @@unique([followerId, followedId])
  @@index([followerId])
  @@index([followedId])
  @@map("user_follows")
}

// ============================================================================
// Activity Feed (Social Feed)
// ============================================================================

model Activity {
  id        String    @id @default(cuid())
  userId    String
  type      String    @db.VarChar(50) // 'follow', 'recommendation', 'collection_add', 'collection_remove'

  // Target references (nullable based on activity type)
  targetUserId      String?
  recommendationId  String?
  collectionAlbumId String?

  // Denormalized data for fast feed queries
  metadata  Json?

  // Timestamps
  createdAt DateTime  @default(now())
  deletedAt DateTime? // Soft delete for unfollows, removed recs, etc.

  // Relations
  user            User              @relation("ActivityActor", fields: [userId], references: [id], onDelete: Cascade)
  targetUser      User?             @relation("ActivityTarget", fields: [targetUserId], references: [id], onDelete: Cascade)
  recommendation  Recommendation?   @relation(fields: [recommendationId], references: [id], onDelete: SetNull)
  collectionAlbum CollectionAlbum?  @relation(fields: [collectionAlbumId], references: [id], onDelete: SetNull)

  // Indexes for feed queries
  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, deletedAt, createdAt(sort: Desc)])
  @@index([type, createdAt(sort: Desc)])
  @@index([targetUserId])
  @@index([recommendationId])
  @@index([collectionAlbumId])

  @@map("activities")
}

model UserActivity {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId        String?  @map("user_id")
  sessionId     String   @map("session_id") @db.VarChar(255)
  operation     String   @db.VarChar(100)
  operationType String   @map("operation_type") @db.VarChar(20)
  metadata      Json?    @map("metadata")
  albumIds      String[] @map("album_ids")
  artistIds     String[] @map("artist_ids")
  userAgent     String?  @map("user_agent")
  ipAddress     String?  @map("ip_address") @db.VarChar(45)
  requestId     String?  @map("request_id") @db.VarChar(255)
  timestamp     DateTime @default(now())

  @@index([userId, timestamp])
  @@index([sessionId, timestamp])
  @@index([operation])
  @@index([timestamp])
  @@map("user_activities")
}

model Artist {
  id               String                   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  musicbrainzId    String?                  @unique @map("musicbrainz_id") @db.Uuid
  spotifyId        String?                  @unique @map("spotify_id")
  discogsId        String?                  @map("discogs_id") @db.VarChar(20)
  name             String                   @db.VarChar(255)
  biography        String?
  formedYear       Int?                     @map("formed_year")
  countryCode      String?                  @map("country_code") @db.VarChar(2)
  area             String?                  @map("area") @db.VarChar(100)
  artistType       String?                  @map("artist_type") @db.VarChar(20)
  genres           String[]                 @map("genres")
  imageUrl         String?                  @map("image_url")
  cloudflareImageId String?                 @map("cloudflare_image_id")
  searchVector     Unsupported("tsvector")? @map("search_vector")
  source           ContentSource            @default(MUSICBRAINZ)
  sourceUrl        String?                  @map("source_url")
  submittedBy      String?                  @map("submitted_by") @db.Uuid
  dataQuality      DataQuality?             @default(LOW) @map("data_quality")
  enrichmentStatus EnrichmentStatus?        @default(PENDING) @map("enrichment_status")
  lastEnriched     DateTime?                @map("last_enriched")
  createdAt        DateTime                 @default(now()) @map("created_at")
  updatedAt        DateTime                 @updatedAt @map("updated_at")
  albums           AlbumArtist[]
  tracks           TrackArtist[]
  llamaLogs        LlamaLog[]

  @@index([name])
  @@index([musicbrainzId])
  @@index([searchVector], type: Gin)
  @@index([source])
  @@map("artists")
}

model Album {
  id                    String                   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  musicbrainzId         String?                  @unique @map("musicbrainz_id") @db.Uuid
  title                 String                   @db.VarChar(255)
  releaseDate           DateTime?                @map("release_date") @db.Date
  releaseType           String?                  @map("release_type") @db.VarChar(50)
  releaseStatus         String?                  @map("release_status") @db.VarChar(20)
  releaseCountry        String?                  @map("release_country") @db.VarChar(2)
  genres                String[]                 @map("genres")
  secondaryTypes        String[]                 @map("secondary_types")
  trackCount            Int?                     @map("track_count")
  durationMs            Int?                     @map("duration_ms")
  coverArtUrl           String?                  @map("cover_art_url")
  cloudflareImageId     String?                  @map("cloudflare_image_id")
  barcode               String?                  @db.VarChar(50)
  label                 String?                  @db.VarChar(255)
  catalogNumber         String?                  @map("catalog_number") @db.VarChar(100)
  searchVector          Unsupported("tsvector")? @map("search_vector")
  spotifyId             String?                  @unique @map("spotify_id") @db.VarChar(50)
  spotifyUrl            String?                  @map("spotify_url")
  discogsId             String?                  @map("discogs_id") @db.VarChar(20)
  source                ContentSource            @default(MUSICBRAINZ)
  sourceUrl             String?                  @map("source_url")
  submittedBy           String?                  @map("submitted_by") @db.Uuid
  dataQuality           DataQuality?             @default(LOW) @map("data_quality")
  enrichmentStatus      EnrichmentStatus?        @default(PENDING) @map("enrichment_status")
  lastEnriched          DateTime?                @map("last_enriched")
  metadata              Json?                    // Sync tracking - see src/types/album-metadata.ts for structure
  gameStatus            AlbumGameStatus       @default(NONE) @map("game_status")
  createdAt             DateTime                 @default(now()) @map("created_at")
  updatedAt             DateTime                 @updatedAt @map("updated_at")
  collectionAlbums      CollectionAlbum[]
  basisRecommendations  Recommendation[]         @relation("BasisAlbum")
  targetRecommendations Recommendation[]         @relation("RecommendedAlbum")
  artists               AlbumArtist[]
  tracks                Track[]
  llamaLogs             LlamaLog[]
  uncoverChallenges  UncoverChallenge[]
  uncoverGuesses     UncoverGuess[]

  @@index([title])
  @@index([releaseDate])
  @@index([musicbrainzId])
  @@index([searchVector], type: Gin)
  @@index([source])
  @@map("albums")
}

model Track {
  id               String                   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  albumId          String                   @map("album_id") @db.Uuid
  musicbrainzId    String?                  @map("musicbrainz_id") @db.Uuid
  isrc             String?                  @db.VarChar(12)
  title            String                   @db.VarChar(255)
  trackNumber      Int                      @map("track_number")
  discNumber       Int                      @default(1) @map("disc_number")
  durationMs       Int?                     @map("duration_ms")
  explicit         Boolean                  @default(false)
  previewUrl       String?                  @map("preview_url")
  spotifyId        String?                  @unique @map("spotify_id") @db.VarChar(50)
  spotifyUrl       String?                  @map("spotify_url")
  youtubeUrl       String?                  @map("youtube_url")
  discogsReleaseId String?                  @map("discogs_release_id") @db.VarChar(20)
  discogsPosition  String?                  @map("discogs_position") @db.VarChar(10)
  source           ContentSource            @default(MUSICBRAINZ)
  sourceUrl        String?                  @map("source_url")
  submittedBy      String?                  @map("submitted_by") @db.Uuid
  dataQuality      DataQuality              @default(LOW) @map("data_quality")
  enrichmentStatus EnrichmentStatus         @default(PENDING) @map("enrichment_status")
  lastEnriched     DateTime?                @map("last_enriched")
  energy           Float?
  valence          Float?
  danceability     Float?
  tempo            Float?
  acousticness     Float?
  instrumentalness Float?
  liveness         Float?
  loudness         Float?
  speechiness      Float?
  key              Int?                     @map("key_signature")
  mode             Int?
  timeSignature    Int?                     @map("time_signature")
  searchVector     Unsupported("tsvector")? @map("search_vector")
  createdAt        DateTime                 @default(now()) @map("created_at")
  updatedAt        DateTime                 @updatedAt @map("updated_at")
  artists          TrackArtist[]
  album            Album                    @relation(fields: [albumId], references: [id], onDelete: Cascade)
  llamaLogs        LlamaLog[]

  @@unique([albumId, musicbrainzId])
  @@index([albumId, discNumber, trackNumber])
  @@index([title])
  @@index([isrc])
  @@index([searchVector], type: Gin)
  @@index([source])
  @@index([discogsReleaseId, discogsPosition])
  @@map("tracks")
}

model AlbumArtist {
  albumId  String @map("album_id") @db.Uuid
  artistId String @map("artist_id") @db.Uuid
  role     String @default("primary") @db.VarChar(50)
  position Int    @default(0)
  album    Album  @relation(fields: [albumId], references: [id], onDelete: Cascade)
  artist   Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@id([albumId, artistId, role])
  @@index([albumId])
  @@index([artistId])
  @@map("album_artists")
}

model TrackArtist {
  trackId  String @map("track_id") @db.Uuid
  artistId String @map("artist_id") @db.Uuid
  role     String @default("primary") @db.VarChar(50)
  position Int    @default(0)
  artist   Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)
  track    Track  @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@id([trackId, artistId, role])
  @@index([trackId])
  @@index([artistId])
  @@map("track_artists")
}

model CacheData {
  id        String   @id @default(cuid())
  key       String   @unique
  data      Json
  expires   DateTime
  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([key, expires])
  @@map("cache_data")
}

// ============================================================================
// LlamaLog - Entity Provenance & Audit System (renamed from EnrichmentLog)
// ============================================================================

enum LlamaLogCategory {
  CREATED      // Entity was created (first appearance in database)
  ENRICHED     // Entity was enriched with external API data
  CORRECTED    // Entity was manually corrected by admin
  CACHED       // Cache operation (read/write)
  FAILED       // Operation failed
  LINKED       // Entity was linked/associated with existing entity
  USER_ACTION  // User-initiated action (add to collection, create recommendation, etc.)
}

model LlamaLog {
  id                 String                 @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  entityType         EnrichmentEntityType?  @map("entity_type")
  entityId           String?                @map("entity_id") @db.Uuid
  artistId           String?                @map("artist_id") @db.Uuid
  albumId            String?                @map("album_id") @db.Uuid
  trackId            String?                @map("track_id") @db.Uuid
  operation          String                 @db.VarChar(100)
  category           LlamaLogCategory       // Categorizes the type of log entry
  sources            String[]
  status             EnrichmentStatus
  reason             String?                // Human-readable explanation of why this enrichment occurred/was skipped
  fieldsEnriched     String[]               @map("fields_enriched")
  dataQualityBefore  DataQuality?           @map("data_quality_before")
  dataQualityAfter   DataQuality?           @map("data_quality_after")
  errorMessage       String?                @map("error_message")
  errorCode          String?                @map("error_code") @db.VarChar(50)
  retryCount         Int                    @default(0) @map("retry_count")
  durationMs         Int?                   @map("duration_ms")
  apiCallCount       Int                    @default(0) @map("api_call_count")
  metadata           Json?
  previewData        Json?                  @map("preview_data") // Stores raw API response and field diffs for preview enrichments
  jobId              String?                @map("job_id") @db.VarChar(100)
  parentJobId        String?                @map("parent_job_id") @db.VarChar(100)
  rootJobId          String?                @map("root_job_id") @db.VarChar(100) // Root job ID for hierarchy queries
  isRootJob          Boolean                @default(false) @map("is_root_job")
  triggeredBy        String?                @map("triggered_by") @db.VarChar(50)
  userId             String?                @map("user_id") // Track which user made manual changes
  createdAt          DateTime               @default(now()) @map("created_at")
  artist             Artist?                @relation(fields: [artistId], references: [id], onDelete: Cascade)
  album              Album?                 @relation(fields: [albumId], references: [id], onDelete: Cascade)
  track              Track?                 @relation(fields: [trackId], references: [id], onDelete: Cascade)
  user               User?                  @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([entityType, entityId])
  @@index([artistId, createdAt])
  @@index([albumId, createdAt])
  @@index([trackId, createdAt])
  @@index([status, createdAt])
  @@index([operation])
  @@index([sources])
  @@index([userId])
  @@index([parentJobId])
  @@index([rootJobId])
  @@index([isRootJob, createdAt])
  @@index([category, createdAt])
  @@map("llama_logs")
}

enum ContentSource {
  DISCOGS
  MUSICBRAINZ
  SPOTIFY
  YOUTUBE
  BANDCAMP
  SOUNDCLOUD
  USER_SUBMITTED
}

enum DataQuality {
  LOW
  MEDIUM
  HIGH
}

enum EnrichmentStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  SUCCESS
  PARTIAL_SUCCESS
  NO_DATA_AVAILABLE
  SKIPPED
  PREVIEW
}

enum EnrichmentEntityType {
  ARTIST
  ALBUM
  TRACK
}

enum AlbumGameStatus {
  ELIGIBLE   // Approved for game pool
  EXCLUDED   // Explicitly blocked from pool
  NONE       // Neutral, not yet reviewed (default)
}

enum UserRole {
  USER
  MODERATOR
  ADMIN
  OWNER
}

// ============================================================================
// Sync Job Tracking
// ============================================================================

enum SyncJobType {
  SPOTIFY_NEW_RELEASES
  SPOTIFY_FEATURED_PLAYLISTS
  MUSICBRAINZ_NEW_RELEASES
  MUSICBRAINZ_SYNC
  DISCOGS_SYNC
  ENRICHMENT_BATCH
}

enum SyncJobStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

enum UncoverSessionStatus {
  IN_PROGRESS
  WON
  LOST
}

model SyncJob {
  id              String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  jobId           String        @unique @map("job_id") @db.VarChar(100) // BullMQ job ID for linking
  jobType         SyncJobType   @map("job_type")
  status          SyncJobStatus @default(PENDING)
  
  // Timing
  startedAt       DateTime      @default(now()) @map("started_at")
  completedAt     DateTime?     @map("completed_at")
  durationMs      Int?          @map("duration_ms")
  
  // Results
  albumsCreated   Int           @default(0) @map("albums_created")
  albumsUpdated   Int           @default(0) @map("albums_updated")
  albumsSkipped   Int           @default(0) @map("albums_skipped")
  artistsCreated  Int           @default(0) @map("artists_created")
  artistsUpdated  Int           @default(0) @map("artists_updated")
  
  // Error tracking
  errorMessage    String?       @map("error_message")
  errorCode       String?       @map("error_code") @db.VarChar(50)
  
  // Metadata (query params, filters, etc.)
  metadata        Json?         // Stores: query, genreTags, year, country, limit, etc.
  
  // Audit
  triggeredBy     String?       @map("triggered_by") @db.VarChar(50) // 'scheduled', 'manual', 'graphql'
  
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @updatedAt @map("updated_at")

  @@index([jobType, status])
  @@index([status, startedAt])
  @@index([startedAt])
  @@index([jobId])
  @@map("sync_jobs")
}

// ============================================================================
// Uncover â€” Daily Album Art Game
// ============================================================================

/// Daily challenge - one album per day for all players
model UncoverChallenge {
  id            String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  date          DateTime  @unique @db.Date
  albumId       String    @map("album_id") @db.Uuid
  album         Album     @relation(fields: [albumId], references: [id], onDelete: Cascade)
  
  maxAttempts   Int       @default(6) @map("max_attempts")
  totalPlays    Int       @default(0) @map("total_plays")
  totalWins     Int       @default(0) @map("total_wins")
  avgAttempts   Float?    @map("avg_attempts")
  
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  
  sessions      UncoverSession[]
  
  @@index([date])
  @@index([albumId])
  @@map("uncover_challenges")
}

/// Player's session for a specific daily challenge
model UncoverSession {
  id              String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  challengeId     String                @map("challenge_id") @db.Uuid
  userId          String?               @map("user_id")
  
  status          UncoverSessionStatus  @default(IN_PROGRESS)
  attemptCount    Int                   @default(0) @map("attempt_count")
  won             Boolean               @default(false)
  completedAt     DateTime?             @map("completed_at")
  revealedHints   String[]              @default([]) @map("revealed_hints")
  
  startedAt       DateTime              @default(now()) @map("started_at")
  
  challenge       UncoverChallenge      @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  user            User?                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  guesses         UncoverGuess[]
  
  @@unique([challengeId, userId])
  @@index([userId])
  @@index([challengeId])
  @@index([status])
  @@map("uncover_sessions")
}

/// Individual guess within a session
model UncoverGuess {
  id              String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sessionId       String          @map("session_id") @db.Uuid
  guessNumber     Int             @map("guess_number")
  
  guessedAlbumId  String?         @map("guessed_album_id") @db.Uuid
  guessedText     String?         @map("guessed_text")
  isCorrect       Boolean         @default(false) @map("is_correct")
  
  guessedAt       DateTime        @default(now()) @map("guessed_at")
  
  session         UncoverSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  guessedAlbum    Album?          @relation(fields: [guessedAlbumId], references: [id], onDelete: SetNull)
  
  @@unique([sessionId, guessNumber])
  @@index([sessionId])
  @@map("uncover_guesses")
}

/// Player stats aggregate (denormalized for fast lookup)
model UncoverPlayerStats {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId          String    @unique @map("user_id")
  
  gamesPlayed     Int       @default(0) @map("games_played")
  gamesWon        Int       @default(0) @map("games_won")
  totalAttempts   Int       @default(0) @map("total_attempts")
  
  currentStreak   Int       @default(0) @map("current_streak")
  maxStreak       Int       @default(0) @map("max_streak")
  lastPlayedDate  DateTime? @db.Date @map("last_played_date")
  
  winDistribution Int[]     @default([0,0,0,0,0,0]) @map("win_distribution")
  
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([currentStreak(sort: Desc)])
  @@map("uncover_player_stats")
}
